<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmos - Curso de Informática</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #F2F2F2;
            color: #333;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 5px 20px;
        }

        header {
            text-align: center;
            padding: 40px 20px;
            background: #5c6d82;
            border-bottom: 5.5px solid #273E74;
            margin-bottom: 30px;
            color: white;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        select:focus {
            outline: none;
            border: 2px solid #5c6d82 !important;
        }

        select:disabled {
            cursor: not-allowed !important;
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            background: #dce1eb;
            outline: none;
            cursor: pointer;
            vertical-align: middle;
        }

        input[type="range"]:hover {
            background: #c4ccda;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 8px;
            background: linear-gradient(90deg, #5c6d82, #273E74);
        }

        input[type="range"]::-moz-range-track {
            height: 8px;
            background: linear-gradient(90deg, #5c6d82, #273E74);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #ffffff;
            border: 2px solid #273E74;
            margin-top: -5px;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #ffffff;
            border: 2px solid #273E74;
        }

        input[type="range"]:disabled {
            cursor: not-allowed;
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .section {
            background: white;
            border: 2.3px solid #273E74;
            padding: 30px;
            margin-bottom: 30px;
        }

        h2 {
            font-size: 1.8em;
            margin-bottom: 20px;
            color: #273E74;
            border-bottom: 2px solid #5c6d82;
            padding-bottom: 10px;
        }

        .info-box {
            background: #f2f2f2;
            padding: 15px;
            border-left: 4px solid #5c6d82;
            margin: 15px 0;
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            background: white;
            padding: 20px;
            border: 2px solid #273E74;
        }

        canvas {
            border: 1px solid #ccc;
            background: white;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        button {
            background: #5c6d82;
            border: 2px solid #273E74;
            color: white;
            padding: 10px 20px;
            font-family: Arial, sans-serif;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            font-size: 1em;
        }

        button:hover {
            background: #273E74;
        }

        button:disabled {
            background: #999;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
        }

        .stat-box {
            background: #f9f9f9;
            border: 2px solid #273E74;
            padding: 15px;
            min-width: 150px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #273E74;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }

        .speed-control label {
            font-weight: bold;
            color: #273E74;
        }

        input[type="range"] {
            width: 200px;
            cursor: pointer;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin: 15px 0;
            padding: 15px;
            background: #f9f9f9;
            border: 1px solid #ddd;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 30px;
            height: 20px;
            border: 1px solid #333;
        }

        #indexBtn {
            margin-top: 15px;
            background: white;
            color: #273E74;
            border: 3.3px solid #273E74;
            padding: 9px 12px;
            font-size: 1.025rem;
        }

        #indexBtn:hover {
            background-color: #273E74;
            color: white;
            border: 3.3px solid white;
        }

        .array-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 5px;
            margin: 20px 0;
            padding: 20px;
            background: #f9f9f9;
            border: 2px solid #273E74;
        }

        .array-bar {
            background: #5c6d82;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
            min-width: 30px;
            transition: all 0.3s;
            border: 1px solid #273E74;
        }

        .array-bar.comparing {
            background: #ff9800;
        }

        .array-bar.swapping {
            background: #f44336;
        }

        .array-bar.sorted {
            background: #4CAF50;
        }

        .array-bar.pivot {
            background: #9C27B0;
        }

        @media (max-width: 1200px) {
            h1 { font-size: 1.8em; }
            h2 { font-size: 1.4em; }
            canvas { max-width: 100%; height: auto; }
            .stat-box { min-width: 120px; }
            input[type="range"] { width: 150px; }
        }

        @media (max-width: 480px) {
            .controls { flex-direction: column; }
            button { width: 100%; }
            .array-bar { min-width: 20px; font-size: 0.7em; }
            select { width: 100%; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Algoritmos</h1>
        <p class="subtitle">Visualização interativa de algoritmos clássicos</p>
        <button id="indexBtn" onclick="window.location.href='/'">Página Inicial</button>
    </header>

    <div class="container">
        <!-- Introdução -->
        <div class="section">
            <h2>00. O QUE SÃO ALGORITMOS? (Introdução)</h2>

            <p>
                Algoritmos são <strong>sequências de passos bem definidos</strong> usadas para resolver
                problemas ou executar tarefas. Eles dizem exatamente <em>o que fazer</em>,
                <em>em que ordem</em> e <em>quando parar</em>.
            </p>

            <div class="info-box">
                <strong>Ideia central:</strong><br>
                Um computador não pensa — ele apenas segue algoritmos.
            </div>

            <p>
                Algoritmos estão presentes em diversas situações do dia a dia, como:
                rotas de GPS, buscas na Internet, jogos, redes sociais e sistemas de recomendação.
            </p>

            <div class="info-box">
                <strong>Todo algoritmo possui:</strong><br>
                • Entrada (dados iniciais)<br>
                • Processamento (regras e decisões)<br>
                • Saída (resultado)<br>
                • Fim (não pode executar indefinidamente)
            </div>

            <p>
                Programar é transformar algoritmos em código. As linguagens de programação
                são apenas diferentes formas de escrever os mesmos algoritmos.
            </p>

            <h3 style="color:#273E74; margin-top:15px; margin-bottom: 15px;">
                Um Algoritmo Simples em Ação (Busca Linear)
            </h3>

            <p>
                O algoritmo percorre os elementos um a um até encontrar o valor desejado.
            </p>

            <div class="canvas-container">   
                <canvas id="linearCanvas" width="720" height="180"></canvas>
            </div>

            <p id="linearCanvasStatus" style="font-weight:bold; text-align: center;"></p>

            <div class="controls">
                <button onclick="startLinearCanvas()" id="startLinearSearch">Iniciar</button>
                <button onclick="resetLinearCanvas()">Resetar</button>
            </div>

            <div class="legend" style="margin-bottom: 0px;">
                <div class="legend-item">
                    <div class="legend-color" style="background: #d1ecff;"></div>
                    <span>Valor Desejado</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9800;"></div>
                    <span>Ponteiro de Busca</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Valor Encontrado</span>
                </div>
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Objetivo desta página:</strong><br>
                Visualizar algoritmos clássicos passo a passo para facilitar a compreensão
                de como eles funcionam internamente.
            </div>
        </div>

        <!-- Bubble Sort -->
        <div class="section">
            <h2>01. BUBBLE SORT (Ordenação por Bolha)</h2>
            <p>O Bubble Sort compara elementos adjacentes e os troca se estiverem na ordem errada. O processo se repete até que não haja mais trocas necessárias.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(n²) no pior caso<br>
                <strong>Conceito:</strong> Elementos maiores "flutuam" para o final como bolhas
            </div>

            <div class="array-container" id="bubbleArray"></div>

            <div class="controls">
                <button onclick="generateBubbleArray()">Gerar Novo Array</button>
                <button onclick="startBubbleSort()" id="bubbleStart">Iniciar Ordenação</button>
                <button onclick="resetBubbleSort()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="bubbleSpeed" min="10" max="1000" value="500" step="10">
                <span id="bubbleSpeedValue">500ms</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Comparações</div>
                    <div class="stat-value" id="bubbleComparisons">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Trocas</div>
                    <div class="stat-value" id="bubbleSwaps">0</div>
                </div>
            </div>

            <div class="legend" style="margin-bottom: 0px;">
                <div class="legend-item">
                    <div class="legend-color" style="background: #5c6d82;"></div>
                    <span>Não ordenado</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9800;"></div>
                    <span>Comparando</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>Trocando</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Ordenado</span>
                </div>
            </div>
        </div>

        <!-- Binary Search -->
        <div class="section">
            <h2>02. BINARY SEARCH (Busca Binária)</h2>
            <p>A busca binária divide repetidamente o array ao meio, eliminando metade dos elementos a cada iteração. Funciona apenas em arrays ordenados.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(log n)<br>
                <strong>Pré-requisito:</strong> Array deve estar ordenado<br>
                <strong>Conceito:</strong> Divide e conquista
            </div>

            <div class="canvas-container">
                <canvas id="binaryCanvas" width="800" height="200"></canvas>
            </div>

            <div class="controls">
                <button onclick="generateBinaryArray()">Gerar Novo Array</button>
                <button onclick="startBinarySearch()" id="binaryStart">Buscar Elemento</button>
                <button onclick="resetBinarySearch()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="binarySpeed" min="300" max="2000" value="1000" step="100">
                <span id="binarySpeedValue">1000ms</span>
            </div>

            <div class="stats" style="margin-bottom: 0px;">
                <div class="stat-box">
                    <div class="stat-label">Elemento Buscado</div>
                    <div class="stat-value" id="binaryTarget">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Iterações</div>
                    <div class="stat-value" id="binaryIterations">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Status</div>
                    <div class="stat-value" id="binaryStatus">-</div>
                </div>
            </div>
        </div>

        <!-- Dijkstra -->
        <div class="section">
            <h2>03. DIJKSTRA (Menor Caminho)</h2>
            <p>O algoritmo de Dijkstra encontra o caminho mais curto entre dois pontos em um grafo ponderado. Clique para adicionar/remover paredes.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O((V + E) log V)<br>
                <strong>Aplicação:</strong> GPS, roteamento de redes, jogos<br>
                <strong>Conceito:</strong> Explora caminhos do mais curto ao mais longo
            </div>

            <div class="canvas-container">
                <canvas id="dijkstraCanvas" width="600" height="400"></canvas>
            </div>

            <div class="controls">
                <button onclick="clearDijkstraWalls()">Limpar Paredes</button>
                <button onclick="startDijkstra()" id="dijkstraStart">Encontrar Caminho</button>
                <button onclick="resetDijkstra()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="dijkstraSpeed" min="10" max="500" value="50" step="10">
                <span id="dijkstraSpeedValue">50ms</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Células Visitadas</div>
                    <div class="stat-value" id="dijkstraVisited">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Distância do Caminho</div>
                    <div class="stat-value" id="dijkstraDistance">0</div>
                </div>
            </div>

            <div class="legend" style="margin-bottom: 0px;">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Início</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>Fim</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #333;"></div>
                    <span>Parede</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #64B5F6;"></div>
                    <span>Visitado</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700;"></div>
                    <span>Caminho</span>
                </div>
            </div>
        </div>

        <!-- N-Queens Backtracking -->
        <div class="section">
            <h2>04. N-QUEENS (Backtracking)</h2>
            <p>O problema das N-Rainhas usa backtracking para posicionar N rainhas em um tabuleiro NxN sem que se ataquem.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(N!)<br>
                <strong>Técnica:</strong> Backtracking (tentativa e erro inteligente)<br>
                <strong>Conceito:</strong> Explora possibilidades e volta atrás quando necessário
            </div>

            <div class="canvas-container">
                <canvas id="queensCanvas" width="400" height="400"></canvas>
            </div>

            <div class="controls">
                <button onclick="startQueens()" id="queensStart">Resolver</button>
                <button onclick="resetQueens()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="queensSpeed" min="50" max="1000" value="200" step="50">
                <span id="queensSpeedValue">200ms</span>
            </div>

            <div class="stats" style="margin-bottom: 0px;">
                <div class="stat-box">
                    <div class="stat-label">Tentativas</div>
                    <div class="stat-value" id="queensAttempts">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Backtracks</div>
                    <div class="stat-value" id="queensBacktracks">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Rainhas Colocadas</div>
                    <div class="stat-value" id="queensPlaced">0</div>
                </div>
            </div>
        </div>

        <!-- Fractals -->
        <div class="section">
            <h2>05. FRACTAIS (Padrões Recursivos)</h2>
            <p>Fractais são padrões geométricos que se repetem em diferentes escalas. Cada iteração adiciona mais detalhes ao desenho através de recursão.</p>
            
            <div class="info-box">
                <strong>Conceito:</strong> Auto-similaridade - o padrão se repete em escalas menores<br>
                <strong>Técnica:</strong> Recursão matemática<br>
                <strong>Aplicações:</strong> Computação gráfica, compressão de imagens, natureza
            </div>

            <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin: 20px 0;">
                <div style="flex: 1; min-width: 300px;">
                    <h3 style="text-align: center; color: #273E74; margin-bottom: 15px;">Triângulo de Sierpinski</h3>
                    <div class="canvas-container">
                        <canvas id="sierpinskiCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="controls">
                        <button onclick="startSierpinski()" id="sierpinskiStart">Desenhar</button>
                        <button onclick="resetSierpinski()">Resetar</button>
                    </div>
                    <div class="speed-control">
                        <label>Nível:</label>
                        <input type="range" id="sierpinskiLevel" min="0" max="7" value="5" step="1">
                        <span id="sierpinskiLevelValue">5</span>
                    </div>
                </div>

                <div style="flex: 1; min-width: 300px;">
                    <h3 style="text-align: center; color: #273E74; margin-bottom: 15px;">Floco de Neve de Koch</h3>
                    <div class="canvas-container">
                        <canvas id="kochCanvas" width="400" height="350"></canvas>
                    </div>
                    <div class="controls">
                        <button onclick="startKoch()" id="kochStart">Desenhar</button>
                        <button onclick="resetKoch()">Resetar</button>
                    </div>
                    <div class="speed-control">
                        <label>Nível:</label>
                        <input type="range" id="kochLevel" min="0" max="6" value="4" step="1">
                        <span id="kochLevelValue">4</span>
                    </div>
                </div>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Triângulos (Sierpinski)</div>
                    <div class="stat-value" id="sierpinskiTriangles">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Segmentos (Koch)</div>
                    <div class="stat-value" id="kochSegments">0</div>
                </div>
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidade:</strong> O Triângulo de Sierpinski tem área zero mas perímetro infinito! O Floco de Koch tem perímetro infinito mas área finita.
            </div>
        </div>

        <!-- Maze Generation -->
        <div class="section">
            <h2>06. MAZE GENERATION (Geração de Labirinto)</h2>
            <p>O algoritmo de Recursive Backtracking cria labirintos perfeitos "escavando" caminhos através de uma grade. Cada labirinto tem um caminho único entre quaisquer dois pontos.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(n × m) onde n e m são as dimensões da grade<br>
                <strong>Técnica:</strong> Backtracking com pilha (DFS)<br>
                <strong>Resultado:</strong> Labirinto perfeito (sem loops, sem áreas isoladas)
            </div>

            <div class="canvas-container">
                <canvas id="mazeCanvas" width="600" height="600"></canvas>
            </div>

            <div class="controls">
                <button onclick="generateMaze()" id="mazeStart">Gerar Labirinto</button>
                <button onclick="resetMaze()">Resetar</button>
                <button onclick="solveMaze()" id="mazeSolve">Resolver Labirinto</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="mazeSpeed" min="1" max="100" value="20" step="1">
                <span id="mazeSpeedValue">20ms</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Células Visitadas</div>
                    <div class="stat-value" id="mazeVisited">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Backtracks</div>
                    <div class="stat-value" id="mazeBacktracks">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Tamanho da Grade</div>
                    <div class="stat-value" id="mazeSize">25×25</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #333;"></div>
                    <span>Parede</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: white;"></div>
                    <span>Caminho</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #5c6d82;"></div>
                    <span>Explorando</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Início</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>Fim</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700;"></div>
                    <span>Solução</span>
                </div>
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Como funciona:</strong> O algoritmo começa em uma célula aleatória e "escava" caminhos escolhendo direções não visitadas. Quando não há mais direções disponíveis, ele volta atrás (backtrack) até encontrar uma célula com vizinhos não visitados.
            </div>
        </div>

        <!-- Convex Hull -->
        <div class="section">
            <h2>07. CONVEX HULL (Envoltório Convexo - Graham Scan)</h2>
            <p>O algoritmo de Graham Scan encontra o menor polígono convexo que envolve todos os pontos de um conjunto. É como colocar um elástico em volta de pregos espalhados.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(n log n) devido à ordenação inicial<br>
                <strong>Técnica:</strong> Ordenação polar + verificação de orientação<br>
                <strong>Aplicações:</strong> Computação gráfica, visão computacional, GIS
            </div>

            <div class="canvas-container">
                <canvas id="convexCanvas" width="600" height="500"></canvas>
            </div>

            <div class="controls">
                <button onclick="generateConvexPoints()">Gerar Pontos</button>
                <button onclick="startConvexHull()" id="convexStart">Encontrar Envoltório</button>
                <button onclick="resetConvex()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="convexSpeed" min="100" max="2000" value="500" step="100">
                <span id="convexSpeedValue">500ms</span>
            </div>

            <div class="speed-control">
                <label>Número de Pontos:</label>
                <input type="range" id="convexPoints" min="5" max="50" value="20" step="1">
                <span id="convexPointsValue">20</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Total de Pontos</div>
                    <div class="stat-value" id="convexTotal">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Pontos no Envoltório</div>
                    <div class="stat-value" id="convexHullPoints">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Pontos Verificados</div>
                    <div class="stat-value" id="convexChecked">0</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #5c6d82;"></div>
                    <span>Pontos Internos</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>Ponto Âncora (mais baixo)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9800;"></div>
                    <span>Ponto Atual</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Pontos no Envoltório</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9C27B0; height: 3px; width: 30px;"></div>
                    <span>Polígono Final</span>
                </div>
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Como funciona:</strong> O algoritmo primeiro encontra o ponto mais baixo (âncora), ordena os outros pontos por ângulo polar, e então "varre" os pontos descartando aqueles que fazem curvas para dentro (não convexos).
            </div>
        </div>

        <!-- Flood Fill -->
        <div class="section">
            <h2>08. FLOOD FILL (Preenchimento)</h2>
            <p>O algoritmo Flood Fill preenche uma área conectada com uma nova cor, como a ferramenta "balde de tinta" em programas de desenho. Clique em qualquer célula para iniciar o preenchimento!</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(n × m) onde n e m são as dimensões da grade<br>
                <strong>Técnica:</strong> DFS (recursivo) ou BFS (fila)<br>
                <strong>Aplicações:</strong> Editores de imagem, jogos (campo minado), seleção de áreas
            </div>

            <div class="canvas-container">
                <canvas id="floodCanvas" width="600" height="600"></canvas>
            </div>

            <div class="controls">
                <button onclick="generateFloodPattern()">Gerar Padrão</button>
                <button onclick="clearFloodGrid()">Limpar Grade</button>
                <button onclick="resetFlood()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="floodSpeed" min="1" max="200" value="20" step="1">
                <span id="floodSpeedValue">20ms</span>
            </div>

            <div class="speed-control">
                <label>Modo:</label>
                <select id="floodMode" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="4">4 Direções (↑→↓←)</option>
                    <option value="8">8 Direções (↑↗→↘↓↙←↖)</option>
                </select>
            </div>

            <div class="speed-control">
                <label>Cor de Preenchimento:</label>
                <input type="color" id="floodColor" value="#5c6d82" style="width: 60px; height: 35px; border: 2px solid #273E74; cursor: pointer;">
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Células Preenchidas</div>
                    <div class="stat-value" id="floodFilled">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Células na Fila</div>
                    <div class="stat-value" id="floodQueue">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Modo Atual</div>
                    <div class="stat-value" id="floodModeDisplay">4 Dir</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: white;"></div>
                    <span>Vazio</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #333;"></div>
                    <span>Obstáculo</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9800;"></div>
                    <span>Processando</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #5c6d82;"></div>
                    <span>Preenchido</span>
                </div>
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Instruções:</strong> 
                <br>• Clique esquerdo em uma célula para preencher a área
                <br>• Clique direito para adicionar/remover obstáculos (antes de preencher)
                <br>• Experimente os dois modos para ver a diferença!
                <br>• 4 direções: apenas cima, baixo, esquerda, direita
                <br>• 8 direções: inclui diagonais
            </div>
        </div>

        <!-- Voronoi Diagram -->
        <div class="section">
            <h2>09. VORONOI DIAGRAM (Diagrama de Voronoi)</h2>
            <p>O Diagrama de Voronoi divide o espaço em regiões, onde cada região contém todos os pontos mais próximos de um ponto-semente específico. Cada pixel é colorido de acordo com qual semente está mais próxima.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(n log n) para construção otimizada<br>
                <strong>Conceito:</strong> Partição espacial baseada em proximidade<br>
                <strong>Aplicações:</strong> Navegação, planejamento urbano, biologia celular, jogos
            </div>

            <div class="canvas-container">
                <canvas id="voronoiCanvas" width="600" height="600"></canvas>
            </div>

            <div class="controls">
                <button onclick="generateVoronoiSeeds()" id=voronoiSeed>Gerar Sementes</button>
                <button onclick="startVoronoi()" id="voronoiStart">Desenhar Diagrama</button>
                <button onclick="resetVoronoi()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Número de Sementes:</label>
                <input type="range" id="voronoiSeeds" min="3" max="30" value="10" step="1">
                <span id="voronoiSeedsValue">10</span>
            </div>

            <div class="speed-control">
                <label>Modo de Visualização:</label>
                <select id="voronoiMode" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="progressive">Progressivo (Animado)</option>
                    <option value="instant">Instantâneo (Rápido)</option>
                </select>
            </div>

            <div class="speed-control">
                <label>Mostrar Bordas:</label>
                <input type="checkbox" id="voronoiBorders" checked style="width: 20px; height: 20px; cursor: pointer;">
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Sementes</div>
                    <div class="stat-value" id="voronoiSeedCount">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Pixels Processados</div>
                    <div class="stat-value" id="voronoiPixels">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Progresso</div>
                    <div class="stat-value" id="voronoiProgress">0%</div>
                </div>
            </div>

            <div class="info-box">
                <strong>Como funciona:</strong> Para cada pixel da imagem, o algoritmo calcula a distância até todas as sementes e atribui o pixel à região da semente mais próxima. Cada região tem uma cor única.
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidade:</strong> O Diagrama de Voronoi aparece naturalmente em muitos fenômenos: células em tecidos biológicos, territórios de animais, áreas de influência de lojas, e até na formação de cristais!
            </div>
        </div>

        <!-- BFS Tree -->
        <div class="section">
            <h2>10. BFS TREE (Busca em Largura)</h2>
            <p>A Busca em Largura (BFS) explora um grafo/árvore nível por nível, visitando todos os vizinhos antes de avançar para o próximo nível. É como uma "onda" se expandindo a partir da raiz.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(V + E) onde V = vértices e E = arestas<br>
                <strong>Estrutura de Dados:</strong> Fila (FIFO - First In, First Out)<br>
                <strong>Aplicações:</strong> Menor caminho sem pesos, crawler web, redes sociais
            </div>

            <div class="canvas-container">
                <canvas id="bfsCanvas" width="800" height="600"></canvas>
            </div>

            <div class="controls">
                <button onclick="startBFSTraversal()" id="bfsStart">Iniciar BFS</button>
                <button onclick="resetBFS()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="bfsSpeed" min="100" max="2000" value="500" step="100">
                <span id="bfsSpeedValue">500ms</span>
            </div>

            <div class="speed-control">
                <label>Tipo de Grafo:</label>
                <select id="bfsGraphType" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="tree">Árvore Binária</option>
                    <option value="grid">Grade</option>
                </select>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Nível Atual</div>
                    <div class="stat-value" id="bfsLevel">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Nós Visitados</div>
                    <div class="stat-value" id="bfsVisited">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Nós na Fila</div>
                    <div class="stat-value" id="bfsQueue">0</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: white; border: 2px solid #333;"></div>
                    <span>Não Visitado</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #64B5F6;"></div>
                    <span>Na Fila</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9800;"></div>
                    <span>Processando</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Visitado</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>Raiz/Início</span>
                </div>
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>BFS vs DFS:</strong> Enquanto o DFS vai o mais fundo possível antes de voltar (usa pilha), o BFS explora todos os vizinhos do nível atual antes de avançar (usa fila). BFS garante o menor caminho em grafos não ponderados!
            </div>
        </div>

        <!-- Game of Life -->
        <div class="section">
            <h2>11. GAME OF LIFE (Jogo da Vida)</h2>
            <p>O Game of Life de John Conway é um autômato celular onde padrões complexos emergem de regras simples. Cada célula vive, morre ou nasce baseado em seus vizinhos.</p>
            
            <div class="info-box">
                <strong>Regras:</strong><br>
                1. Célula viva com 2-3 vizinhos vivos → sobrevive<br>
                2. Célula viva com menos de 2 ou mais de 3 vizinhos → morre<br>
                3. Célula morta com exatamente 3 vizinhos vivos → nasce<br>
                <strong>Aplicações:</strong> Teoria da computação, arte generativa, simulação
            </div>

            <div class="canvas-container">
                <canvas id="gameOfLifeCanvas" width="600" height="600"></canvas>
            </div>

            <div class="controls">
                <button onclick="toggleGameOfLife()" id="golToggle">Iniciar</button>
                <button onclick="stepGameOfLife()" id="stepGameOfLifeBtn">Próxima Geração</button>
                <button onclick="clearGameOfLife()">Limpar</button>
                <button onclick="randomizeGameOfLife()">Aleatório</button>
            </div>

            <div class="controls" style="margin-top: 10px;">
                <button onclick="loadGlider()">Glider</button>
                <button onclick="loadBlinker()">Blinker</button>
                <button onclick="loadToad()">Toad</button>
                <button onclick="loadBeacon()">Beacon</button>
                <button onclick="loadGliderGun()">Glider Gun</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="golSpeed" min="50" max="1000" value="200" step="50">
                <span id="golSpeedValue">200ms</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Geração</div>
                    <div class="stat-value" id="golGeneration">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Células Vivas</div>
                    <div class="stat-value" id="golAliveCells">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">População Máxima</div>
                    <div class="stat-value" id="golMaxPop">0</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: white;"></div>
                    <span>Célula Morta</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #5c6d82;"></div>
                    <span>Célula Viva</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Nasceu (nova)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>Morreu (última geração)</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Instruções:</strong> Clique nas células para ativá-las/desativá-las. Carregue padrões clássicos ou crie os seus próprios!
                <br><strong>Dica:</strong> O "Glider Gun" cria Gliders infinitamente!
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidade:</strong> O Game of Life é Turing-completo, o que significa que pode simular qualquer computador! Padrões podem funcionar como portas lógicas, memória e até computadores completos.
            </div>
        </div>

        <!-- Wave Function Collapse -->
        <div class="section">
            <h2>12. WAVE FUNCTION COLLAPSE (Colapso de Função de Onda)</h2>
            <p>O Wave Function Collapse é um algoritmo de geração procedural que cria padrões coerentes escolhendo possibilidades locais e propagando restrições. Cada célula "colapsa" de todas as possibilidades para uma única escolha.</p>
            
            <div class="info-box">
                <strong>Conceito:</strong> Inspirado na mecânica quântica (superposição → colapso)<br>
                <strong>Técnica:</strong> Backtracking com propagação de restrições<br>
                <strong>Aplicações:</strong> Geração de mapas, texturas, níveis de jogos, arte generativa
            </div>

            <div class="canvas-container">
                <canvas id="wfcCanvas" width="600" height="600"></canvas>
            </div>

            <div class="controls">
                <button onclick="startWFC()" id="wfcStart">Gerar Padrão</button>
                <button onclick="resetWFC()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="wfcSpeed" min="1" max="200" value="30" step="1">
                <span id="wfcSpeedValue">30ms</span>
            </div>

            <div class="speed-control">
                <label>Tipo de Padrão:</label>
                <select id="wfcPattern" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="simple">Simples (3 tiles)</option>
                    <option value="terrain">Terreno (5 tiles)</option>
                    <option value="pipes">Tubos (6 tiles)</option>
                </select>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Células Colapsadas</div>
                    <div class="stat-value" id="wfcCollapsed">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Entropia Mínima</div>
                    <div class="stat-value" id="wfcEntropy">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Progresso</div>
                    <div class="stat-value" id="wfcProgress">0%</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #f0f0f0;"></div>
                    <span>Não Colapsado (superposição)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9800;"></div>
                    <span>Colapsando Agora</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #64B5F6;"></div>
                    <span>Propagando Restrições</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Como funciona:</strong>
                <br>1. Todas as células começam em "superposição" (todas possibilidades)
                <br>2. Escolhe célula com menor entropia (menos possibilidades)
                <br>3. "Colapsa" para uma escolha aleatória válida
                <br>4. Propaga restrições para vizinhos (remove possibilidades inválidas)
                <br>5. Repete até todas células estarem colapsadas
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Padrões Disponíveis:</strong>
                <br>• <strong>Simples:</strong> Preto, branco e cinza com regras básicas
                <br>• <strong>Terreno:</strong> Água, areia, grama, floresta, montanha
                <br>• <strong>Tubos:</strong> Sistema de conexões (cria labirintos orgânicos)
            </div>
        </div>

        <!-- Mandelbrot & Julia Set -->
        <div class="section">
            <h2>13. FRACTAIS - MANDELBROT & JULIA SET</h2>
            <p>Os conjuntos de Mandelbrot e Julia são fractais complexos gerados por iterações de funções matemáticas no plano complexo. Cada pixel representa um número complexo e é colorido baseado em quantas iterações leva para "escapar".</p>
            
            <div class="info-box">
                <strong>Mandelbrot:</strong> z → z² + c (c varia, z₀ = 0)<br>
                <strong>Julia Set:</strong> z → z² + c (c fixo, z₀ varia)<br>
                <strong>Conceito:</strong> Iteração de números complexos, auto-similaridade infinita<br>
                <strong>Propriedade:</strong> Zoom infinito revela detalhes cada vez mais complexos
            </div>

            <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin: 20px 0;">
                <div style="flex: 1; min-width: 300px;">
                    <h3 style="text-align: center; color: #273E74; margin-bottom: 15px;">Mandelbrot Set</h3>
                    <div class="canvas-container">
                        <canvas id="mandelbrotCanvas" width="500" height="500"></canvas>
                    </div>
                    <div class="controls">
                        <button onclick="drawMandelbrot()" id="mandelbrotDraw">Desenhar</button>
                        <button onclick="resetMandelbrot()">Resetar Zoom</button>
                    </div>
                    <div class="speed-control">
                        <label>Iterações:</label>
                        <input type="range" id="mandelbrotIter" min="50" max="500" value="100" step="50">
                        <span id="mandelbrotIterValue">100</span>
                    </div>
                    <div class="speed-control">
                        <label>Esquema de Cores:</label>
                        <select id="mandelbrotColors" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                            <option value="rainbow">Arco-Íris</option>
                            <option value="fire">Fogo</option>
                            <option value="ocean">Oceano</option>
                            <option value="purple">Roxo</option>
                            <option value="grayscale">Escala de Cinza</option>
                            <option value="neon">Neon</option>
                        </select>
                    </div>
                    <p style="text-align: center; font-size: 0.9em; color: #666; margin-top: 10px;">
                        Clique para dar zoom!
                    </p>
                </div>

                <div style="flex: 1; min-width: 300px;">
                    <h3 style="text-align: center; color: #273E74; margin-bottom: 15px;">Julia Set</h3>
                    <div class="canvas-container">
                        <canvas id="juliaCanvas" width="500" height="500"></canvas>
                    </div>
                    <div class="controls">
                        <button onclick="drawJulia()" id="juliaDraw">Desenhar</button>
                        <button onclick="randomJuliaC()" id="randomJuliaDraw">Parâmetro Aleatório</button>
                        <button onclick="resetJulia()">Resetar Zoom</button>
                    </div>
                    <div class="speed-control">
                        <label>Iterações:</label>
                        <input type="range" id="juliaIter" min="50" max="500" value="100" step="50">
                        <span id="juliaIterValue">100</span>
                    </div>
                    <div class="speed-control">
                        <label>C Real:</label>
                        <input type="range" id="juliaCReal" min="-2" max="2" value="-0.7" step="0.01">
                        <span id="juliaCRealValue">-0.7</span>
                    </div>
                    <div class="speed-control">
                        <label>C Imaginário:</label>
                        <input type="range" id="juliaCImag" min="-2" max="2" value="0.27" step="0.01">
                        <span id="juliaCImagValue">0.27</span>
                    </div>
                    <div class="speed-control">
                        <label>Esquema de Cores:</label>
                        <select id="juliaColors" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                            <option value="rainbow">Arco-Íris</option>
                            <option value="fire">Fogo</option>
                            <option value="ocean">Oceano</option>
                            <option value="purple">Roxo</option>
                            <option value="grayscale">Escala de Cinza</option>
                            <option value="neon">Neon</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="stats" style="max-width: 100%;">
                <div class="stat-box">
                    <div class="stat-label">Status Mandelbrot</div>
                    <div class="stat-value" id="mandelbrotStatus" style="font-size: 1em;">Pronto</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Zoom Mandelbrot</div>
                    <div class="stat-value" id="mandelbrotZoom">1x</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Status Julia</div>
                    <div class="stat-value" id="juliaStatus" style="font-size: 1em;">Pronto</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Zoom Julia</div>
                    <div class="stat-value" id="juliaZoom">1x</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(90deg, #000033, #0066cc, #00ffff, #ffff00, #ff0000, #ffffff);"></div>
                    <span>Gradiente de Escape (preto = dentro do conjunto)</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Como funcionam:</strong>
                <br>• Para cada pixel (x,y), converte para número complexo
                <br>• Itera z → z² + c até |z| > 2 ou atingir max iterações
                <br>• Cor baseada em quantas iterações levou para escapar
                <br>• Preto = não escapou (dentro do conjunto)
            </div>

            <div class="info-box">
                <strong>Interatividade:</strong>
                <br>• <strong>Mandelbrot:</strong> Clique em qualquer lugar para dar zoom naquela região!
                <br>• <strong>Julia:</strong> Ajuste os sliders para explorar diferentes conjuntos de Julia
                <br>• <strong>Dica:</strong> Aumente iterações para mais detalhes (mas demora mais)
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidade Matemática:</strong> O conjunto de Mandelbrot tem área finita (≈1.506) mas perímetro infinito! Além disso, todo conjunto de Julia está "codificado" no Mandelbrot - cada ponto do Mandelbrot corresponde a um Julia Set específico.
            </div>
        </div>

        <!-- Quick Sort -->
        <div class="section">
            <h2>14. QUICK SORT (Ordenação Rápida)</h2>
            <p>O Quick Sort escolhe um pivô e particiona o array, colocando elementos menores à esquerda e maiores à direita, recursivamente.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(n log n) em média, O(n²) no pior caso<br>
                <strong>Técnica:</strong> Divide e conquista<br>
                <strong>Conceito:</strong> Particiona o array em torno de um pivô
            </div>

            <div class="canvas-container">
                <canvas id="quickCanvas" width="800" height="300"></canvas>
            </div>

            <div class="controls">
                <button onclick="generateQuickArray()">Gerar Novo Array</button>
                <button onclick="startQuickSort()" id="quickStart">Iniciar Ordenação</button>
                <button onclick="resetQuickSort()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="quickSpeed" min="50" max="1000" value="300" step="50">
                <span id="quickSpeedValue">300ms</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Comparações</div>
                    <div class="stat-value" id="quickComparisons">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Trocas</div>
                    <div class="stat-value" id="quickSwaps">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Recursões</div>
                    <div class="stat-value" id="quickRecursions">0</div>
                </div>
            </div>

            <div class="legend" style="margin-bottom: 0px;">
                <div class="legend-item">
                    <div class="legend-color" style="background: #5c6d82;"></div>
                    <span>Não ordenado</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9C27B0;"></div>
                    <span>Pivô</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9800;"></div>
                    <span>Comparando</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Ordenado</span>
                </div>
            </div>
        </div>

        <!-- Linear Regression -->
        <div class="section">
            <h2>15. REGRESSÃO LINEAR (Machine Learning)</h2>
            <p>A Regressão Linear é um algoritmo fundamental de Machine Learning que encontra a melhor linha reta para prever valores baseado em dados. Usa o método de Gradiente Descendente para minimizar o erro.</p>
            
            <div class="info-box">
                <strong>Objetivo:</strong> Encontrar y = mx + b que melhor se ajusta aos dados<br>
                <strong>Técnica:</strong> Gradiente Descendente (ajusta m e b iterativamente)<br>
                <strong>Métrica:</strong> MSE (Mean Squared Error) - erro médio quadrático<br>
                <strong>Aplicações:</strong> Previsões, análise de tendências, ciência de dados
            </div>

            <div class="canvas-container">
                <canvas id="regressionCanvas" width="700" height="600"></canvas>
            </div>

            <div class="controls">
                <button onclick="generateRegressionData()" id="regressionGenerateData">Gerar Dados</button>
                <button onclick="startRegression()" id="regressionStart">Treinar Modelo</button>
                <button onclick="resetRegression()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="regressionSpeed" min="10" max="500" value="50" step="10">
                <span id="regressionSpeedValue">50ms</span>
            </div>

            <div class="speed-control">
                <label>Taxa de Aprendizado:</label>
                <input type="range" id="learningRate" min="0.0001" max="0.01" value="0.001" step="0.0001">
                <span id="learningRateValue">0.001</span>
            </div>

            <div class="speed-control">
                <label>Ruído nos Dados:</label>
                <input type="range" id="noiseLevel" min="0" max="50" value="20" step="5">
                <span id="noiseLevelValue">20</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Época</div>
                    <div class="stat-value" id="regressionEpoch">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Erro (MSE)</div>
                    <div class="stat-value" id="regressionError" style="font-size: 1.2em;">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Coeficiente (m)</div>
                    <div class="stat-value" id="regressionM" style="font-size: 1.2em;">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Intercepto (b)</div>
                    <div class="stat-value" id="regressionB" style="font-size: 1.2em;">-</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #5c6d82; border-radius: 50%; width: 12px; height: 12px;"></div>
                    <span>Pontos de Dados</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336; height: 3px;"></div>
                    <span>Linha de Regressão</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9800; height: 1px; border: 1px dashed #ff9800;"></div>
                    <span>Linhas de Erro</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Como funciona o Gradiente Descendente:</strong>
                <br>1. Inicia com valores aleatórios de m e b
                <br>2. Calcula o erro (diferença entre previsão e valor real)
                <br>3. Ajusta m e b na direção que reduz o erro
                <br>4. Repete até convergir (erro mínimo)
                <br><br><strong>Fórmulas:</strong>
                <br>• Previsão: ŷ = mx + b
                <br>• Erro: MSE = Σ(y - ŷ)² / n
                <br>• Atualização: m = m - α × ∂MSE/∂m
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Interatividade:</strong>
                <br>• Clique no gráfico para adicionar seus próprios pontos!
                <br>• Ajuste o ruído para dados mais/menos dispersos
                <br>• Ajuste a taxa de aprendizado (muito alta = instável, muito baixa = lento)
                <br>• Observe a linha vermelha se ajustando aos dados
            </div>
        </div>

        <!-- L-Systems -->
        <div class="section">
            <h2>16. L-SYSTEMS (Lindenmayer Systems)</h2>
            <p>L-Systems são sistemas de reescrita que geram padrões fractais complexos através de regras simples. Criados para modelar o crescimento de plantas, criam estruturas orgânicas realistas.</p>
            
            <div class="info-box">
                <strong>Conceito:</strong> String → Regras de substituição → Interpretação gráfica<br>
                <strong>Técnica:</strong> Gramática formal + Gráfico Tartaruga<br>
                <strong>Aplicações:</strong> Modelagem de plantas, arte generativa, jogos, arquitetura
            </div>

            <div class="canvas-container">
                <canvas id="lsystemCanvas" width="700" height="700"></canvas>
            </div>

            <div class="controls">
                <button onclick="drawLSystem()" id="lsystemDraw">Desenhar</button>
                <button onclick="resetLSystem()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Iterações:</label>
                <input type="range" id="lsystemIterations" min="1" max="7" value="4" step="1">
                <span id="lsystemIterationsValue">4</span>
            </div>

            <div class="speed-control">
                <label>Tipo de Planta:</label>
                <select id="lsystemType" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="tree">Árvore Fractal</option>
                    <option value="plant">Planta Ramificada</option>
                    <option value="bush">Arbusto</option>
                    <option value="fern">Samambaia</option>
                    <option value="alternatingPlant">Planta Alternada</option>
                    <option value="whorledPlant">Planta em Camadas</option>
                    <option value="leafPlant">Planta com Folhas</option>
                    <option value="dragon">Curva do Dragão</option>
                    <option value="sierpinski">Triângulo (Sierpinski)</option>
                    <option value="hilbert">Curva de Hilbert</option>
                    <option value="peano">Curva de Peano</option>
                    <option value="gosper">Curva de Gosper</option>
                    <option value="koch">Koch Snowflake</option>
                    <option value="kochIsland">Quadratic Koch Island</option>
                </select>
            </div>

            <div class="speed-control">
                <label>Cor dos Galhos:</label>
                <select id="lsystemColor" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="brown">Marrom (Natural)</option>
                    <option value="green">Verde</option>
                    <option value="rainbow">Arco-Íris</option>
                    <option value="autumn">Outono</option>
                    <option value="neon">Neon</option>
                </select>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">String Atual</div>
                    <div class="stat-value" id="lsystemLength" style="font-size: 1.2em;">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Segmentos</div>
                    <div class="stat-value" id="lsystemSegments">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Status</div>
                    <div class="stat-value" id="lsystemStatus" style="font-size: 1em;">Pronto</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #8B4513;"></div>
                    <span>F = Desenha linha (frente)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>+ = Gira à direita</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3;"></div>
                    <span>− = Gira à esquerda</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF9800;"></div>
                    <span>[ = Salva posição</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9C27B0;"></div>
                    <span>] = Volta posição</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Como funciona:</strong>
                <br>1. <strong>Axioma:</strong> String inicial (ex: "F")
                <br>2. <strong>Regras:</strong> Substituições (ex: F → FF+[+F-F-F]-[-F+F+F])
                <br>3. <strong>Iteração:</strong> Aplica regras repetidamente
                <br>4. <strong>Renderização:</strong> Interpreta string como comandos gráficos
            </div>

            <div class="info-box">
                <strong>Exemplos de Regras:</strong>
                <br>• <strong>Árvore:</strong> F → FF+[+F-F-F]-[-F+F+F]
                <br>• <strong>Planta:</strong> X → F+[[X]-X]-F[-FX]+X
                <br>• <strong>Dragão:</strong> X → X+YF+, Y → -FX-Y
                <br><br>Cada iteração torna o padrão mais complexo e orgânico!
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidade:</strong> L-Systems foram inventados pelo biólogo Aristid Lindenmayer em 1968 para modelar o crescimento de algas. Hoje são usados em jogos para gerar florestas inteiras proceduralmente!
            </div>
        </div>

        <!-- Delaunay Triangulation -->
        <div class="section">
            <h2>17. DELAUNAY TRIANGULATION (Triangulação de Delaunay)</h2>
            <p>A Triangulação de Delaunay conecta pontos criando triângulos de forma ótima, maximizando o ângulo mínimo. É o dual geométrico do Diagrama de Voronoi e forma a base de muitas aplicações em computação gráfica.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(n log n) com algoritmo Bowyer-Watson<br>
                <strong>Propriedade:</strong> Maximiza o menor ângulo (evita triângulos "finos")<br>
                <strong>Relação:</strong> Dual do Voronoi - cada aresta de Voronoi ⊥ aresta de Delaunay<br>
                <strong>Aplicações:</strong> Malhas 3D, terrenos, interpolação, elementos finitos
            </div>

            <div class="canvas-container">
                <canvas id="delaunayCanvas" width="700" height="700"></canvas>
            </div>

            <div class="controls">
                <button onclick="generateDelaunayPoints()" id="delaunayGenerate">Gerar Pontos</button>
                <button onclick="startDelaunay()" id="delaunayStart">Executar</button>
                <button onclick="resetDelaunay()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="delaunaySpeed" min="100" max="2000" value="500" step="100">
                <span id="delaunaySpeedValue">500ms</span>
            </div>

            <div class="speed-control">
                <label>Número de Pontos:</label>
                <input type="range" id="delaunayPoints" min="3" max="30" value="15" step="1">
                <span id="delaunayPointsValue">15</span>
            </div>

            <div class="speed-control">
                <label>Visualização:</label>
                <select id="delaunayVisualization" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="triangles">Triângulos</option>
                    <option value="voronoi">Voronoi + Delaunay</option>
                    <option value="circles">Círculos Circunscritos</option>
                    <option value="mesh">Malha 3D</option>
                </select>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Pontos</div>
                    <div class="stat-value" id="delaunayPointCount">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Triângulos</div>
                    <div class="stat-value" id="delaunayTriangleCount">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Arestas</div>
                    <div class="stat-value" id="delaunayEdgeCount">0</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #5c6d82; border-radius: 50%; width: 12px; height: 12px;"></div>
                    <span>Pontos</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3; height: 2px;"></div>
                    <span>Arestas de Delaunay</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(33, 150, 243, 0.1);"></div>
                    <span>Triângulos</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336; height: 1px; border: 1px dashed #f44336;"></div>
                    <span>Voronoi (quando visível)</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Algoritmo Bowyer-Watson:</strong>
                <br>1. Cria super-triângulo contendo todos os pontos
                <br>2. Para cada ponto:
                <br>&nbsp;&nbsp;&nbsp;a) Encontra triângulos cujo círculo circunscrito contém o ponto
                <br>&nbsp;&nbsp;&nbsp;b) Remove esses triângulos ("bad triangles")
                <br>&nbsp;&nbsp;&nbsp;c) Reconecta o polígono resultante ao novo ponto
                <br>3. Remove triângulos conectados ao super-triângulo
            </div>

            <div class="info-box">
                <strong>Propriedades Únicas:</strong>
                <br>• <strong>Critério de Delaunay:</strong> Nenhum ponto está dentro do círculo circunscrito de qualquer triângulo
                <br>• <strong>Maxmin Angle:</strong> Maximiza o menor ângulo de todos os triângulos
                <br>• <strong>Dualidade:</strong> Cada aresta de Voronoi cruza perpendicularmente uma aresta de Delaunay
                <br>• <strong>Unicidade:</strong> Para pontos em posição geral, a triangulação é única
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidade:</strong> A Triangulação de Delaunay é usada para criar terrenos em jogos 3D! Cada triângulo vira uma face, e a altura de cada ponto define a elevação. É também essencial em análise de elementos finitos (engenharia).
            </div>
        </div>

        <!-- KNN (K-Nearest Neighbors) -->
        <div class="section">
            <h2>18. KNN - K-NEAREST NEIGHBORS (Machine Learning)</h2>
            <p>O algoritmo KNN classifica pontos baseado nos K vizinhos mais próximos. É um algoritmo de aprendizado supervisionado simples mas poderoso usado em classificação e regressão. Clique no canvas para adicionar pontos!</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(n) para cada classificação<br>
                <strong>Conceito:</strong> "Diga-me quem são seus vizinhos e te direi quem você é"<br>
                <strong>Aplicações:</strong> Reconhecimento de padrões, sistemas de recomendação, diagnósticos
            </div>

            <div class="canvas-container">
                <canvas id="knnCanvas" width="700" height="600"></canvas>
            </div>

            <div class="controls">
                <button onclick="generateKNNData()">Gerar Dados</button>
                <button onclick="clearKNNData()">Limpar</button>
                <button onclick="classifyAllKNN()" id="knnClassifyAll">Classificar Área</button>
                <button onclick="resetKNN()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Valor de K:</label>
                <input type="range" id="knnK" min="1" max="15" value="3" step="1">
                <span id="knnKValue">3</span>
            </div>

            <div class="speed-control">
                <label>Classe para Adicionar:</label>
                <select id="knnClassSelect" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="0">Classe A (Vermelho)</option>
                    <option value="1">Classe B (Azul)</option>
                    <option value="2">Classe C (Verde)</option>
                </select>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="knnSpeed" min="1" max="100" value="10" step="1">
                <span id="knnSpeedValue">10ms</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Pontos Classe A</div>
                    <div class="stat-value" id="knnClassA">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Pontos Classe B</div>
                    <div class="stat-value" id="knnClassB">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Pontos Classe C</div>
                    <div class="stat-value" id="knnClassC">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Pixels Classificados</div>
                    <div class="stat-value" id="knnClassified">0</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336; border-radius: 50%; width: 15px; height: 15px;"></div>
                    <span>Classe A (Vermelho)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3; border-radius: 50%; width: 15px; height: 15px;"></div>
                    <span>Classe B (Azul)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50; border-radius: 50%; width: 15px; height: 15px;"></div>
                    <span>Classe C (Verde)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700; border-radius: 50%; width: 12px; height: 12px;"></div>
                    <span>Ponto a Classificar</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: none; border: 2px dashed #ff9800; width: 20px; height: 20px; border-radius: 50%;"></div>
                    <span>Vizinhos mais próximos</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Como funciona:</strong>
                <br>1. <strong>Treinamento:</strong> Armazena todos os pontos de dados com suas classes
                <br>2. <strong>Classificação:</strong> Para um novo ponto:
                <br>&nbsp;&nbsp;&nbsp;a) Calcula distância para todos os pontos conhecidos
                <br>&nbsp;&nbsp;&nbsp;b) Seleciona os K vizinhos mais próximos
                <br>&nbsp;&nbsp;&nbsp;c) Vota pela classe mais comum entre os K vizinhos
                <br>3. <strong>Resultado:</strong> O ponto recebe a classe vencedora
            </div>

            <div class="info-box">
                <strong>Escolhendo K:</strong>
                <br>• <strong>K pequeno (1-3):</strong> Fronteiras mais detalhadas, sensível a ruído
                <br>• <strong>K médio (5-7):</strong> Balanceado, funciona bem na maioria dos casos
                <br>• <strong>K grande (9-15):</strong> Fronteiras mais suaves, mais robusto a outliers
                <br>• <strong>Dica:</strong> Use K ímpar para evitar empates em problemas binários
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Interatividade:</strong>
                <br>• <strong>Clique esquerdo:</strong> Adiciona ponto da classe selecionada
                <br>• <strong>Clique direito:</strong> Classifica o ponto clicado e mostra os K vizinhos
                <br>• <strong>Classificar Área:</strong> Pinta todo o canvas mostrando as regiões de decisão
                <br>• <strong>Experimente:</strong> Mude o valor de K e veja como as fronteiras mudam!
            </div>
        </div>

        <!-- Sudoku Solver -->
        <div class="section">
            <h2>19. SUDOKU SOLVER (Backtracking)</h2>
            <p>O Sudoku Solver usa backtracking para resolver quebra-cabeças de Sudoku. O algoritmo tenta números de 1-9 em cada célula vazia, verificando se é válido, e volta atrás quando encontra um beco sem saída.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(9^n) onde n é o número de células vazias<br>
                <strong>Técnica:</strong> Backtracking (tentativa e erro inteligente)<br>
                <strong>Conceito:</strong> Tenta todas as possibilidades sistematicamente, desfazendo escolhas ruins<br>
                <strong>Aplicações:</strong> Puzzles, problemas de satisfação de restrições, scheduling
            </div>

            <div class="canvas-container">
                <canvas id="sudokuCanvas" width="550" height="550" style="border: none;"></canvas>
            </div>

            <div class="controls">
                <button onclick="generateSudokuPuzzle('easy')">Fácil</button>
                <button onclick="generateSudokuPuzzle('medium')">Médio</button>
                <button onclick="generateSudokuPuzzle('hard')">Difícil</button>
                <button onclick="solveSudoku()" id="sudokuSolve">Resolver</button>
                <button onclick="clearSudoku()">Limpar</button>
                <button onclick="resetSudoku()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="sudokuSpeed" min="1" max="491" value="50" step="10">
                <span id="sudokuSpeedValue">50ms</span>
            </div>

            <div class="speed-control">
                <label>Modo de Visualização:</label>
                <select id="sudokuVizMode" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="full">Completo (mostra cada tentativa)</option>
                    <option value="backtrack">Backtracking (mostra só retrocessos)</option>
                    <option value="solution">Solução (mostra só números corretos)</option>
                </select>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Tentativas</div>
                    <div class="stat-value" id="sudokuAttempts">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Backtracks</div>
                    <div class="stat-value" id="sudokuBacktracks">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Células Preenchidas</div>
                    <div class="stat-value" id="sudokuFilled">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Status</div>
                    <div class="stat-value" id="sudokuStatus" style="font-size: 1em;">Aguardando</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #f0f0f0;"></div>
                    <span>Célula Vazia</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #e3f2fd;"></div>
                    <span>Números Iniciais</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fff9c4;"></div>
                    <span>Tentando</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #c8e6c9;"></div>
                    <span>Correto</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffcdd2;"></div>
                    <span>Backtracking</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Regras do Sudoku:</strong>
                <br>• Cada linha deve conter números de 1 a 9 sem repetição
                <br>• Cada coluna deve conter números de 1 a 9 sem repetição
                <br>• Cada quadrante 3×3 deve conter números de 1 a 9 sem repetição
            </div>

            <div class="info-box">
                <strong>Como funciona o algoritmo:</strong>
                <br>1. <strong>Encontra célula vazia:</strong> Procura a próxima posição não preenchida
                <br>2. <strong>Tenta números 1-9:</strong> Para cada número, verifica se é válido
                <br>3. <strong>Validação:</strong> Checa linha, coluna e quadrante 3×3
                <br>4. <strong>Recursão:</strong> Se válido, continua para próxima célula
                <br>5. <strong>Backtracking:</strong> Se não há solução, volta e tenta outro número
                <br>6. <strong>Sucesso:</strong> Quando todas células estão preenchidas corretamente
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Interatividade:</strong>
                <br>• <strong>Clique nas células:</strong> Digite números de 1-9 para criar seu próprio puzzle
                <br>• <strong>Delete/Backspace:</strong> Remove número da célula
                <br>• <strong>Níveis:</strong> Fácil (40 números), Médio (30 números), Difícil (25 números)
                <br>• <strong>Modos de visualização:</strong> Veja diferentes aspectos do algoritmo
            </div>
        </div>

        <!-- Sieve of Eratosthenes -->
        <div class="section">
            <h2>20. SIEVE OF ERATOSTHENES (Crivo de Eratóstenes)</h2>
            <p>O Crivo de Eratóstenes é um algoritmo antigo e eficiente para encontrar todos os números primos até um determinado limite. Ele funciona eliminando múltiplos de cada primo encontrado.</p>
            
            <div class="info-box">
                <strong>Complexidade:</strong> O(n log log n)<br>
                <strong>Criador:</strong> Eratóstenes de Cirene (~276-194 a.C.)<br>
                <strong>Conceito:</strong> Marcar múltiplos de cada primo como compostos<br>
                <strong>Aplicações:</strong> Criptografia, teoria dos números, fatoração
            </div>

            <div class="canvas-container">
                <canvas id="sieveCanvas" width="800" height="600"></canvas>
            </div>

            <div class="controls">
                <button onclick="startSieve()" id="sieveStart">Iniciar Crivo</button>
                <button onclick="resetSieve()" id="sieveReset">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Limite (N):</label>
                <input type="range" id="sieveLimit" min="50" max="300" value="100" step="10">
                <span id="sieveLimitValue">100</span>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="sieveSpeed" min="1" max="491" value="30" step="10">
                <span id="sieveSpeedValue">30ms</span>
            </div>

            <div class="speed-control">
                <label>Modo de Visualização:</label>
                <select id="sieveVizMode" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="grid">Grade</option>
                    <option value="spiral">Espiral de Ulam</option>
                </select>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Primo Atual</div>
                    <div class="stat-value" id="sieveCurrentPrime">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Primos Encontrados</div>
                    <div class="stat-value" id="sievePrimeCount">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Números Eliminados</div>
                    <div class="stat-value" id="sieveEliminated">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Progresso</div>
                    <div class="stat-value" id="sieveProgress">0%</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #f0f0f0;"></div>
                    <span>Não processado</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700;"></div>
                    <span>Primo atual</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Primo</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>Sendo eliminado</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #999;"></div>
                    <span>Composto (eliminado)</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Como funciona:</strong>
                <br>1. <strong>Lista inicial:</strong> Começa com todos os números de 2 até N
                <br>2. <strong>Encontra primo:</strong> O menor número não marcado é primo
                <br>3. <strong>Elimina múltiplos:</strong> Marca todos os múltiplos desse primo como compostos
                <br>4. <strong>Repete:</strong> Vai para o próximo número não marcado
                <br>5. <strong>Termina:</strong> Quando chega em √N, todos os primos foram encontrados
            </div>

            <div class="info-box">
                <strong>Por que funciona:</strong>
                <br>• Todo número composto tem pelo menos um divisor primo ≤ √N
                <br>• Ao eliminar múltiplos de cada primo, sobram apenas os primos
                <br>• É muito mais eficiente que testar cada número individualmente
                <br><br><strong>Exemplo:</strong> Para encontrar primos até 30:
                <br>• Elimina múltiplos de 2: 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30
                <br>• Elimina múltiplos de 3: 9, 15, 21, 27
                <br>• Elimina múltiplos de 5: 25
                <br>• Sobram: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 ✓
            </div>

            <div class="info-box">
                <strong>Espiral de Ulam:</strong>
                <br>Padrão descoberto por Stanisław Ulam em 1963. Ao organizar números em espiral, os primos formam linhas diagonais misteriosas! Isso sugere padrões ainda não completamente compreendidos na distribuição de números primos.
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidades:</strong>
                <br>• Eratóstenes também calculou o tamanho da Terra com incrível precisão
                <br>• O algoritmo tem mais de 2.200 anos, mas ainda é usado hoje
                <br>• É o método mais eficiente para encontrar TODOS os primos até N
                <br>• Números primos são fundamentais para criptografia moderna (RSA)
            </div>
        </div>

        <!-- Fibonacci -->
        <div class="section">
            <h2>21. FIBONACCI (Sequência)</h2>
            <p>A sequência de Fibonacci é uma série onde cada número é a soma dos dois anteriores (0, 1, 1, 2, 3, 5, 8, 13...). A razão entre números consecutivos se aproxima da razão áurea (≈1.618), criando padrões encontrados na natureza.</p>
            
            <div class="info-box">
                <strong>Fórmula:</strong> F(n) = F(n-1) + F(n-2), onde F(0) = 0 e F(1) = 1<br>
                <strong>Complexidade:</strong> O(n) iterativo, O(2ⁿ) recursivo ingênuo<br>
                <strong>Na natureza:</strong> Pétalas de flores, espirais de conchas, galáxias, girassóis
            </div>

            <div class="canvas-container">
                <canvas id="fibSequenceCanvas" width="800" height="400"></canvas>
            </div>

            <div class="controls">
                <button onclick="startFibSequence()" id="fibSeqStart">Gerar Sequência</button>
                <button onclick="resetFibonacci()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Velocidade:</label>
                <input type="range" id="fibSpeed" min="50" max="1000" value="300" step="50">
                <span id="fibSpeedValue">300ms</span>
            </div>

            <div class="speed-control">
                <label>Números na Sequência:</label>
                <input type="range" id="fibCount" min="5" max="15" value="10" step="1">
                <span id="fibCountValue">10</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Último Número</div>
                    <div class="stat-value" id="fibLast">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Razão Áurea Atual</div>
                    <div class="stat-value" id="fibRatio" style="font-size: 1.2em;">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Iterações</div>
                    <div class="stat-value" id="fibIterations">0</div>
                </div>
            </div>

            <div class="info-box">
                <strong>Visualização:</strong> Mostra os números como barras crescentes com gradiente de cores.
                <br>• A razão entre F(n) e F(n-1) converge para φ (phi) ≈ 1.618034
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidade:</strong> A sequência de Fibonacci aparece em inúmeros lugares na natureza: no arranjo de folhas em plantas (filotaxia), no número de pétalas de flores, na espiral de conchas do nautilus, na estrutura de galáxias espirais e até na reprodução de coelhos!
            </div>
        </div>

        <!-- Perlin Noise -->
        <div class="section">
            <h2>22. PERLIN NOISE (Ruído Coerente)</h2>
            <p>Perlin Noise é um algoritmo de geração de ruído gradiente criado por Ken Perlin em 1983. Diferente do ruído aleatório, o Perlin Noise produz valores suaves e naturais, muito usado em texturas procedurais, terrenos e efeitos visuais.</p>
            
            <div class="info-box">
                <strong>Característica:</strong> Gera valores suaves e contínuos (não totalmente aleatório)<br>
                <strong>Aplicações:</strong> Geração de terrenos, nuvens, texturas de madeira, fogo, água<br>
                <strong>Diferença:</strong> Ruído aleatório = pixels desconexos | Perlin = transições suaves
            </div>

            <div class="canvas-container">
                <canvas id="perlinCanvas" width="600" height="600"></canvas>
            </div>

            <div class="controls">
                <button onclick="generatePerlinNoise()" id="perlinStart">Gerar Ruído</button>
                <button onclick="animatePerlinNoise()" id="perlinAnimate">Animar</button>
                <button onclick="stopPerlinAnimation()" id="perlinStop">Parar Animação</button>
                <button onclick="resetPerlin()" id="resetPerlin">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Modo de Visualização:</label>
                <select id="perlinMode" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="grayscale">Escala de Cinza</option>
                    <option value="terrain">Mapa de Terreno</option>
                    <option value="clouds">Nuvens</option>
                    <option value="fire">Fogo</option>
                    <option value="water">Água</option>
                    <option value="wood">Madeira</option>
                </select>
            </div>

            <div class="speed-control">
                <label>Escala (Zoom):</label>
                <input type="range" id="perlinScale" min="20" max="200" value="50" step="10">
                <span id="perlinScaleValue">50</span>
            </div>

            <div class="speed-control">
                <label>Octaves (Detalhes):</label>
                <input type="range" id="perlinOctaves" min="1" max="8" value="4" step="1">
                <span id="perlinOctavesValue">4</span>
            </div>

            <div class="speed-control">
                <label>Persistência:</label>
                <input type="range" id="perlinPersistence" min="0.1" max="1.0" value="0.5" step="0.1">
                <span id="perlinPersistenceValue">0.5</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Pixels Processados</div>
                    <div class="stat-value" id="perlinPixels">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Progresso</div>
                    <div class="stat-value" id="perlinProgress">0%</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Tempo (frame)</div>
                    <div class="stat-value" id="perlinTime">0.00</div>
                </div>
            </div>

            <div class="info-box">
                <strong>Parâmetros:</strong>
                <br>• <strong>Escala:</strong> Controla o "zoom" - valores menores = mais detalhes
                <br>• <strong>Octaves:</strong> Camadas de ruído sobrepostas - mais octaves = mais detalhes
                <br>• <strong>Persistência:</strong> Quanto cada octave influencia - valores maiores = mais rugoso
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidade:</strong> Ken Perlin ganhou um Oscar Técnico em 1997 por inventar o Perlin Noise! É usado em praticamente todos os filmes e jogos modernos para criar terrenos, nuvens, fogo, e texturas naturais. Filmes como Tron (1982) e jogos como Minecraft usam variações deste algoritmo.
            </div>
        </div>

        <!-- Fourier Transform -->
        <div class="section">
            <h2>23. FOURIER TRANSFORM (Transformada de Fourier)</h2>
            <p>A Transformada de Fourier decompõe um sinal complexo em suas componentes de frequência. É como "ouvir" quais notas musicais compõem um som - transforma dados do domínio do tempo para o domínio da frequência.</p>
            
            <div class="info-box">
                <strong>Conceito:</strong> Qualquer onda pode ser construída somando ondas senoidais simples<br>
                <strong>Aplicações:</strong> Processamento de áudio, compressão de imagem (JPEG), comunicações, análise de sinais<br>
                <strong>Descoberta:</strong> Joseph Fourier (1822) - revolucionou matemática e engenharia
            </div>

            <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin: 20px 0;">
                <div style="flex: 1; min-width: 300px;">
                    <h3 style="text-align: center; color: #273E74; margin-bottom: 15px;">Domínio do Tempo (Onda Original)</h3>
                    <div class="canvas-container">
                        <canvas id="fourierTimeCanvas" width="500" height="300"></canvas>
                    </div>
                </div>

                <div style="flex: 1; min-width: 300px;">
                    <h3 style="text-align: center; color: #273E74; margin-bottom: 15px;">Domínio da Frequência (Espectro)</h3>
                    <div class="canvas-container">
                        <canvas id="fourierFreqCanvas" width="500" height="300"></canvas>
                    </div>
                </div>
            </div>

            <div class="controls">
                <button onclick="addFourierWave()" id="fourierAdd">Adicionar Onda</button>
                <button onclick="removeFourierWave()" id="fourierRemove">Remover Onda</button>
                <button onclick="animateFourier()" id="fourierAnimate">Animar</button>
                <button onclick="stopFourierAnimation()" id="fourierStop">Parar</button>
                <button onclick="resetFourier()">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Tipo de Sinal:</label>
                <select id="fourierPreset" onchange="loadFourierPreset()" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="custom">Personalizado</option>
                    <option value="sine">Onda Senoidal Pura</option>
                    <option value="square">Onda Quadrada</option>
                    <option value="sawtooth">Onda Dente de Serra</option>
                    <option value="triangle">Onda Triangular</option>
                    <option value="complex">Sinal Complexo</option>
                </select>
            </div>

            <div style="background: #f9f9f9; padding: 20px; margin: 20px 0; border: 2px solid #273E74;">
                <h3 style="color: #273E74; margin-bottom: 15px;">Ondas Componentes</h3>
                <div id="fourierWavesList" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- Waves will be added here dynamically -->
                </div>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Número de Ondas</div>
                    <div class="stat-value" id="fourierWaveCount">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Frequência Dominante</div>
                    <div class="stat-value" id="fourierDominant">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Amplitude Total</div>
                    <div class="stat-value" id="fourierAmplitude">0.00</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #5c6d82;"></div>
                    <span>Onda Composta (soma de todas)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(255, 152, 0, 0.3);"></div>
                    <span>Ondas Individuais (transparentes)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: linear-gradient(90deg, hsl(0, 70%, 60%), hsl(180, 70%, 60%), hsl(280, 70%, 60%));"></div>
                    <span>Barras de Frequência (cada cor = uma onda)</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Como funciona:</strong>
                <br>• <strong>Domínio do Tempo:</strong> Mostra o sinal como ele varia ao longo do tempo
                <br>• <strong>Domínio da Frequência:</strong> Mostra quais frequências compõem o sinal
                <br>• Cada barra no espectro representa a intensidade de uma frequência específica
                <br>• A altura das barras indica a amplitude (força) daquela frequência
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidade:</strong> A Transformada de Fourier é uma das equações mais importantes da matemática! Ela permite que o Shazam identifique músicas, que o JPEG comprima imagens, que o WiFi transmita dados, e até que médicos vejam dentro do corpo com ressonância magnética (MRI). Sem Fourier, não teríamos celulares, internet moderna ou música digital!
            </div>
        </div>

        <!-- Circle Packing -->
        <div class="section">
            <h2>24. CIRCLE PACKING (Empacotamento de Círculos)</h2>
            <p>Circle Packing é um algoritmo que organiza círculos no espaço de forma que eles cresçam o máximo possível sem se sobrepor. O resultado é visualmente orgânico e matematicamente elegante, criando padrões que lembram bolhas, células ou espuma.</p>
            
            <div class="info-box">
                <strong>Algoritmo:</strong> Posiciona círculos aleatoriamente e os expande até tocarem outros círculos<br>
                <strong>Aplicações:</strong> Design gráfico, visualização de dados, arte generativa, layout de interfaces<br>
                <strong>Matemática:</strong> Baseado em detecção de colisão e geometria euclidiana
            </div>

            <div class="canvas-container">
                <canvas id="circlePackCanvas" width="700" height="700"></canvas>
            </div>

            <div class="controls">
                <button onclick="startCirclePacking()" id="circlePackStart">Iniciar Empacotamento</button>
                <button onclick="stopCirclePacking()" id="circlePackStop">Parar</button>
                <button onclick="resetCirclePacking()">Resetar</button>
                <button onclick="exportCirclePackImage()">Exportar Imagem</button>
            </div>

            <div class="speed-control">
                <label>Modo de Crescimento:</label>
                <select id="circlePackMode" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="random">Aleatório</option>
                    <option value="grid">Grade</option>
                    <option value="spiral">Espiral</option>
                    <option value="center">Centro para Fora</option>
                </select>
            </div>

            <div class="speed-control">
                <label>Velocidade de Crescimento:</label>
                <input type="range" id="circlePackSpeed" min="0.1" max="2" value="0.5" step="0.1">
                <span id="circlePackSpeedValue">0.5</span>
            </div>

            <div class="speed-control">
                <label>Número de Círculos:</label>
                <input type="range" id="circlePackCount" min="50" max="1000" value="200" step="50">
                <span id="circlePackCountValue">200</span>
            </div>

            <div class="speed-control">
                <label>Estilo Visual:</label>
                <select id="circlePackStyle" onchange="redrawCirclePacking()" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="colorful">Colorido</option>
                    <option value="gradient">Gradiente</option>
                    <option value="monochrome">Monocromático</option>
                    <option value="outline">Apenas Contorno</option>
                    <option value="size">Por Tamanho</option>
                </select>
            </div>

            <div class="speed-control">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="circlePackBorders" onchange="redrawCirclePacking()" checked style="width: 20px; height: 20px; cursor: pointer;">
                    <span>Mostrar Bordas</span>
                </label>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Círculos Ativos</div>
                    <div class="stat-value" id="circlePackActive">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Círculos Completos</div>
                    <div class="stat-value" id="circlePackComplete">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Taxa de Preenchimento</div>
                    <div class="stat-value" id="circlePackFill">0.0%</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Maior Círculo</div>
                    <div class="stat-value" id="circlePackLargest">0</div>
                </div>
            </div>

            <div class="info-box">
                <strong>Como funciona:</strong>
                <br>1. Círculos são posicionados em locais válidos (sem sobreposição inicial)
                <br>2. Cada círculo cresce gradualmente a cada frame
                <br>3. Quando um círculo toca outro ou atinge a borda, para de crescer
                <br>4. O processo continua até todos os círculos estarem "completos"
                <br>• <strong>Detecção de Colisão:</strong> Usa distância euclidiana entre centros dos círculos
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidade:</strong> O Circle Packing tem conexões profundas com matemática pura! O "Teorema do Circle Packing" (provado por Kenneth Stephenson) mostra que qualquer grafo planar pode ser representado por círculos tangentes. Isso conecta topologia, geometria e teoria dos grafos de forma elegante. Também aparece na natureza: bolhas de sabão, células biológicas e até na estrutura de frutas como romãs seguem princípios de empacotamento circular!
            </div>
        </div>

        <!-- Chladni Patterns -->
        <div class="section">
            <h2>25. CHLADNI PATTERNS (Padrões de Chladni)</h2>
            <p>Os Padrões de Chladni são formações geométricas criadas por vibrações em placas. Quando uma placa vibra em diferentes frequências, partículas se acumulam nos nodos (pontos de vibração zero), formando padrões fascinantes.</p>
            
            <div class="info-box">
                <strong>Física:</strong> Baseado em ondas estacionárias e ressonância<br>
                <strong>Equação:</strong> sin(n·x)·sin(m·y) + sin(m·x)·sin(n·y)<br>
                <strong>Descoberta:</strong> Ernst Chladni (1787), "Pai da Acústica"<br>
                <strong>Aplicações:</strong> Acústica, design de instrumentos musicais, arte sonora
            </div>

            <div class="canvas-container">
                <canvas id="chladniCanvas" width="600" height="600"></canvas>
            </div>

            <div class="controls">
                <button onclick="drawChladni()" id="chladniDraw">Desenhar Padrão</button>
                <button onclick="animateChladni()" id="chladniAnimate">Animar</button>
                <button onclick="randomChladniPattern()" id="randomPatternChladni">Padrão Aleatório</button>
                <button onclick="exportChladniImage()" id="exportImageChladni">Exportar Imagem</button>
                <button onclick="resetChladni()" id="resetChladniBtn">Resetar</button>
            </div>

            <div class="speed-control">
                <label>Tipo de Padrão:</label>
                <select id="chladniEquation" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="classic">Clássico (Retangular)</option>
                    <option value="cosine">Cosseno</option>
                    <option value="mixed">Misto (Seno/Cosseno)</option>
                    <option value="square">Quadrado</option>
                    <option value="circular">Circular</option>
                    <option value="diagonal">Diagonal</option>
                    <option value="complex">Complexo (Harmônicos)</option>
                    <option value="radial">Radial</option>
                    <option value="spiral">Espiral</option>
                    <option value="interference">Interferência</option>
                    <option value="web">Teia</option>
                    <option value="flower">Floral</option>
                </select>
            </div>

            <div class="speed-control">
                <label>Modo N (horizontal):</label>
                <input type="range" id="chladniN" min="1" max="12" value="3" step="1">
                <span id="chladniNValue">3</span>
            </div>

            <div class="speed-control">
                <label>Modo M (vertical):</label>
                <input type="range" id="chladniM" min="1" max="12" value="4" step="1">
                <span id="chladniMValue">4</span>
            </div>

            <div class="speed-control">
                <label>Resolução:</label>
                <input type="range" id="chladniResolution" min="200" max="800" value="400" step="50">
                <span id="chladniResolutionValue">400</span>
            </div>

            <div class="speed-control">
                <label>Esquema de Cores:</label>
                <select id="chladniColors" style="padding: 8px; border: 2px solid #273E74; background: white; color: #273E74; font-weight: bold; cursor: pointer;">
                    <option value="bw">Preto e Branco (Clássico)</option>
                    <option value="gradient">Gradiente (Azul-Roxo)</option>
                    <option value="fire">Fogo</option>
                    <option value="ocean">Oceano</option>
                    <option value="rainbow">Arco-Íris</option>
                    <option value="gold">Dourado</option>
                    <option value="copper">Cobre</option>
                    <option value="neon">Neon</option>
                </select>
            </div>

            <div class="speed-control">
                <label>Limiar de Contraste:</label>
                <input type="range" id="chladniThreshold" min="0" max="100" value="50" step="5">
                <span id="chladniThresholdValue">50</span>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Modo Atual (n, m)</div>
                    <div class="stat-value" id="chladniMode">3, 4</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Frequência Teórica</div>
                    <div class="stat-value" id="chladniFreq">-</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Status</div>
                    <div class="stat-value" id="chladniStatus" style="font-size: 1em;">Pronto</div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #000;"></div>
                    <span>Nodos (sem movimento)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #fff;"></div>
                    <span>Antinodos (máx. vibração)</span>
                </div>
            </div>

            <div class="info-box">
                <strong>Como funcionam:</strong> Quando uma placa vibra em certas frequências (modos normais), algumas áreas ficam paradas (nodos) enquanto outras vibram intensamente (antinodos). Partículas como areia se acumulam nos nodos, revelando os padrões.
                <br><br>
                <strong>Modos (n, m):</strong> Representam o número de linhas nodais nas direções horizontal e vertical. Maiores valores = padrões mais complexos.
            </div>

            <div class="info-box" style="margin-bottom: 0px;">
                <strong>Curiosidade:</strong> Estes padrões inspiraram artistas e cientistas por séculos! Podem ser vistos em tambores, pratos de violinos, e até na natureza (como nas manchas de animais). A frequência de ressonância é proporcional a √(n² + m²).
            </div>
        </div>
    </div>

    <script>
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // ========== BUBBLE SORT ==========
        let bubbleArray = [];
        let bubbleAnimating = false;
        let bubbleComparisons = 0;
        let bubbleSwaps = 0;
        let bubbleShouldStop = false;
        let bubbleIsSorted = false;

        function generateBubbleArray() {
            bubbleArray = [];
            for (let i = 0; i < 15; i++) {
                bubbleArray.push(Math.floor(Math.random() * 100) + 10);
            }
            bubbleIsSorted = false;
            renderBubbleArray();
            bubbleComparisons = 0;
            bubbleSwaps = 0;
            updateBubbleStats();
        }

        function renderBubbleArray(sortedIndices = []) {
            const container = document.getElementById('bubbleArray');
            container.innerHTML = '';
            bubbleArray.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'array-bar';
                if (sortedIndices.includes(index)) {
                    bar.classList.add('sorted');
                }
                bar.style.height = value * 2 + 'px';
                bar.textContent = value;
                bar.id = 'bubble-' + index;
                container.appendChild(bar);
            });
        }

        function updateBubbleStats() {
            document.getElementById('bubbleComparisons').textContent = bubbleComparisons;
            document.getElementById('bubbleSwaps').textContent = bubbleSwaps;
        }

        async function startBubbleSort() {
            if (bubbleAnimating) return;
            if (bubbleIsSorted) {
                alert('O array já está ordenado! Clique em "Gerar Novo Array" para criar um novo.');
                return;
            }
            
            bubbleAnimating = true;
            bubbleShouldStop = false;
            document.getElementById('bubbleStart').disabled = true;
            document.querySelectorAll('#bubbleArray').forEach(el => {
                el.closest('.section').querySelectorAll('button').forEach(btn => {
                    if (btn.textContent.includes('Gerar')) btn.disabled = true;
                });
            });

            const n = bubbleArray.length;
            const sortedIndices = [];
            
            for (let i = 0; i < n - 1; i++) {
                if (bubbleShouldStop) break;
                for (let j = 0; j < n - i - 1; j++) {
                    if (bubbleShouldStop) break;
                    
                    const bar1 = document.getElementById('bubble-' + j);
                    const bar2 = document.getElementById('bubble-' + (j + 1));

                    if (!bar1 || !bar2) break;

                    bar1.classList.add('comparing');
                    bar2.classList.add('comparing');
                    bubbleComparisons++;
                    updateBubbleStats();

                    await sleep(parseInt(document.getElementById('bubbleSpeed').value));

                    if (bubbleShouldStop) break;

                    if (bubbleArray[j] > bubbleArray[j + 1]) {
                        bar1.classList.remove('comparing');
                        bar2.classList.remove('comparing');
                        bar1.classList.add('swapping');
                        bar2.classList.add('swapping');

                        [bubbleArray[j], bubbleArray[j + 1]] = [bubbleArray[j + 1], bubbleArray[j]];
                        bubbleSwaps++;
                        updateBubbleStats();

                        await sleep(parseInt(document.getElementById('bubbleSpeed').value));
                        
                        if (bubbleShouldStop) break;
                        
                        renderBubbleArray(sortedIndices);
                    } else {
                        bar1.classList.remove('comparing');
                        bar2.classList.remove('comparing');
                    }
                }
                if (!bubbleShouldStop) {
                    sortedIndices.push(n - i - 1);
                    const sortedBar = document.getElementById('bubble-' + (n - i - 1));
                    if (sortedBar) sortedBar.classList.add('sorted');
                }
            }
            if (!bubbleShouldStop) {
                sortedIndices.push(0);
                const firstBar = document.getElementById('bubble-0');
                if (firstBar) firstBar.classList.add('sorted');
                bubbleIsSorted = true;
            }
            
            bubbleAnimating = false;
            document.getElementById('bubbleStart').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Gerar Novo Array')) btn.disabled = false;
            });
        }

        function resetBubbleSort() {
            bubbleShouldStop = true;
            bubbleAnimating = false;
            bubbleComparisons = 0;
            bubbleSwaps = 0;
            bubbleIsSorted = false;
            generateBubbleArray();
            document.getElementById('bubbleStart').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Gerar Novo Array')) btn.disabled = false;
            });
        }

        document.getElementById('bubbleSpeed').addEventListener('input', (e) => {
            document.getElementById('bubbleSpeedValue').textContent = e.target.value + 'ms';
        });

        // ========== BINARY SEARCH ==========
        let binaryArray = [];
        let binaryAnimating = false;
        let binaryTarget = 0;
        let binaryShouldStop = false;

        function generateBinaryArray() {
            binaryArray = [];
            for (let i = 0; i < 20; i++) {
                binaryArray.push(i * 5 + Math.floor(Math.random() * 3));
            }
            binaryArray.sort((a, b) => a - b);
            binaryTarget = binaryArray[Math.floor(Math.random() * binaryArray.length)];
            document.getElementById('binaryTarget').textContent = binaryTarget;
            document.getElementById('binaryIterations').textContent = 0;
            document.getElementById('binaryStatus').textContent = '-';
            drawBinaryArray();
        }

        function drawBinaryArray(left = -1, right = -1, mid = -1, found = false) {
            const canvas = document.getElementById('binaryCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / binaryArray.length;
            const maxHeight = 150;

            binaryArray.forEach((value, index) => {
                const x = index * barWidth;
                const height = (value / Math.max(...binaryArray)) * maxHeight;
                const y = canvas.height - height - 30;

                if (found && index === mid) {
                    ctx.fillStyle = '#4CAF50';
                } else if (index === mid) {
                    ctx.fillStyle = '#ff9800';
                } else if (index >= left && index <= right) {
                    ctx.fillStyle = '#64B5F6';
                } else {
                    ctx.fillStyle = '#5c6d82';
                }

                ctx.fillRect(x + 2, y, barWidth - 4, height);
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(value, x + barWidth / 2, canvas.height - 10);
            });
        }

        async function startBinarySearch() {
            if (binaryAnimating) return;
            binaryAnimating = true;
            binaryShouldStop = false;
            document.getElementById('binaryStart').disabled = true;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Gerar Novo Array')) btn.disabled = true;
            });

            let left = 0;
            let right = binaryArray.length - 1;
            let iterations = 0;

            while (left <= right && !binaryShouldStop) {
                iterations++;
                const mid = Math.floor((left + right) / 2);
                document.getElementById('binaryIterations').textContent = iterations;

                drawBinaryArray(left, right, mid);
                await sleep(parseInt(document.getElementById('binarySpeed').value));

                if (binaryShouldStop) break;

                if (binaryArray[mid] === binaryTarget) {
                    document.getElementById('binaryStatus').textContent = 'ENCONTRADO!';
                    drawBinaryArray(left, right, mid, true);
                    binaryAnimating = false;
                    document.getElementById('binaryStart').disabled = false;
                    document.querySelectorAll('button').forEach(btn => {
                        if (btn.textContent.includes('Gerar Novo Array')) btn.disabled = false;
                    });
                    return;
                } else if (binaryArray[mid] < binaryTarget) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }

            if (!binaryShouldStop) {
                document.getElementById('binaryStatus').textContent = 'NÃO ENCONTRADO';
            }
            binaryAnimating = false;
            document.getElementById('binaryStart').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Gerar Novo Array')) btn.disabled = false;
            });
        }

        function resetBinarySearch() {
            binaryShouldStop = true;
            binaryAnimating = false;
            generateBinaryArray();
            document.getElementById('binaryStart').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Gerar Novo Array')) btn.disabled = false;
            });
        }

        document.getElementById('binarySpeed').addEventListener('input', (e) => {
            document.getElementById('binarySpeedValue').textContent = e.target.value + 'ms';
        });

        // ========== DIJKSTRA ==========
        const dijkstraCanvas = document.getElementById('dijkstraCanvas');
        const dijkstraCtx = dijkstraCanvas.getContext('2d');
        const cellSize = 20;
        const rows = Math.floor(dijkstraCanvas.height / cellSize);
        const cols = Math.floor(dijkstraCanvas.width / cellSize);
        let dijkstraGrid = [];
        let dijkstraAnimating = false;
        let isDrawing = false;
        let drawMode = null;
        let dijkstraShouldStop = false;

        function initDijkstraGrid() {
            dijkstraGrid = [];
            for (let i = 0; i < rows; i++) {
                dijkstraGrid[i] = [];
                for (let j = 0; j < cols; j++) {
                    dijkstraGrid[i][j] = {
                        row: i,
                        col: j,
                        isWall: false,
                        isVisited: false,
                        distance: Infinity,
                        previous: null
                    };
                }
            }
            drawDijkstraGrid();
        }

        function drawDijkstraGrid() {
            dijkstraCtx.clearRect(0, 0, dijkstraCanvas.width, dijkstraCanvas.height);
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = dijkstraGrid[i][j];
                    const x = j * cellSize;
                    const y = i * cellSize;

                    if (i === 1 && j === 1) {
                        dijkstraCtx.fillStyle = '#4CAF50';
                    } else if (i === rows - 2 && j === cols - 2) {
                        dijkstraCtx.fillStyle = '#f44336';
                    } else if (cell.isWall) {
                        dijkstraCtx.fillStyle = '#333';
                    } else if (cell.isVisited) {
                        dijkstraCtx.fillStyle = '#64B5F6';
                    } else {
                        dijkstraCtx.fillStyle = '#fff';
                    }

                    dijkstraCtx.fillRect(x, y, cellSize - 1, cellSize - 1);
                    
                    // Desenha grid
                    dijkstraCtx.strokeStyle = '#ddd';
                    dijkstraCtx.lineWidth = 0.5;
                    dijkstraCtx.strokeRect(x, y, cellSize, cellSize);
                }
            }
        }

        function drawDijkstraPath(path) {
            path.forEach(cell => {
                const x = cell.col * cellSize;
                const y = cell.row * cellSize;
                dijkstraCtx.fillStyle = '#FFD700';
                dijkstraCtx.fillRect(x, y, cellSize - 1, cellSize - 1);
            });
            
            dijkstraCtx.fillStyle = '#4CAF50';
            dijkstraCtx.fillRect(cellSize, cellSize, cellSize - 1, cellSize - 1);
            dijkstraCtx.fillStyle = '#f44336';
            dijkstraCtx.fillRect((cols - 2) * cellSize, (rows - 2) * cellSize, cellSize - 1, cellSize - 1);
        }

        function getCanvasCoords(canvas, event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY
            };
        }

        dijkstraCanvas.addEventListener('mousedown', (e) => {
            if (dijkstraAnimating) return;
            isDrawing = true;

            const { x, y } = getCanvasCoords(dijkstraCanvas, e);
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (row >= 0 && row < rows && col >= 0 && col < cols) {
                if ((row === 1 && col === 1) || (row === rows - 2 && col === cols - 2)) return;

                drawMode = !dijkstraGrid[row][col].isWall;
                dijkstraGrid[row][col].isWall = drawMode;
                drawDijkstraGrid();
            }
        });

        dijkstraCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing || dijkstraAnimating || drawMode === null) return;

            const { x, y } = getCanvasCoords(dijkstraCanvas, e);
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (row >= 0 && row < rows && col >= 0 && col < cols) {
                if ((row === 1 && col === 1) || (row === rows - 2 && col === cols - 2)) return;

                if (dijkstraGrid[row][col].isWall !== drawMode) {
                    dijkstraGrid[row][col].isWall = drawMode;
                    drawDijkstraGrid();
                }
            }
        });

        dijkstraCanvas.addEventListener('mouseup', () => {
            isDrawing = false;
            drawMode = null;
        });

        dijkstraCanvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            drawMode = null;
        });

        async function startDijkstra() {
            if (dijkstraAnimating) return;
            dijkstraAnimating = true;
            dijkstraShouldStop = false;
            document.getElementById('dijkstraStart').disabled = true;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Limpar Paredes')) btn.disabled = true;
            });

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    dijkstraGrid[i][j].isVisited = false;
                    dijkstraGrid[i][j].distance = Infinity;
                    dijkstraGrid[i][j].previous = null;
                }
            }

            const startCell = dijkstraGrid[1][1];
            const endCell = dijkstraGrid[rows - 2][cols - 2];
            startCell.distance = 0;

            const unvisited = [];
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (!dijkstraGrid[i][j].isWall) {
                        unvisited.push(dijkstraGrid[i][j]);
                    }
                }
            }

            let visitedCount = 0;

            while (unvisited.length > 0 && !dijkstraShouldStop) {
                unvisited.sort((a, b) => a.distance - b.distance);
                const current = unvisited.shift();

                if (current.distance === Infinity) break;

                current.isVisited = true;
                visitedCount++;
                document.getElementById('dijkstraVisited').textContent = visitedCount;

                drawDijkstraGrid();
                await sleep(parseInt(document.getElementById('dijkstraSpeed').value));

                if (dijkstraShouldStop) break;

                if (current === endCell) {
                    const path = [];
                    let temp = endCell;
                    while (temp !== null) {
                        path.unshift(temp);
                        temp = temp.previous;
                    }
                    drawDijkstraPath(path);
                    document.getElementById('dijkstraDistance').textContent = endCell.distance;
                    dijkstraAnimating = false;
                    document.getElementById('dijkstraStart').disabled = false;
                    document.querySelectorAll('button').forEach(btn => {
                        if (btn.textContent.includes('Limpar Paredes')) btn.disabled = false;
                    });
                    return;
                }

                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    if (!neighbor.isVisited && !neighbor.isWall) {
                        const newDist = current.distance + 1;
                        if (newDist < neighbor.distance) {
                            neighbor.distance = newDist;
                            neighbor.previous = current;
                        }
                    }
                }
            }

            dijkstraAnimating = false;
            document.getElementById('dijkstraStart').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Limpar Paredes')) btn.disabled = false;
            });
        }

        function getNeighbors(cell) {
            const neighbors = [];
            const { row, col } = cell;
            if (row > 0) neighbors.push(dijkstraGrid[row - 1][col]);
            if (row < rows - 1) neighbors.push(dijkstraGrid[row + 1][col]);
            if (col > 0) neighbors.push(dijkstraGrid[row][col - 1]);
            if (col < cols - 1) neighbors.push(dijkstraGrid[row][col + 1]);
            return neighbors;
        }

        function clearDijkstraWalls() {
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    dijkstraGrid[i][j].isWall = false;
                }
            }
            drawDijkstraGrid();
        }

        function resetDijkstra() {
            dijkstraShouldStop = true;
            dijkstraAnimating = false;
            document.getElementById('dijkstraVisited').textContent = 0;
            document.getElementById('dijkstraDistance').textContent = 0;
            initDijkstraGrid();
            document.getElementById('dijkstraStart').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Limpar Paredes')) btn.disabled = false;
            });
        }

        document.getElementById('dijkstraSpeed').addEventListener('input', (e) => {
            document.getElementById('dijkstraSpeedValue').textContent = e.target.value + 'ms';
        });

        // ========== N-QUEENS ==========
        const queensCanvas = document.getElementById('queensCanvas');
        const queensCtx = queensCanvas.getContext('2d');
        const queensSize = 8;
        const queensCellSize = queensCanvas.width / queensSize;
        let queensBoard = [];
        let queensAnimating = false;
        let queensAttempts = 0;
        let queensBacktracks = 0;
        let queensShouldStop = false;

        function initQueensBoard() {
            queensBoard = Array(queensSize).fill().map(() => Array(queensSize).fill(0));
            queensAttempts = 0;
            queensBacktracks = 0;
            updateQueensStats();
            drawQueensBoard();
        }

        function drawQueensBoard() {
            queensCtx.clearRect(0, 0, queensCanvas.width, queensCanvas.height);

            for (let i = 0; i < queensSize; i++) {
                for (let j = 0; j < queensSize; j++) {
                    queensCtx.fillStyle = (i + j) % 2 === 0 ? '#f0f0f0' : '#5c6d82';
                    queensCtx.fillRect(j * queensCellSize, i * queensCellSize, queensCellSize, queensCellSize);

                    if (queensBoard[i][j] === 1) {
                        queensCtx.fillStyle = '#f44336';
                        queensCtx.font = 'bold 30px Arial';
                        queensCtx.textAlign = 'center';
                        queensCtx.textBaseline = 'middle';
                        queensCtx.fillText('♛', j * queensCellSize + queensCellSize / 2, i * queensCellSize + queensCellSize / 2);
                    }
                }
            }
        }

        function updateQueensStats() {
            document.getElementById('queensAttempts').textContent = queensAttempts;
            document.getElementById('queensBacktracks').textContent = queensBacktracks;
            const placed = queensBoard.flat().filter(x => x === 1).length;
            document.getElementById('queensPlaced').textContent = placed;
        }

        function isSafe(row, col) {
            for (let i = 0; i < col; i++) {
                if (queensBoard[row][i] === 1) return false;
            }

            for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {
                if (queensBoard[i][j] === 1) return false;
            }

            for (let i = row, j = col; i < queensSize && j >= 0; i++, j--) {
                if (queensBoard[i][j] === 1) return false;
            }

            return true;
        }

        async function solveQueens(col) {
            if (queensShouldStop) return false;
            if (col >= queensSize) return true;

            for (let i = 0; i < queensSize; i++) {
                if (queensShouldStop) return false;
                
                queensAttempts++;
                updateQueensStats();

                if (isSafe(i, col)) {
                    queensBoard[i][col] = 1;
                    drawQueensBoard();
                    updateQueensStats();
                    await sleep(parseInt(document.getElementById('queensSpeed').value));

                    if (queensShouldStop) return false;

                    if (await solveQueens(col + 1)) return true;

                    if (queensShouldStop) return false;

                    queensBoard[i][col] = 0;
                    queensBacktracks++;
                    drawQueensBoard();
                    updateQueensStats();
                    await sleep(parseInt(document.getElementById('queensSpeed').value));
                }
            }

            return false;
        }

        async function startQueens() {
            if (queensAnimating) return;
            queensAnimating = true;
            queensShouldStop = false;
            document.getElementById('queensStart').disabled = true;

            initQueensBoard();
            await solveQueens(0);

            queensAnimating = false;
            document.getElementById('queensStart').disabled = false;
        }

        function resetQueens() {
            queensShouldStop = true;
            queensAnimating = false;
            initQueensBoard();
            document.getElementById('queensStart').disabled = false;
        }

        document.getElementById('queensSpeed').addEventListener('input', (e) => {
            document.getElementById('queensSpeedValue').textContent = e.target.value + 'ms';
        });

        // ========== FRACTALS - SIERPINSKI TRIANGLE ==========
        const sierpinskiCanvas = document.getElementById('sierpinskiCanvas');
        const sierpinskiCtx = sierpinskiCanvas.getContext('2d');
        let sierpinskiAnimating = false;
        let sierpinskiShouldStop = false;

        function drawTriangle(x1, y1, x2, y2, x3, y3, color = '#5c6d82') {
            sierpinskiCtx.beginPath();
            sierpinskiCtx.moveTo(x1, y1);
            sierpinskiCtx.lineTo(x2, y2);
            sierpinskiCtx.lineTo(x3, y3);
            sierpinskiCtx.closePath();
            sierpinskiCtx.fillStyle = color;
            sierpinskiCtx.fill();
            sierpinskiCtx.strokeStyle = '#273E74';
            sierpinskiCtx.lineWidth = 1;
            sierpinskiCtx.stroke();
        }

        async function sierpinski(x1, y1, x2, y2, x3, y3, level, delay = 100) {
            if (sierpinskiShouldStop) return;
            
            if (level === 0) {
                drawTriangle(x1, y1, x2, y2, x3, y3, '#5c6d82');
                const current = parseInt(document.getElementById('sierpinskiTriangles').textContent);
                document.getElementById('sierpinskiTriangles').textContent = current + 1;
                await sleep(delay);
                return;
            }

            if (sierpinskiShouldStop) return;

            const midX1 = (x1 + x2) / 2;
            const midY1 = (y1 + y2) / 2;
            const midX2 = (x2 + x3) / 2;
            const midY2 = (y2 + y3) / 2;
            const midX3 = (x1 + x3) / 2;
            const midY3 = (y1 + y3) / 2;

            drawTriangle(midX1, midY1, midX2, midY2, midX3, midY3, '#F2F2F2');

            await sierpinski(x1, y1, midX1, midY1, midX3, midY3, level - 1, delay);
            if (sierpinskiShouldStop) return;
            await sierpinski(midX1, midY1, x2, y2, midX2, midY2, level - 1, delay);
            if (sierpinskiShouldStop) return;
            await sierpinski(midX3, midY3, midX2, midY2, x3, y3, level - 1, delay);
        }

        async function startSierpinski() {
            if (sierpinskiAnimating) return;
            sierpinskiAnimating = true;
            sierpinskiShouldStop = false;
            document.getElementById('sierpinskiStart').disabled = true;
            document.getElementById('sierpinskiLevel').disabled = true;

            sierpinskiCtx.clearRect(0, 0, sierpinskiCanvas.width, sierpinskiCanvas.height);
            document.getElementById('sierpinskiTriangles').textContent = 0;

            const level = parseInt(document.getElementById('sierpinskiLevel').value);
            const padding = 20;
            const x1 = sierpinskiCanvas.width / 2;
            const y1 = padding;
            const x2 = padding;
            const y2 = sierpinskiCanvas.height - padding;
            const x3 = sierpinskiCanvas.width - padding;
            const y3 = sierpinskiCanvas.height - padding;

            drawTriangle(x1, y1, x2, y2, x3, y3, '#5c6d82');

            const delay = level <= 3 ? 200 : level <= 5 ? 50 : 10;
            await sierpinski(x1, y1, x2, y2, x3, y3, level, delay);

            sierpinskiAnimating = false;
            document.getElementById('sierpinskiStart').disabled = false;
            document.getElementById('sierpinskiLevel').disabled = false;
        }

        function resetSierpinski() {
            sierpinskiShouldStop = true;
            sierpinskiAnimating = false;
            sierpinskiCtx.clearRect(0, 0, sierpinskiCanvas.width, sierpinskiCanvas.height);
            document.getElementById('sierpinskiTriangles').textContent = 0;
            document.getElementById('sierpinskiStart').disabled = false;
            document.getElementById('sierpinskiLevel').disabled = false;
        }

        document.getElementById('sierpinskiLevel').addEventListener('input', (e) => {
            document.getElementById('sierpinskiLevelValue').textContent = e.target.value;
        });

        // ========== FRACTALS - KOCH SNOWFLAKE ==========
        const kochCanvas = document.getElementById('kochCanvas');
        const kochCtx = kochCanvas.getContext('2d');
        let kochAnimating = false;
        let kochSegmentCount = 0;
        let kochShouldStop = false;

        function drawLine(x1, y1, x2, y2) {
            kochCtx.beginPath();
            kochCtx.moveTo(x1, y1);
            kochCtx.lineTo(x2, y2);
            kochCtx.strokeStyle = '#5c6d82';
            kochCtx.lineWidth = 2;
            kochCtx.stroke();
            kochSegmentCount++;
            document.getElementById('kochSegments').textContent = kochSegmentCount;
        }

        async function kochSegment(x1, y1, x2, y2, level, delay) {
            if (kochShouldStop) return;
            
            if (level === 0) {
                drawLine(x1, y1, x2, y2);
                await sleep(delay);
                return;
            }

            if (kochShouldStop) return;

            const deltaX = x2 - x1;
            const deltaY = y2 - y1;

            const x3 = x1 + deltaX / 3;
            const y3 = y1 + deltaY / 3;

            const x5 = x1 + 2 * deltaX / 3;
            const y5 = y1 + 2 * deltaY / 3;

            const angle = Math.PI / 3;
            const x4 = x3 + (x5 - x3) * Math.cos(angle) - (y5 - y3) * Math.sin(angle);
            const y4 = y3 + (x5 - x3) * Math.sin(angle) + (y5 - y3) * Math.cos(angle);

            await kochSegment(x1, y1, x3, y3, level - 1, delay);
            if (kochShouldStop) return;
            await kochSegment(x3, y3, x4, y4, level - 1, delay);
            if (kochShouldStop) return;
            await kochSegment(x4, y4, x5, y5, level - 1, delay);
            if (kochShouldStop) return;
            await kochSegment(x5, y5, x2, y2, level - 1, delay);
        }

        async function startKoch() {
            if (kochAnimating) return;
            kochAnimating = true;
            kochShouldStop = false;
            document.getElementById('kochStart').disabled = true;
            document.getElementById('kochLevel').disabled = true;

            kochCtx.clearRect(0, 0, kochCanvas.width, kochCanvas.height);
            kochSegmentCount = 0;
            document.getElementById('kochSegments').textContent = 0;

            const level = parseInt(document.getElementById('kochLevel').value);
            const centerX = kochCanvas.width / 2;
            const centerY = kochCanvas.height / 2;
            const size = 150;

            const x1 = centerX;
            const y1 = centerY - size;
            const x2 = centerX - size * Math.cos(Math.PI / 6);
            const y2 = centerY + size * Math.sin(Math.PI / 6);
            const x3 = centerX + size * Math.cos(Math.PI / 6);
            const y3 = centerY + size * Math.sin(Math.PI / 6);

            const delay = level <= 2 ? 100 : level <= 4 ? 20 : 1;

            await kochSegment(x1, y1, x2, y2, level, delay);
            if (kochShouldStop) {
                kochAnimating = false;
                document.getElementById('kochStart').disabled = false;
                document.getElementById('kochLevel').disabled = false;
                return;
            }
            await kochSegment(x2, y2, x3, y3, level, delay);
            if (kochShouldStop) {
                kochAnimating = false;
                document.getElementById('kochStart').disabled = false;
                document.getElementById('kochLevel').disabled = false;
                return;
            }
            await kochSegment(x3, y3, x1, y1, level, delay);

            kochAnimating = false;
            document.getElementById('kochStart').disabled = false;
            document.getElementById('kochLevel').disabled = false;
        }

        function resetKoch() {
            kochShouldStop = true;
            kochAnimating = false;
            kochCtx.clearRect(0, 0, kochCanvas.width, kochCanvas.height);
            kochSegmentCount = 0;
            document.getElementById('kochSegments').textContent = 0;
            document.getElementById('kochStart').disabled = false;
            document.getElementById('kochLevel').disabled = false;
        }

        document.getElementById('kochLevel').addEventListener('input', (e) => {
            document.getElementById('kochLevelValue').textContent = e.target.value;
        });

        // ========== MAZE GENERATION ==========
        const mazeCanvas = document.getElementById('mazeCanvas');
        const mazeCtx = mazeCanvas.getContext('2d');
        const mazeGridSize = 25;
        const mazeCellSize = mazeCanvas.width / mazeGridSize;
        let mazeGrid = [];
        let mazeAnimating = false;
        let mazeShouldStop = false;
        let mazeVisitedCount = 0;
        let mazeBacktrackCount = 0;

        function initMazeGrid() {
            mazeGrid = [];
            for (let i = 0; i < mazeGridSize; i++) {
                mazeGrid[i] = [];
                for (let j = 0; j < mazeGridSize; j++) {
                    mazeGrid[i][j] = {
                        row: i,
                        col: j,
                        visited: false,
                        walls: { top: true, right: true, bottom: true, left: true },
                        current: false,
                        path: false
                    };
                }
            }
            mazeVisitedCount = 0;
            mazeBacktrackCount = 0;
            document.getElementById('mazeVisited').textContent = 0;
            document.getElementById('mazeBacktracks').textContent = 0;
            document.getElementById('mazeSize').textContent = `${mazeGridSize}×${mazeGridSize}`;
            drawMaze();
        }

        function drawMaze() {
            mazeCtx.clearRect(0, 0, mazeCanvas.width, mazeCanvas.height);

            for (let i = 0; i < mazeGridSize; i++) {
                for (let j = 0; j < mazeGridSize; j++) {
                    const cell = mazeGrid[i][j];
                    const x = j * mazeCellSize;
                    const y = i * mazeCellSize;

                    // Preenche o fundo
                    if (i === 0 && j === 0) {
                        mazeCtx.fillStyle = '#4CAF50';
                    } else if (i === mazeGridSize - 1 && j === mazeGridSize - 1) {
                        mazeCtx.fillStyle = '#f44336';
                    } else if (cell.path) {
                        mazeCtx.fillStyle = '#FFD700';
                    } else if (cell.current) {
                        mazeCtx.fillStyle = '#5c6d82';
                    } else if (cell.visited) {
                        mazeCtx.fillStyle = 'white';
                    } else {
                        mazeCtx.fillStyle = '#333';
                    }
                    mazeCtx.fillRect(x, y, mazeCellSize, mazeCellSize);

                    // Desenha as paredes
                    mazeCtx.strokeStyle = '#000';
                    mazeCtx.lineWidth = 2;
                    mazeCtx.beginPath();

                    if (cell.walls.top) {
                        mazeCtx.moveTo(x, y);
                        mazeCtx.lineTo(x + mazeCellSize, y);
                    }
                    if (cell.walls.right) {
                        mazeCtx.moveTo(x + mazeCellSize, y);
                        mazeCtx.lineTo(x + mazeCellSize, y + mazeCellSize);
                    }
                    if (cell.walls.bottom) {
                        mazeCtx.moveTo(x + mazeCellSize, y + mazeCellSize);
                        mazeCtx.lineTo(x, y + mazeCellSize);
                    }
                    if (cell.walls.left) {
                        mazeCtx.moveTo(x, y + mazeCellSize);
                        mazeCtx.lineTo(x, y);
                    }

                    mazeCtx.stroke();
                }
            }
        }

        function getMazeNeighbors(cell) {
            const neighbors = [];
            const { row, col } = cell;

            if (row > 0) neighbors.push({ cell: mazeGrid[row - 1][col], direction: 'top' });
            if (col < mazeGridSize - 1) neighbors.push({ cell: mazeGrid[row][col + 1], direction: 'right' });
            if (row < mazeGridSize - 1) neighbors.push({ cell: mazeGrid[row + 1][col], direction: 'bottom' });
            if (col > 0) neighbors.push({ cell: mazeGrid[row][col - 1], direction: 'left' });

            return neighbors.filter(n => !n.cell.visited);
        }

        function removeWall(current, next, direction) {
            if (direction === 'top') {
                current.walls.top = false;
                next.walls.bottom = false;
            } else if (direction === 'right') {
                current.walls.right = false;
                next.walls.left = false;
            } else if (direction === 'bottom') {
                current.walls.bottom = false;
                next.walls.top = false;
            } else if (direction === 'left') {
                current.walls.left = false;
                next.walls.right = false;
            }
        }

        async function generateMazeRecursive(cell, stack) {
            if (mazeShouldStop) return;
            
            cell.visited = true;
            cell.current = true;
            mazeVisitedCount++;
            document.getElementById('mazeVisited').textContent = mazeVisitedCount;
            drawMaze();
            await sleep(parseInt(document.getElementById('mazeSpeed').value));
            
            if (mazeShouldStop) return; // ← ADICIONAR VERIFICAÇÃO EXTRA
            
            const neighbors = getMazeNeighbors(cell);
            
            if (neighbors.length > 0) {
                const random = neighbors[Math.floor(Math.random() * neighbors.length)];
                const nextCell = random.cell;
                stack.push(cell);
                removeWall(cell, nextCell, random.direction);
                cell.current = false;
                await generateMazeRecursive(nextCell, stack);
            } else if (stack.length > 0) {
                cell.current = false;
                mazeBacktrackCount++;
                document.getElementById('mazeBacktracks').textContent = mazeBacktrackCount;
                const prevCell = stack.pop();
                await generateMazeRecursive(prevCell, stack);
            } else {
                cell.current = false;
                drawMaze();
                await sleep(parseInt(document.getElementById('mazeSpeed').value));
            }
        }

        async function generateMaze() {
            if (mazeAnimating) return;
            mazeAnimating = true;
            mazeShouldStop = false;
            document.getElementById('mazeStart').disabled = true;
            document.getElementById('mazeSolve').disabled = true;

            initMazeGrid();
            const startCell = mazeGrid[0][0];
            const stack = [];

            await generateMazeRecursive(startCell, stack);

            mazeAnimating = false;
            document.getElementById('mazeStart').disabled = false;
            document.getElementById('mazeSolve').disabled = false;
        }

        async function solveMazeRecursive(cell, visited) {
            if (mazeShouldStop) return false; // ← JÁ EXISTE
            
            const { row, col } = cell;
            
            if (row === mazeGridSize - 1 && col === mazeGridSize - 1) {
                cell.path = true;
                drawMaze();
                return true;
            }
            
            visited.add(`${row},${col}`);
            cell.path = true;
            drawMaze();
            await sleep(parseInt(document.getElementById('mazeSpeed').value) * 2);
            
            // ← ADICIONAR VERIFICAÇÃO AQUI
            if (mazeShouldStop) return false;
            
            const neighbors = [
                { cell: mazeGrid[row - 1]?.[col], canGo: !cell.walls.top },
                { cell: mazeGrid[row][col + 1], canGo: !cell.walls.right },
                { cell: mazeGrid[row + 1]?.[col], canGo: !cell.walls.bottom },
                { cell: mazeGrid[row][col - 1], canGo: !cell.walls.left }
            ];
            
            for (const { cell: next, canGo } of neighbors) {
                if (mazeShouldStop) return false; // ← ADICIONAR AQUI TAMBÉM
                
                if (next && canGo && !visited.has(`${next.row},${next.col}`)) {
                    if (await solveMazeRecursive(next, visited)) {
                        return true;
                    }
                }
            }
            
            if (mazeShouldStop) return false; // ← E AQUI
            
            cell.path = false;
            drawMaze();
            await sleep(parseInt(document.getElementById('mazeSpeed').value));
            return false;
        }

        async function solveMaze() {
            if (mazeAnimating) return;
            
            let hasPath = false;
            for (let i = 0; i < mazeGridSize; i++) {
                for (let j = 0; j < mazeGridSize; j++) {
                    if (mazeGrid[i][j].visited) {
                        hasPath = true;
                        break;
                    }
                }
                if (hasPath) break;
            }

            if (!hasPath) {
                alert('Gere um labirinto primeiro!');
                return;
            }

            mazeAnimating = true;
            mazeShouldStop = false;
            document.getElementById('mazeStart').disabled = true;
            document.getElementById('mazeSolve').disabled = true;

            for (let i = 0; i < mazeGridSize; i++) {
                for (let j = 0; j < mazeGridSize; j++) {
                    mazeGrid[i][j].path = false;
                }
            }

            const startCell = mazeGrid[0][0];
            const visited = new Set();
            await solveMazeRecursive(startCell, visited);

            mazeAnimating = false;
            document.getElementById('mazeStart').disabled = false;
            document.getElementById('mazeSolve').disabled = false;
        }

        function resetMaze() {
            mazeShouldStop = true;
            
            // Aguardar um pouco para as recursões pararem
            setTimeout(() => {
                mazeAnimating = false;
                initMazeGrid();
                document.getElementById('mazeStart').disabled = false;
                document.getElementById('mazeSolve').disabled = false;
            }, 100); // ← Pequeno delay para garantir que as recursões parem
        }

        document.getElementById('mazeSpeed').addEventListener('input', (e) => {
            document.getElementById('mazeSpeedValue').textContent = e.target.value + 'ms';
        });

        // ========== CONVEX HULL (GRAHAM SCAN) ==========
        const convexCanvas = document.getElementById('convexCanvas');
        const convexCtx = convexCanvas.getContext('2d');
        let convexPoints = [];
        let convexHull = [];
        let convexAnimating = false;
        let convexShouldStop = false;

        function generateConvexPoints() {
            const numPoints = parseInt(document.getElementById('convexPoints').value);
            convexPoints = [];
            const padding = 40;
            
            for (let i = 0; i < numPoints; i++) {
                convexPoints.push({
                    x: Math.random() * (convexCanvas.width - 2 * padding) + padding,
                    y: Math.random() * (convexCanvas.height - 2 * padding) + padding,
                    onHull: false,
                    anchor: false,
                    current: false
                });
            }
            
            convexHull = [];
            document.getElementById('convexTotal').textContent = numPoints;
            document.getElementById('convexHullPoints').textContent = 0;
            document.getElementById('convexChecked').textContent = 0;
            drawConvexPoints();
        }

        function drawConvexPoints(currentPoint = null, stack = []) {
            convexCtx.clearRect(0, 0, convexCanvas.width, convexCanvas.height);

            // Desenha linhas do hull parcial
            if (stack.length > 1) {
                convexCtx.strokeStyle = '#64B5F6';
                convexCtx.lineWidth = 2;
                convexCtx.beginPath();
                convexCtx.moveTo(stack[0].x, stack[0].y);
                for (let i = 1; i < stack.length; i++) {
                    convexCtx.lineTo(stack[i].x, stack[i].y);
                }
                convexCtx.stroke();
            }

            // Desenha o hull final
            if (convexHull.length > 2) {
                convexCtx.strokeStyle = '#9C27B0';
                convexCtx.lineWidth = 3;
                convexCtx.beginPath();
                convexCtx.moveTo(convexHull[0].x, convexHull[0].y);
                for (let i = 1; i < convexHull.length; i++) {
                    convexCtx.lineTo(convexHull[i].x, convexHull[i].y);
                }
                convexCtx.closePath();
                convexCtx.stroke();

                // Preenche o polígono
                convexCtx.fillStyle = 'rgba(156, 39, 176, 0.1)';
                convexCtx.fill();
            }

            // Desenha os pontos
            convexPoints.forEach(point => {
                convexCtx.beginPath();
                convexCtx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                
                if (point.anchor) {
                    convexCtx.fillStyle = '#f44336';
                } else if (point === currentPoint) {
                    convexCtx.fillStyle = '#ff9800';
                } else if (point.onHull) {
                    convexCtx.fillStyle = '#4CAF50';
                } else {
                    convexCtx.fillStyle = '#5c6d82';
                }
                
                convexCtx.fill();
                convexCtx.strokeStyle = '#273E74';
                convexCtx.lineWidth = 1;
                convexCtx.stroke();
            });
        }

        function crossProduct(o, a, b) {
            return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
        }

        function polarAngle(anchor, point) {
            return Math.atan2(point.y - anchor.y, point.x - anchor.x);
        }

        function distance(p1, p2) {
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }

        async function startConvexHull() {
            if (convexAnimating) return;
            if (convexPoints.length < 3) {
                alert('Gere pelo menos 3 pontos primeiro!');
                return;
            }

            convexAnimating = true;
            convexShouldStop = false;
            document.getElementById('convexStart').disabled = true;
            document.getElementById('convexPoints').disabled = true;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Gerar Pontos')) btn.disabled = true;
            });

            // Limpa estados anteriores
            convexPoints.forEach(p => {
                p.onHull = false;
                p.anchor = false;
                p.current = false;
            });
            convexHull = [];
            document.getElementById('convexHullPoints').textContent = 0;
            document.getElementById('convexChecked').textContent = 0;

            // Passo 1: Encontra o ponto mais baixo (âncora)
            let anchor = convexPoints[0];
            for (let i = 1; i < convexPoints.length; i++) {
                if (convexPoints[i].y > anchor.y || 
                    (convexPoints[i].y === anchor.y && convexPoints[i].x < anchor.x)) {
                    anchor = convexPoints[i];
                }
            }
            anchor.anchor = true;
            drawConvexPoints();
            await sleep(parseInt(document.getElementById('convexSpeed').value));

            if (convexShouldStop) {
                convexAnimating = false;
                document.getElementById('convexStart').disabled = false;
                document.getElementById('convexPoints').disabled = false;
                document.querySelectorAll('button').forEach(btn => {
                    if (btn.textContent.includes('Gerar Pontos')) btn.disabled = false;
                });
                return;
            }

            // Passo 2: Ordena os pontos por ângulo polar
            const sortedPoints = convexPoints.filter(p => p !== anchor);
            sortedPoints.sort((a, b) => {
                const angleA = polarAngle(anchor, a);
                const angleB = polarAngle(anchor, b);
                if (angleA !== angleB) return angleA - angleB;
                return distance(anchor, a) - distance(anchor, b);
            });

            // Passo 3: Graham Scan
            const stack = [anchor];
            
            for (let i = 0; i < sortedPoints.length; i++) {
                if (convexShouldStop) break;

                const point = sortedPoints[i];
                point.current = true;
                
                const checked = parseInt(document.getElementById('convexChecked').textContent);
                document.getElementById('convexChecked').textContent = checked + 1;

                drawConvexPoints(point, stack);
                await sleep(parseInt(document.getElementById('convexSpeed').value));

                if (convexShouldStop) break;

                // Remove pontos que fazem curva para direita
                while (stack.length > 1 && 
                       crossProduct(stack[stack.length - 2], stack[stack.length - 1], point) <= 0) {
                    const removed = stack.pop();
                    removed.onHull = false;
                    
                    const hullCount = parseInt(document.getElementById('convexHullPoints').textContent);
                    document.getElementById('convexHullPoints').textContent = Math.max(0, hullCount - 1);
                    
                    drawConvexPoints(point, stack);
                    await sleep(parseInt(document.getElementById('convexSpeed').value) / 2);
                    
                    if (convexShouldStop) break;
                }

                if (convexShouldStop) break;

                stack.push(point);
                point.onHull = true;
                point.current = false;
                
                const hullCount = parseInt(document.getElementById('convexHullPoints').textContent);
                document.getElementById('convexHullPoints').textContent = hullCount + 1;

                drawConvexPoints(null, stack);
                await sleep(parseInt(document.getElementById('convexSpeed').value));
            }

            if (!convexShouldStop) {
                convexHull = [...stack];
                drawConvexPoints();
            }

            convexAnimating = false;
            document.getElementById('convexStart').disabled = false;
            document.getElementById('convexPoints').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Gerar Pontos')) btn.disabled = false;
            });
        }

        function resetConvex() {
            convexShouldStop = true;
            convexAnimating = false;
            convexPoints.forEach(p => {
                p.onHull = false;
                p.anchor = false;
                p.current = false;
            });
            convexHull = [];
            drawConvexPoints();
            document.getElementById('convexStart').disabled = false;
            document.getElementById('convexPoints').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Gerar Pontos')) btn.disabled = false;
            });
        }

        document.getElementById('convexSpeed').addEventListener('input', (e) => {
            document.getElementById('convexSpeedValue').textContent = e.target.value + 'ms';
        });

        document.getElementById('convexPoints').addEventListener('input', (e) => {
            document.getElementById('convexPointsValue').textContent = e.target.value;
        });

        // ========== FLOOD FILL ==========
        const floodCanvas = document.getElementById('floodCanvas');
        const floodCtx = floodCanvas.getContext('2d');
        const floodGridSize = 30;
        let floodGrid = [];
        let floodAnimating = false;
        let floodShouldStop = false;
        let isDrawingObstacle = false;
        let obstacleMode = null;

        const FLOOD_COLORS = {
            EMPTY: '#ffffff',
            OBSTACLE: '#333333',
            PROCESSING: '#ff9800',
            FILLED: '#5c6d82'
        };

        function getFloodCellSize() {
            return floodCanvas.width / floodGridSize;
        }

        function initFloodGrid() {
            floodGrid = [];
            for (let i = 0; i < floodGridSize; i++) {
                floodGrid[i] = [];
                for (let j = 0; j < floodGridSize; j++) {
                    floodGrid[i][j] = {
                        row: i,
                        col: j,
                        color: FLOOD_COLORS.EMPTY,
                        isObstacle: false
                    };
                }
            }
            document.getElementById('floodFilled').textContent = 0;
            document.getElementById('floodQueue').textContent = 0;
            drawFloodGrid();
        }

        function drawFloodGrid() {
            floodCtx.clearRect(0, 0, floodCanvas.width, floodCanvas.height);

            const cellSize = getFloodCellSize();

            for (let i = 0; i < floodGridSize; i++) {
                for (let j = 0; j < floodGridSize; j++) {
                    const cell = floodGrid[i][j];
                    const x = j * cellSize;
                    const y = i * cellSize;

                    floodCtx.fillStyle = cell.color;
                    floodCtx.fillRect(x, y, cellSize, cellSize);

                    floodCtx.strokeStyle = '#ddd';
                    floodCtx.lineWidth = 0.5;
                    floodCtx.strokeRect(x, y, cellSize, cellSize);
                }
            }
        }

        function generateFloodPattern() {
            if (floodAnimating) return;
            
            initFloodGrid();
            
            // Gera alguns obstáculos aleatórios
            const numObstacles = Math.floor(Math.random() * 50) + 30;
            for (let i = 0; i < numObstacles; i++) {
                const row = Math.floor(Math.random() * floodGridSize);
                const col = Math.floor(Math.random() * floodGridSize);
                floodGrid[row][col].isObstacle = true;
                floodGrid[row][col].color = FLOOD_COLORS.OBSTACLE;
            }
            
            // Adiciona algumas "ilhas" de obstáculos
            const numIslands = Math.floor(Math.random() * 5) + 2;
            for (let i = 0; i < numIslands; i++) {
                const startRow = Math.floor(Math.random() * (floodGridSize - 5));
                const startCol = Math.floor(Math.random() * (floodGridSize - 5));
                const size = Math.floor(Math.random() * 4) + 2;
                
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (startRow + r < floodGridSize && startCol + c < floodGridSize) {
                            floodGrid[startRow + r][startCol + c].isObstacle = true;
                            floodGrid[startRow + r][startCol + c].color = FLOOD_COLORS.OBSTACLE;
                        }
                    }
                }
            }
            
            drawFloodGrid();
        }

        function clearFloodGrid() {
            if (floodAnimating) return;
            initFloodGrid();
        }

        floodCanvas.addEventListener('mousedown', (e) => {
            if (floodAnimating) return;

            const { x, y } = getCanvasCoords(floodCanvas, e);
            const cellSize = getFloodCellSize();

            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (row >= 0 && row < floodGridSize && col >= 0 && col < floodGridSize) {
                if (e.button === 0) {
                    startFloodFill(row, col);
                } else if (e.button === 2) {
                    isDrawingObstacle = true;
                    obstacleMode = !floodGrid[row][col].isObstacle;
                    toggleObstacle(row, col);
                }
            }
        });

        floodCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        floodCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawingObstacle || floodAnimating) return;

            const { x, y } = getCanvasCoords(floodCanvas, e);
            const cellSize = getFloodCellSize();

            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (row >= 0 && row < floodGridSize && col >= 0 && col < floodGridSize) {
                if (floodGrid[row][col].isObstacle !== obstacleMode) {
                    toggleObstacle(row, col);
                }
            }
        });

        floodCanvas.addEventListener('mouseup', () => {
            isDrawingObstacle = false;
            obstacleMode = null;
        });

        floodCanvas.addEventListener('mouseleave', () => {
            isDrawingObstacle = false;
            obstacleMode = null;
        });

        function toggleObstacle(row, col) {
            const cell = floodGrid[row][col];
            if (cell.color === FLOOD_COLORS.EMPTY || cell.color === FLOOD_COLORS.OBSTACLE) {
                cell.isObstacle = !cell.isObstacle;
                cell.color = cell.isObstacle ? FLOOD_COLORS.OBSTACLE : FLOOD_COLORS.EMPTY;
                drawFloodGrid();
            }
        }

        async function floodFillBFS(startRow, startCol, targetColor, fillColor) {
            if (targetColor === fillColor) return;
            if (floodGrid[startRow][startCol].isObstacle) return;

            const queue = [{ row: startRow, col: startCol }];
            const visited = new Set();
            visited.add(`${startRow},${startCol}`);
            let filledCount = 0;

            const mode = document.getElementById('floodMode').value;
            const directions = mode === '4' 
                ? [[-1, 0], [1, 0], [0, -1], [0, 1]]
                : [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]];

            while (queue.length > 0 && !floodShouldStop) {
                document.getElementById('floodQueue').textContent = queue.length;

                const { row, col } = queue.shift();
                const cell = floodGrid[row][col];

                if (cell.color !== targetColor || cell.isObstacle) continue;

                cell.color = FLOOD_COLORS.PROCESSING;
                drawFloodGrid();
                await sleep(parseInt(document.getElementById('floodSpeed').value));

                if (floodShouldStop) break;

                cell.color = fillColor;
                filledCount++;
                document.getElementById('floodFilled').textContent = filledCount;
                drawFloodGrid();

                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    const key = `${newRow},${newCol}`;

                    if (newRow >= 0 && newRow < floodGridSize && 
                        newCol >= 0 && newCol < floodGridSize && 
                        !visited.has(key)) {
                        
                        const neighbor = floodGrid[newRow][newCol];
                        if (neighbor.color === targetColor && !neighbor.isObstacle) {
                            queue.push({ row: newRow, col: newCol });
                            visited.add(key);
                        }
                    }
                }
            }

            document.getElementById('floodQueue').textContent = 0;
        }

        function setFloodUIEnabled(enabled) {
            const controls = [
                document.querySelector('button[onclick="generateFloodPattern()"]'),
                document.querySelector('button[onclick="clearFloodGrid()"]'),
                document.getElementById('floodMode'),
                document.getElementById('floodColor'),
            ];

            controls.forEach(el => {
                if (!el) return;
                el.disabled = !enabled;
                el.style.opacity = enabled ? '1' : '0.5';
                el.style.cursor = enabled ? 'pointer' : 'not-allowed';
            });

            // Canvas: bloqueia interação
            floodCanvas.style.pointerEvents = enabled ? 'auto' : 'none';
        }

        async function startFloodFill(row, col) {
            if (floodAnimating) return;
            
            const cell = floodGrid[row][col];
            if (cell.isObstacle) return;

            floodAnimating = true;
            floodShouldStop = false;
            setFloodUIEnabled(false);
            document.getElementById('floodFilled').textContent = 0;

            const targetColor = cell.color;
            const fillColor = document.getElementById('floodColor').value;

            await floodFillBFS(row, col, targetColor, fillColor);

            floodAnimating = false;
            setFloodUIEnabled(true);
        }

        function resetFlood() {
            floodShouldStop = true;
            floodAnimating = false;
            setFloodUIEnabled(true);
            initFloodGrid();
        }

        document.getElementById('floodSpeed').addEventListener('input', (e) => {
            document.getElementById('floodSpeedValue').textContent = e.target.value + 'ms';
        });

        document.getElementById('floodMode').addEventListener('change', (e) => {
            const mode = e.target.value === '4' ? '4 Dir' : '8 Dir';
            document.getElementById('floodModeDisplay').textContent = mode;
        });

        // ========== VORONOI DIAGRAM ==========
        const voronoiCanvas = document.getElementById('voronoiCanvas');
        const voronoiCtx = voronoiCanvas.getContext('2d');
        let voronoiSeeds = [];
        let voronoiAnimating = false;
        let voronoiShouldStop = false;

        function generateVoronoiSeeds() {
            if (voronoiAnimating) return;
            
            const numSeeds = parseInt(document.getElementById('voronoiSeeds').value);
            voronoiSeeds = [];
            
            const padding = 30;
            for (let i = 0; i < numSeeds; i++) {
                const hue = (i * 360 / numSeeds) % 360;
                voronoiSeeds.push({
                    x: Math.random() * (voronoiCanvas.width - 2 * padding) + padding,
                    y: Math.random() * (voronoiCanvas.height - 2 * padding) + padding,
                    color: `hsl(${hue}, 70%, 60%)`
                });
            }
            
            document.getElementById('voronoiSeedCount').textContent = numSeeds;
            document.getElementById('voronoiPixels').textContent = 0;
            document.getElementById('voronoiProgress').textContent = '0%';
            
            drawVoronoiSeeds();
        }

        function drawVoronoiSeeds() {
            voronoiCtx.clearRect(0, 0, voronoiCanvas.width, voronoiCanvas.height);
            voronoiCtx.fillStyle = '#f0f0f0';
            voronoiCtx.fillRect(0, 0, voronoiCanvas.width, voronoiCanvas.height);
            
            voronoiSeeds.forEach(seed => {
                voronoiCtx.beginPath();
                voronoiCtx.arc(seed.x, seed.y, 6, 0, Math.PI * 2);
                voronoiCtx.fillStyle = seed.color;
                voronoiCtx.fill();
                voronoiCtx.strokeStyle = '#273E74';
                voronoiCtx.lineWidth = 2;
                voronoiCtx.stroke();
            });
        }

        function distanceSquared(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return dx * dx + dy * dy;
        }

        function findClosestSeed(x, y) {
            let minDist = Infinity;
            let closestSeed = null;
            
            for (const seed of voronoiSeeds) {
                const dist = distanceSquared(x, y, seed.x, seed.y);
                if (dist < minDist) {
                    minDist = dist;
                    closestSeed = seed;
                }
            }
            
            return closestSeed;
        }

        async function startVoronoi() {
            if (voronoiAnimating) return;
            if (voronoiSeeds.length === 0) {
                alert('Gere sementes primeiro!');
                return;
            }
            
            voronoiAnimating = true;
            voronoiShouldStop = false;
            document.getElementById('voronoiStart').disabled = true;
            document.getElementById('voronoiSeed').disabled = true;
            
            const mode = document.getElementById('voronoiMode').value;
            const showBorders = document.getElementById('voronoiBorders').checked;
            
            voronoiCtx.clearRect(0, 0, voronoiCanvas.width, voronoiCanvas.height);
            
            const width = voronoiCanvas.width;
            const height = voronoiCanvas.height;
            const totalPixels = width * height;
            
            if (mode === 'instant') {
                // Modo instantâneo - processa tudo de uma vez
                const imageData = voronoiCtx.createImageData(width, height);
                const data = imageData.data;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const seed = findClosestSeed(x, y);
                        const rgb = hslToRgb(seed.color);
                        
                        const index = (y * width + x) * 4;
                        data[index] = rgb.r;
                        data[index + 1] = rgb.g;
                        data[index + 2] = rgb.b;
                        data[index + 3] = 255;
                    }
                }
                
                voronoiCtx.putImageData(imageData, 0, 0);
                document.getElementById('voronoiPixels').textContent = totalPixels.toLocaleString();
                document.getElementById('voronoiProgress').textContent = '100%';
                
            } else {
                // Modo progressivo - anima linha por linha
                let pixelsProcessed = 0;
                const batchSize = 5; // Processa 5 linhas por vez
                
                for (let y = 0; y < height; y += batchSize) {
                    if (voronoiShouldStop) break;
                    
                    const batchHeight = Math.min(batchSize, height - y);
                    const imageData = voronoiCtx.createImageData(width, batchHeight);
                    const data = imageData.data;
                    
                    for (let by = 0; by < batchHeight; by++) {
                        for (let x = 0; x < width; x++) {
                            const seed = findClosestSeed(x, y + by);
                            const rgb = hslToRgb(seed.color);
                            
                            const index = (by * width + x) * 4;
                            data[index] = rgb.r;
                            data[index + 1] = rgb.g;
                            data[index + 2] = rgb.b;
                            data[index + 3] = 255;
                            
                            pixelsProcessed++;
                        }
                    }
                    
                    voronoiCtx.putImageData(imageData, 0, y);
                    
                    document.getElementById('voronoiPixels').textContent = pixelsProcessed.toLocaleString();
                    document.getElementById('voronoiProgress').textContent = 
                        Math.floor((pixelsProcessed / totalPixels) * 100) + '%';
                    
                    await sleep(1);
                }
            }
            
            // Desenha bordas se ativado
            if (showBorders && !voronoiShouldStop) {
                drawVoronoiBorders();
            }
            
            // Redesenha as sementes por cima
            voronoiSeeds.forEach(seed => {
                voronoiCtx.beginPath();
                voronoiCtx.arc(seed.x, seed.y, 6, 0, Math.PI * 2);
                voronoiCtx.fillStyle = seed.color;
                voronoiCtx.fill();
                voronoiCtx.strokeStyle = '#273E74';
                voronoiCtx.lineWidth = 2;
                voronoiCtx.stroke();
            });
            
            voronoiAnimating = false;
            document.getElementById('voronoiStart').disabled = false;
            document.getElementById('voronoiSeed').disabled = false;
        }

        function drawVoronoiBorders() {
            const width = voronoiCanvas.width;
            const height = voronoiCanvas.height;
            
            voronoiCtx.strokeStyle = '#273E74';
            voronoiCtx.lineWidth = 1;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const current = findClosestSeed(x, y);
                    const right = findClosestSeed(x + 1, y);
                    const bottom = findClosestSeed(x, y + 1);
                    
                    if (current !== right) {
                        voronoiCtx.beginPath();
                        voronoiCtx.moveTo(x + 0.5, y);
                        voronoiCtx.lineTo(x + 0.5, y + 1);
                        voronoiCtx.stroke();
                    }
                    
                    if (current !== bottom) {
                        voronoiCtx.beginPath();
                        voronoiCtx.moveTo(x, y + 0.5);
                        voronoiCtx.lineTo(x + 1, y + 0.5);
                        voronoiCtx.stroke();
                    }
                }
            }
        }

        function hslToRgb(hslString) {
            // Extrai os valores HSL da string de forma mais flexível
            const match = hslString.match(/(\d+(\.\d+)?)/g);
            if (!match || match.length < 3) return { r: 0, g: 0, b: 0 };
            
            const h = parseInt(match[0]) / 360;
            const s = parseInt(match[1]) / 100;
            const l = parseInt(match[2]) / 100;
            
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        function resetVoronoi() {
            voronoiShouldStop = true;
            voronoiAnimating = false;
            drawVoronoiSeeds();
            document.getElementById('voronoiStart').disabled = false;
            document.getElementById('voronoiSeed').disabled = false;
        }

        document.getElementById('voronoiSeeds').addEventListener('input', (e) => {
            document.getElementById('voronoiSeedsValue').textContent = e.target.value;
        });

        // ========== BFS TREE ==========
        const bfsCanvas = document.getElementById('bfsCanvas');
        const bfsCtx = bfsCanvas.getContext('2d');
        let bfsNodes = [];
        let bfsEdges = [];
        let bfsAnimating = false;
        let bfsShouldStop = false;

        class BFSNode {
            constructor(id, x, y, level = 0) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.level = level;
                this.visited = false;
                this.inQueue = false;
                this.processing = false;
                this.isRoot = false;
                this.neighbors = [];
            }
        }

        function generateBFSGraph() {
            if (bfsAnimating) return;
            
            const type = document.getElementById('bfsGraphType').value;
            bfsNodes = [];
            bfsEdges = [];
            
            if (type === 'tree') {
                generateBinaryTree();
            } else if (type === 'grid') {
                generateGridGraph();
            }
            
            document.getElementById('bfsVisited').textContent = 0;
            document.getElementById('bfsQueue').textContent = 0;
            document.getElementById('bfsLevel').textContent = 0;
            drawBFSGraph();
        }

        document.getElementById('bfsGraphType').addEventListener('change', () => {
            generateBFSGraph();
        });

        function generateBinaryTree() {
            const levels = 4;
            const startX = bfsCanvas.width / 2;
            const startY = 50;
            const levelGap = 120;
            
            let nodeId = 0;
            const queue = [{ id: nodeId++, x: startX, y: startY, level: 0, parentId: null }];
            
            while (queue.length > 0) {
                const current = queue.shift();
                const node = new BFSNode(current.id, current.x, current.y, current.level);
                
                if (current.level === 0) node.isRoot = true;
                bfsNodes.push(node);
                
                if (current.parentId !== null) {
                    bfsEdges.push({ from: current.parentId, to: current.id });
                    bfsNodes[current.parentId].neighbors.push(current.id);
                    node.neighbors.push(current.parentId);
                }
                
                if (current.level < levels - 1) {
                    const gap = bfsCanvas.width / Math.pow(2, current.level + 2);
                    
                    // Filho esquerdo
                    queue.push({
                        id: nodeId++,
                        x: current.x - gap,
                        y: current.y + levelGap,
                        level: current.level + 1,
                        parentId: current.id
                    });
                    
                    // Filho direito
                    queue.push({
                        id: nodeId++,
                        x: current.x + gap,
                        y: current.y + levelGap,
                        level: current.level + 1,
                        parentId: current.id
                    });
                }
            }
        }

        function generateRandomGraph() {
            const numNodes = 15;
            const padding = 80;
            
            for (let i = 0; i < numNodes; i++) {
                const node = new BFSNode(
                    i,
                    Math.random() * (bfsCanvas.width - 2 * padding) + padding,
                    Math.random() * (bfsCanvas.height - 2 * padding) + padding
                );
                if (i === 0) node.isRoot = true;
                bfsNodes.push(node);
            }
            
            // Cria arestas aleatórias
            for (let i = 0; i < bfsNodes.length; i++) {
                const numConnections = Math.floor(Math.random() * 3) + 1;
                for (let j = 0; j < numConnections; j++) {
                    let target = Math.floor(Math.random() * bfsNodes.length);
                    if (target !== i && !bfsNodes[i].neighbors.includes(target)) {
                        bfsNodes[i].neighbors.push(target);
                        bfsNodes[target].neighbors.push(i);
                        bfsEdges.push({ from: i, to: target });
                    }
                }
            }
        }

        function generateGridGraph() {
            const rows = 6;
            const cols = 8;
            const cellWidth = (bfsCanvas.width - 100) / cols;
            const cellHeight = (bfsCanvas.height - 100) / rows;
            const startX = 50;
            const startY = 50;
            
            let nodeId = 0;
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const node = new BFSNode(
                        nodeId++,
                        startX + c * cellWidth + cellWidth / 2,
                        startY + r * cellHeight + cellHeight / 2
                    );
                    if (r === 0 && c === 0) node.isRoot = true;
                    bfsNodes.push(node);
                }
            }
            
            // Conecta vizinhos (4 direções)
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const currentId = r * cols + c;
                    
                    // Direita
                    if (c < cols - 1) {
                        const rightId = r * cols + (c + 1);
                        bfsNodes[currentId].neighbors.push(rightId);
                        bfsEdges.push({ from: currentId, to: rightId });
                    }
                    
                    // Baixo
                    if (r < rows - 1) {
                        const downId = (r + 1) * cols + c;
                        bfsNodes[currentId].neighbors.push(downId);
                        bfsEdges.push({ from: currentId, to: downId });
                    }
                }
            }
        }

        function drawBFSGraph() {
            bfsCtx.clearRect(0, 0, bfsCanvas.width, bfsCanvas.height);
            
            // Desenha arestas
            bfsCtx.strokeStyle = '#999';
            bfsCtx.lineWidth = 2;
            bfsEdges.forEach(edge => {
                const from = bfsNodes[edge.from];
                const to = bfsNodes[edge.to];
                
                bfsCtx.beginPath();
                bfsCtx.moveTo(from.x, from.y);
                bfsCtx.lineTo(to.x, to.y);
                bfsCtx.stroke();
            });
            
            // Desenha nós
            bfsNodes.forEach(node => {
                bfsCtx.beginPath();
                bfsCtx.arc(node.x, node.y, 20, 0, Math.PI * 2);
                
                if (node.isRoot && !node.visited && !node.processing) {
                    bfsCtx.fillStyle = '#f44336';
                } else if (node.processing) {
                    bfsCtx.fillStyle = '#ff9800';
                } else if (node.visited) {
                    bfsCtx.fillStyle = '#4CAF50';
                } else if (node.inQueue) {
                    bfsCtx.fillStyle = '#64B5F6';
                } else {
                    bfsCtx.fillStyle = 'white';
                }
                
                bfsCtx.fill();
                bfsCtx.strokeStyle = '#273E74';
                bfsCtx.lineWidth = 2;
                bfsCtx.stroke();
                
                // Desenha ID do nó
                bfsCtx.fillStyle = '#273E74';
                bfsCtx.font = 'bold 14px Arial';
                bfsCtx.textAlign = 'center';
                bfsCtx.textBaseline = 'middle';
                bfsCtx.fillText(node.id, node.x, node.y);
            });
        }

        async function startBFSTraversal() {
            if (bfsAnimating) return;
            if (bfsNodes.length === 0) {
                alert('Gere um grafo primeiro!');
                return;
            }
            
            bfsAnimating = true;
            bfsShouldStop = false;
            document.getElementById('bfsStart').disabled = true;
            document.getElementById('bfsGraphType').disabled = true;
            
            // Reset
            bfsNodes.forEach(node => {
                node.visited = false;
                node.inQueue = false;
                node.processing = false;
            });
            
            const queue = [0]; // Começa pelo nó 0 (raiz)
            bfsNodes[0].inQueue = true;
            let visitedCount = 0;
            let currentLevel = 0;
            
            document.getElementById('bfsLevel').textContent = currentLevel;
            drawBFSGraph();
            await sleep(parseInt(document.getElementById('bfsSpeed').value));
            
            while (queue.length > 0 && !bfsShouldStop) {
                document.getElementById('bfsQueue').textContent = queue.length;
                
                const currentId = queue.shift();
                const currentNode = bfsNodes[currentId];
                
                currentNode.inQueue = false;
                currentNode.processing = true;
                
                drawBFSGraph();
                await sleep(parseInt(document.getElementById('bfsSpeed').value));
                
                if (bfsShouldStop) break;
                
                currentNode.processing = false;
                currentNode.visited = true;
                visitedCount++;
                
                document.getElementById('bfsVisited').textContent = visitedCount;
                
                // Atualiza nível (baseado na árvore BFS)
                if (currentNode.level > currentLevel) {
                    currentLevel = currentNode.level;
                    document.getElementById('bfsLevel').textContent = currentLevel;
                }
                
                drawBFSGraph();
                await sleep(parseInt(document.getElementById('bfsSpeed').value) / 2);
                
                // Adiciona vizinhos não visitados à fila
                for (const neighborId of currentNode.neighbors) {
                    const neighbor = bfsNodes[neighborId];
                    if (!neighbor.visited && !neighbor.inQueue && !neighbor.processing) {
                        if (bfsShouldStop) return;
                        neighbor.inQueue = true;
                        neighbor.level = currentNode.level + 1;
                        queue.push(neighborId);
                    }
                }
                
                drawBFSGraph();
                await sleep(parseInt(document.getElementById('bfsSpeed').value) / 2);
            }
            
            document.getElementById('bfsQueue').textContent = 0;
            bfsAnimating = false;
            document.getElementById('bfsStart').disabled = false;
            document.getElementById('bfsGraphType').disabled = false;
        }

        function resetBFS() {
            bfsShouldStop = true;
            bfsAnimating = false;
            
            bfsNodes.forEach(node => {
                node.visited = false;
                node.inQueue = false;
                node.processing = false;
                node.level = 0;
            });
            
            drawBFSGraph();
            document.getElementById('bfsStart').disabled = false;
            document.getElementById('bfsGraphType').disabled = false;
            document.getElementById('bfsVisited').textContent = 0;
            document.getElementById('bfsQueue').textContent = 0;
            document.getElementById('bfsLevel').textContent = 0;
        }

        document.getElementById('bfsSpeed').addEventListener('input', (e) => {
            document.getElementById('bfsSpeedValue').textContent = e.target.value + 'ms';
        });

        // ========== GAME OF LIFE ==========
        const golCanvas = document.getElementById('gameOfLifeCanvas');
        const golCtx = golCanvas.getContext('2d');
        const golGridSize = 40;
        let golGrid = [];
        let golRunning = false;
        let golInterval = null;
        let golGeneration = 0;
        let golMaxPopulation = 0;
        let isDrawingGOL = false;
        let drawModeGOL = null;

        function getGolCellSize() {
            return golCanvas.width / golGridSize;
        }

        function initGameOfLife() {
            golGrid = [];
            for (let i = 0; i < golGridSize; i++) {
                golGrid[i] = [];
                for (let j = 0; j < golGridSize; j++) {
                    golGrid[i][j] = {
                        alive: false,
                        wasAlive: false,
                        justBorn: false,
                        justDied: false
                    };
                }
            }
            golGeneration = 0;
            golMaxPopulation = 0;
            updateGOLStats();
            drawGameOfLife();
        }

        function drawGameOfLife() {
            golCtx.clearRect(0, 0, golCanvas.width, golCanvas.height);

            const cellSize = getGolCellSize();

            for (let i = 0; i < golGridSize; i++) {
                for (let j = 0; j < golGridSize; j++) {
                    const cell = golGrid[i][j];
                    const x = j * cellSize;
                    const y = i * cellSize;

                    if (cell.justBorn) {
                        golCtx.fillStyle = '#4CAF50';
                    } else if (cell.justDied) {
                        golCtx.fillStyle = '#f44336';
                    } else if (cell.alive) {
                        golCtx.fillStyle = '#5c6d82';
                    } else {
                        golCtx.fillStyle = '#ffffff';
                    }

                    golCtx.fillRect(x, y, cellSize, cellSize);
                    golCtx.strokeStyle = '#ddd';
                    golCtx.lineWidth = 0.5;
                    golCtx.strokeRect(x, y, cellSize, cellSize);
                }
            }
        }

        function countNeighbors(row, col) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const newRow = (row + i + golGridSize) % golGridSize;
                    const newCol = (col + j + golGridSize) % golGridSize;
                    if (golGrid[newRow][newCol].wasAlive) count++;
                }
            }
            return count;
        }

        function stepGameOfLife() {
            // Salva estado atual
            for (let i = 0; i < golGridSize; i++) {
                for (let j = 0; j < golGridSize; j++) {
                    golGrid[i][j].wasAlive = golGrid[i][j].alive;
                    golGrid[i][j].justBorn = false;
                    golGrid[i][j].justDied = false;
                }
            }

            // Aplica regras
            for (let i = 0; i < golGridSize; i++) {
                for (let j = 0; j < golGridSize; j++) {
                    const neighbors = countNeighbors(i, j);
                    const cell = golGrid[i][j];

                    if (cell.wasAlive) {
                        if (neighbors < 2 || neighbors > 3) {
                            cell.alive = false;
                            cell.justDied = true;
                        }
                    } else {
                        if (neighbors === 3) {
                            cell.alive = true;
                            cell.justBorn = true;
                        }
                    }
                }
            }

            golGeneration++;
            updateGOLStats();
            drawGameOfLife();

            // Limpa marcadores após um tempo
            setTimeout(() => {
                for (let i = 0; i < golGridSize; i++) {
                    for (let j = 0; j < golGridSize; j++) {
                        golGrid[i][j].justBorn = false;
                        golGrid[i][j].justDied = false;
                    }
                }
                drawGameOfLife();
            }, 150);
        }

        function toggleGameOfLife() {
            golRunning = !golRunning;
            const btn = document.getElementById('golToggle');

            if (golRunning) {
                btn.textContent = 'Pausar';
                document.getElementById('stepGameOfLifeBtn').disabled = true;
                golInterval = setInterval(() => {
                    stepGameOfLife();
                }, parseInt(document.getElementById('golSpeed').value));
            } else {
                btn.textContent = 'Iniciar';
                document.getElementById('stepGameOfLifeBtn').disabled = false;
                if (golInterval) {
                    clearInterval(golInterval);
                    golInterval = null;
                }
            }
        }

        function clearGameOfLife() {
            if (golRunning) toggleGameOfLife();
            initGameOfLife();
        }

        function randomizeGameOfLife() {
            if (golRunning) toggleGameOfLife();
            for (let i = 0; i < golGridSize; i++) {
                for (let j = 0; j < golGridSize; j++) {
                    golGrid[i][j].alive = Math.random() < 0.3;
                    golGrid[i][j].wasAlive = golGrid[i][j].alive;
                }
            }
            golGeneration = 0;
            updateGOLStats();
            drawGameOfLife();
        }

        function updateGOLStats() {
            let aliveCount = 0;
            for (let i = 0; i < golGridSize; i++) {
                for (let j = 0; j < golGridSize; j++) {
                    if (golGrid[i][j].alive) aliveCount++;
                }
            }
            document.getElementById('golGeneration').textContent = golGeneration;
            document.getElementById('golAliveCells').textContent = aliveCount;
            if (aliveCount > golMaxPopulation) {
                golMaxPopulation = aliveCount;
                document.getElementById('golMaxPop').textContent = golMaxPopulation;
            }
        }

        golCanvas.addEventListener('mousedown', (e) => {
            if (golRunning) return;

            const { x, y } = getCanvasCoords(golCanvas, e);
            const cellSize = getGolCellSize();

            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (row >= 0 && row < golGridSize && col >= 0 && col < golGridSize) {
                isDrawingGOL = true;
                drawModeGOL = !golGrid[row][col].alive;
                golGrid[row][col].alive = drawModeGOL;
                golGrid[row][col].wasAlive = drawModeGOL;
                updateGOLStats();
                drawGameOfLife();
            }
        });

        golCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawingGOL || golRunning) return;

            const { x, y } = getCanvasCoords(golCanvas, e);
            const cellSize = getGolCellSize();

            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (row >= 0 && row < golGridSize && col >= 0 && col < golGridSize) {
                if (golGrid[row][col].alive !== drawModeGOL) {
                    golGrid[row][col].alive = drawModeGOL;
                    golGrid[row][col].wasAlive = drawModeGOL;
                    updateGOLStats();
                    drawGameOfLife();
                }
            }
        });

        golCanvas.addEventListener('mouseup', () => {
            isDrawingGOL = false;
            drawModeGOL = null;
        });

        golCanvas.addEventListener('mouseleave', () => {
            isDrawingGOL = false;
            drawModeGOL = null;
        });

        // Padrões clássicos
        function loadPattern(pattern, startRow, startCol) {
            if (golRunning) toggleGameOfLife();
            clearGameOfLife();

            pattern.forEach((row, i) => {
                row.forEach((cell, j) => {
                    if (startRow + i < golGridSize && startCol + j < golGridSize) {
                        golGrid[startRow + i][startCol + j].alive = cell === 1;
                        golGrid[startRow + i][startCol + j].wasAlive = cell === 1;
                    }
                });
            });

            updateGOLStats();
            drawGameOfLife();
        }

        function loadGlider() {
            const glider = [
                [0, 1, 0],
                [0, 0, 1],
                [1, 1, 1]
            ];
            loadPattern(glider, 5, 5);
        }

        function loadBlinker() {
            const blinker = [
                [1, 1, 1]
            ];
            loadPattern(blinker, 10, 10);
        }

        function loadToad() {
            const toad = [
                [0, 1, 1, 1],
                [1, 1, 1, 0]
            ];
            loadPattern(toad, 15, 15);
        }

        function loadBeacon() {
            const beacon = [
                [1, 1, 0, 0],
                [1, 1, 0, 0],
                [0, 0, 1, 1],
                [0, 0, 1, 1]
            ];
            loadPattern(beacon, 20, 20);
        }

        function loadGliderGun() {
            const gun = [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ];
            loadPattern(gun, 10, 5);
        }

        document.getElementById('golSpeed').addEventListener('input', (e) => {
            document.getElementById('golSpeedValue').textContent = e.target.value + 'ms';
            if (golRunning) {
                clearInterval(golInterval);
                golInterval = setInterval(() => {
                    stepGameOfLife();
                }, parseInt(e.target.value));
            }
        });

        // ========== WAVE FUNCTION COLLAPSE ==========
        const wfcCanvas = document.getElementById('wfcCanvas');
        const wfcCtx = wfcCanvas.getContext('2d');
        const wfcGridSize = 30;
        const wfcCellSize = wfcCanvas.width / wfcGridSize;
        let wfcGrid = [];
        let wfcAnimating = false;
        let wfcShouldStop = false;
        let wfcTiles = {};

        // Define tiles e regras de adjacência
        const tilesets = {
            simple: {
                tiles: [
                    { id: 0, color: '#000000', name: 'black' },
                    { id: 1, color: '#888888', name: 'gray' },
                    { id: 2, color: '#ffffff', name: 'white' }
                ],
                rules: {
                    0: { top: [0,1], right: [0,1], bottom: [0,1], left: [0,1] },
                    1: { top: [0,1,2], right: [0,1,2], bottom: [0,1,2], left: [0,1,2] },
                    2: { top: [1,2], right: [1,2], bottom: [1,2], left: [1,2] }
                }
            },
            terrain: {
                tiles: [
                    { id: 0, color: '#1E88E5', name: 'water' },
                    { id: 1, color: '#FFD54F', name: 'sand' },
                    { id: 2, color: '#66BB6A', name: 'grass' },
                    { id: 3, color: '#2E7D32', name: 'forest' },
                    { id: 4, color: '#795548', name: 'mountain' }
                ],
                rules: {
                    0: { top: [0,1], right: [0,1], bottom: [0,1], left: [0,1] },
                    1: { top: [0,1,2], right: [0,1,2], bottom: [0,1,2], left: [0,1,2] },
                    2: { top: [1,2,3], right: [1,2,3], bottom: [1,2,3], left: [1,2,3] },
                    3: { top: [2,3,4], right: [2,3,4], bottom: [2,3,4], left: [2,3,4] },
                    4: { top: [3,4], right: [3,4], bottom: [3,4], left: [3,4] }
                }
            },
            pipes: {
                tiles: [
                    { id: 0, color: '#333333', edges: [0,0,0,0], name: 'empty' },
                    { id: 1, color: '#5c6d82', edges: [1,0,1,0], name: 'vertical' },
                    { id: 2, color: '#5c6d82', edges: [0,1,0,1], name: 'horizontal' },
                    { id: 3, color: '#5c6d82', edges: [1,1,0,0], name: 'corner_tr' },
                    { id: 4, color: '#5c6d82', edges: [0,1,1,0], name: 'corner_br' },
                    { id: 5, color: '#5c6d82', edges: [0,0,1,1], name: 'corner_bl' }
                ],
                rules: null // Será calculado baseado em edges
            }
        };

        function initWFC() {
            const pattern = document.getElementById('wfcPattern').value;
            const tileset = tilesets[pattern];
            wfcTiles = tileset;

            // Calcula regras para pipes baseado em edges
            if (pattern === 'pipes') {
                wfcTiles.rules = {};
                tileset.tiles.forEach(tile => {
                    wfcTiles.rules[tile.id] = {
                        top: tileset.tiles.filter(t => t.edges[2] === tile.edges[0]).map(t => t.id),
                        right: tileset.tiles.filter(t => t.edges[3] === tile.edges[1]).map(t => t.id),
                        bottom: tileset.tiles.filter(t => t.edges[0] === tile.edges[2]).map(t => t.id),
                        left: tileset.tiles.filter(t => t.edges[1] === tile.edges[3]).map(t => t.id)
                    };
                });
            }

            wfcGrid = [];
            for (let i = 0; i < wfcGridSize; i++) {
                wfcGrid[i] = [];
                for (let j = 0; j < wfcGridSize; j++) {
                    wfcGrid[i][j] = {
                        collapsed: false,
                        collapsing: false,
                        propagating: false,
                        possibilities: tileset.tiles.map(t => t.id)
                    };
                }
            }

            document.getElementById('wfcCollapsed').textContent = 0;
            document.getElementById('wfcEntropy').textContent = '-';
            document.getElementById('wfcProgress').textContent = '0%';
            drawWFC();
        }

        function drawWFC() {
            wfcCtx.clearRect(0, 0, wfcCanvas.width, wfcCanvas.height);

            for (let i = 0; i < wfcGridSize; i++) {
                for (let j = 0; j < wfcGridSize; j++) {
                    const cell = wfcGrid[i][j];
                    const x = j * wfcCellSize;
                    const y = i * wfcCellSize;

                    if (cell.collapsing) {
                        wfcCtx.fillStyle = '#ff9800';
                    } else if (cell.propagating) {
                        wfcCtx.fillStyle = '#64B5F6';
                    } else if (cell.collapsed) {
                        const tileId = cell.possibilities[0];
                        const tile = wfcTiles.tiles.find(t => t.id === tileId);
                        wfcCtx.fillStyle = tile.color;
                    } else {
                        wfcCtx.fillStyle = '#f0f0f0';
                    }

                    wfcCtx.fillRect(x, y, wfcCellSize, wfcCellSize);

                    // Desenha tubos se for o padrão pipes
                    if (cell.collapsed && document.getElementById('wfcPattern').value === 'pipes') {
                        const tileId = cell.possibilities[0];
                        const tile = wfcTiles.tiles.find(t => t.id === tileId);
                        if (tile.edges) {
                            drawPipe(x, y, tile.edges);
                        }
                    }

                    wfcCtx.strokeStyle = '#ddd';
                    wfcCtx.lineWidth = 0.5;
                    wfcCtx.strokeRect(x, y, wfcCellSize, wfcCellSize);

                    // Mostra entropia
                    if (!cell.collapsed && cell.possibilities.length < wfcTiles.tiles.length) {
                        wfcCtx.fillStyle = '#273E74';
                        wfcCtx.font = '10px Arial';
                        wfcCtx.textAlign = 'center';
                        wfcCtx.textBaseline = 'middle';
                        wfcCtx.fillText(cell.possibilities.length, x + wfcCellSize/2, y + wfcCellSize/2);
                    }
                }
            }
        }

        function drawPipe(x, y, edges) {
            const cx = x + wfcCellSize / 2;
            const cy = y + wfcCellSize / 2;
            const lineWidth = wfcCellSize * 0.3;

            wfcCtx.strokeStyle = '#FFD700';
            wfcCtx.lineWidth = lineWidth;
            wfcCtx.lineCap = 'round';

            if (edges[0]) { // top
                wfcCtx.beginPath();
                wfcCtx.moveTo(cx, cy);
                wfcCtx.lineTo(cx, y);
                wfcCtx.stroke();
            }
            if (edges[1]) { // right
                wfcCtx.beginPath();
                wfcCtx.moveTo(cx, cy);
                wfcCtx.lineTo(x + wfcCellSize, cy);
                wfcCtx.stroke();
            }
            if (edges[2]) { // bottom
                wfcCtx.beginPath();
                wfcCtx.moveTo(cx, cy);
                wfcCtx.lineTo(cx, y + wfcCellSize);
                wfcCtx.stroke();
            }
            if (edges[3]) { // left
                wfcCtx.beginPath();
                wfcCtx.moveTo(cx, cy);
                wfcCtx.lineTo(x, cy);
                wfcCtx.stroke();
            }
        }

        function findMinEntropyCell() {
            let minEntropy = Infinity;
            let candidates = [];

            for (let i = 0; i < wfcGridSize; i++) {
                for (let j = 0; j < wfcGridSize; j++) {
                    const cell = wfcGrid[i][j];
                    if (!cell.collapsed) {
                        const entropy = cell.possibilities.length;
                        if (entropy < minEntropy) {
                            minEntropy = entropy;
                            candidates = [{i, j}];
                        } else if (entropy === minEntropy) {
                            candidates.push({i, j});
                        }
                    }
                }
            }

            if (candidates.length === 0) return null;
            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        async function propagate(row, col) {
            const stack = [{row, col}];
            const visited = new Set();

            while (stack.length > 0 && !wfcShouldStop) {
                const current = stack.pop();
                const key = `${current.row},${current.col}`;
                if (visited.has(key)) continue;
                visited.add(key);

                const cell = wfcGrid[current.row][current.col];
                cell.propagating = true;
                drawWFC();
                await sleep(parseInt(document.getElementById('wfcSpeed').value) / 4);

                const neighbors = [
                    { row: current.row - 1, col: current.col, dir: 'top', opposite: 'bottom' },
                    { row: current.row, col: current.col + 1, dir: 'right', opposite: 'left' },
                    { row: current.row + 1, col: current.col, dir: 'bottom', opposite: 'top' },
                    { row: current.row, col: current.col - 1, dir: 'left', opposite: 'right' }
                ];

                for (const neighbor of neighbors) {
                    if (neighbor.row < 0 || neighbor.row >= wfcGridSize || 
                        neighbor.col < 0 || neighbor.col >= wfcGridSize) continue;

                    const neighborCell = wfcGrid[neighbor.row][neighbor.col];
                    if (neighborCell.collapsed) continue;

                    const validTiles = new Set();
                    for (const tileId of cell.possibilities) {
                        const allowedNeighbors = wfcTiles.rules[tileId][neighbor.dir];
                        allowedNeighbors.forEach(t => validTiles.add(t));
                    }

                    const oldLength = neighborCell.possibilities.length;
                    neighborCell.possibilities = neighborCell.possibilities.filter(p => validTiles.has(p));

                    if (neighborCell.possibilities.length === 0) {
                        // Contradiction - tentaria backtrack aqui, mas simplificando
                        neighborCell.possibilities = wfcTiles.tiles.map(t => t.id);
                    }

                    if (neighborCell.possibilities.length < oldLength) {
                        stack.push({ row: neighbor.row, col: neighbor.col });
                    }
                }

                cell.propagating = false;
            }
        }

        async function startWFC() {
            if (wfcAnimating) return;
            wfcAnimating = true;
            wfcShouldStop = false;
            document.getElementById('wfcStart').disabled = true;

            initWFC();

            let collapsedCount = 0;
            const totalCells = wfcGridSize * wfcGridSize;

            while (collapsedCount < totalCells && !wfcShouldStop) {
                const cell = findMinEntropyCell();
                if (!cell) break;

                const currentCell = wfcGrid[cell.i][cell.j];
                
                document.getElementById('wfcEntropy').textContent = currentCell.possibilities.length;

                currentCell.collapsing = true;
                if (!wfcAnimating) return;
                drawWFC();
                await sleep(parseInt(document.getElementById('wfcSpeed').value));

                if (wfcShouldStop) break;

                // Colapsa para uma escolha aleatória
                const choice = currentCell.possibilities[Math.floor(Math.random() * currentCell.possibilities.length)];
                currentCell.possibilities = [choice];
                currentCell.collapsed = true;
                currentCell.collapsing = false;
                collapsedCount++;

                document.getElementById('wfcCollapsed').textContent = collapsedCount;
                document.getElementById('wfcProgress').textContent = 
                    Math.floor((collapsedCount / totalCells) * 100) + '%';

                if (!wfcAnimating) return;
                drawWFC();
                await sleep(parseInt(document.getElementById('wfcSpeed').value) / 2);

                // Propaga restrições
                if (!wfcAnimating) return;
                await propagate(cell.i, cell.j);

                if (!wfcAnimating) return;
                drawWFC();
            }

            wfcAnimating = false;
            document.getElementById('wfcStart').disabled = false;
        }

        function resetWFC() {
            wfcShouldStop = true;
            wfcAnimating = false;
            initWFC();
            document.getElementById('wfcStart').disabled = false;
        }

        document.getElementById('wfcSpeed').addEventListener('input', (e) => {
            document.getElementById('wfcSpeedValue').textContent = e.target.value + 'ms';
        });

        // ========== MANDELBROT & JULIA SET ==========
        const mandelbrotCanvas = document.getElementById('mandelbrotCanvas');
        const mandelbrotCtx = mandelbrotCanvas.getContext('2d');
        const juliaCanvas = document.getElementById('juliaCanvas');
        const juliaCtx = juliaCanvas.getContext('2d');

        let mandelbrotBounds = { xMin: -2.5, xMax: 1.0, yMin: -1.25, yMax: 1.25 };
        let mandelbrotZoomLevel = 1;
        let juliaC = { real: -0.7, imag: 0.27 };

        let juliaBounds = {
            xMin: -1.5,
            xMax:  1.5,
            yMin: -1.5,
            yMax:  1.5
        };

        let juliaZoomLevel = 1;
        let juliaRendering = false;

        function getColor(iterations, maxIterations, colorScheme = 'rainbow') {
            if (iterations === maxIterations) return [0, 0, 0];

            const t = iterations / maxIterations;
            
            // Esquema padrão (arco-íris)
            let r, g, b;
            
            if (colorScheme === 'fire') {
                // Fogo: vermelho -> laranja -> amarelo
                if (t < 0.33) {
                    r = Math.floor(255 * t * 3);
                    g = Math.floor(255 * t * 2);
                    b = 0;
                } else if (t < 0.66) {
                    r = 255;
                    g = Math.floor(255 * (t - 0.33) * 3);
                    b = 0;
                } else {
                    r = 255;
                    g = 255;
                    b = Math.floor(255 * (t - 0.66) * 3);
                }
            } else if (colorScheme === 'ocean') {
                // Oceano: azul escuro -> azul claro -> turquesa
                r = 0;
                g = Math.floor(150 * t);
                b = Math.floor(100 + 155 * t);
            } else if (colorScheme === 'purple') {
                // Roxo: roxo escuro -> rosa -> branco
                r = Math.floor(128 + 127 * t);
                g = Math.floor(50 * t);
                b = Math.floor(128 + 127 * t);
            } else if (colorScheme === 'grayscale') {
                // Escala de cinza
                const intensity = Math.floor(255 * t);
                r = g = b = intensity;
            } else if (colorScheme === 'neon') {
                // Neon: preto -> verde neon -> rosa neon -> ciano
                if (t < 0.33) {
                    r = Math.floor(255 * t * 3);
                    g = 255;
                    b = Math.floor(255 * t * 2);
                } else if (t < 0.66) {
                    r = 255;
                    g = Math.floor(255 - 255 * (t - 0.33) * 3);
                    b = Math.floor(255 - 255 * (t - 0.33) * 3);
                } else {
                    r = Math.floor(255 - 255 * (t - 0.66) * 3);
                    g = 255;
                    b = 255;
                }
            } else {
                // Arco-íris (padrão)
                if (t < 0.16) {
                    const local = t / 0.16;
                    r = 0;
                    g = Math.floor(7 + local * 93);
                    b = Math.floor(100 * local);
                } else if (t < 0.42) {
                    const local = (t - 0.16) / 0.26;
                    r = 0;
                    g = Math.floor(100 + local * 155);
                    b = Math.floor(100 + local * 155);
                } else if (t < 0.6425) {
                    const local = (t - 0.42) / 0.2225;
                    r = Math.floor(local * 255);
                    g = 255;
                    b = 255;
                } else if (t < 0.8575) {
                    const local = (t - 0.6425) / 0.215;
                    r = 255;
                    g = Math.floor(255 - local * 255);
                    b = Math.floor(255 - local * 255);
                } else {
                    const local = (t - 0.8575) / 0.1425;
                    r = 255;
                    g = Math.floor(local * 255);
                    b = Math.floor(local * 255);
                }
            }
            
            return [r, g, b];
        }

        async function drawMandelbrot() {
            mandelbrotRendering = true;
            document.getElementById('mandelbrotDraw').disabled = true;
            document.getElementById('mandelbrotStatus').textContent = 'Desenhando...';

            const width = mandelbrotCanvas.width;
            const height = mandelbrotCanvas.height;
            const imageData = mandelbrotCtx.createImageData(width, height);
            const data = imageData.data;
            const maxIter = parseInt(document.getElementById('mandelbrotIter').value);
            const colorScheme = document.getElementById('mandelbrotColors').value;

            const { xMin, xMax, yMin, yMax } = mandelbrotBounds;

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const x0 = xMin + (px / width) * (xMax - xMin);
                    const y0 = yMin + (py / height) * (yMax - yMin);

                    let x = 0, y = 0;
                    let iteration = 0;

                    while (x * x + y * y <= 4 && iteration < maxIter) {
                        const xTemp = x * x - y * y + x0;
                        y = 2 * x * y + y0;
                        x = xTemp;
                        iteration++;
                    }

                    const color = getColor(iteration, maxIter, colorScheme);
                    const index = (py * width + px) * 4;
                    data[index] = color[0];
                    data[index + 1] = color[1];
                    data[index + 2] = color[2];
                    data[index + 3] = 255;
                }

                if (py % 10 === 0) {
                    mandelbrotCtx.putImageData(imageData, 0, 0);
                    document.getElementById('mandelbrotStatus').textContent = 
                        `${Math.floor((py / height) * 100)}%`;
                    await sleep(1);
                }
            }

            mandelbrotCtx.putImageData(imageData, 0, 0);
            document.getElementById('mandelbrotStatus').textContent = 'Completo!';
            document.getElementById('mandelbrotDraw').disabled = false;
            mandelbrotRendering = false;
        }

        let mandelbrotRendering = false;

        mandelbrotCanvas.addEventListener('click', async (e) => {
            if (mandelbrotRendering) return;
            mandelbrotRendering = true;

            const rect = mandelbrotCanvas.getBoundingClientRect();

            // Coordenadas normalizadas [0..1] em CSS pixels
            const nx = (e.clientX - rect.left) / rect.width;
            const ny = (e.clientY - rect.top) / rect.height;

            const { xMin, xMax, yMin, yMax } = mandelbrotBounds;

            // Mapeamento correto para o plano complexo
            const clickX = xMin + nx * (xMax - xMin);
            const clickY = yMin + ny * (yMax - yMin);

            const zoomFactor = 0.5;
            const rangeX = (xMax - xMin) * zoomFactor;
            const rangeY = (yMax - yMin) * zoomFactor;

            mandelbrotBounds = {
                xMin: clickX - rangeX / 2,
                xMax: clickX + rangeX / 2,
                yMin: clickY - rangeY / 2,
                yMax: clickY + rangeY / 2
            };

            mandelbrotZoomLevel *= 2;
            document.getElementById('mandelbrotZoom').textContent =
                mandelbrotZoomLevel >= 1000
                    ? (mandelbrotZoomLevel / 1000).toFixed(1) + 'Kx'
                    : mandelbrotZoomLevel + 'x';

            await sleep(50);
            await drawMandelbrot();

            mandelbrotRendering = false;
        });

        function resetMandelbrot() {
            mandelbrotBounds = { xMin: -2.5, xMax: 1.0, yMin: -1.25, yMax: 1.25 };
            mandelbrotZoomLevel = 1;
            document.getElementById('mandelbrotZoom').textContent = '1x';
            drawMandelbrot();
        }

        document.getElementById('mandelbrotIter').addEventListener('input', (e) => {
            document.getElementById('mandelbrotIterValue').textContent = e.target.value;
        });

        document.getElementById('juliaColors').addEventListener('change', () => {
            drawJulia();
        });

        document.getElementById('mandelbrotColors').addEventListener('change', () => {
            drawMandelbrot();
        });

        async function drawJulia() {
            juliaRendering = true;
            document.getElementById('juliaDraw').disabled = true;
            document.getElementById('randomJuliaDraw').disabled = true;
            document.getElementById('juliaStatus').textContent = 'Desenhando...';

            const width = juliaCanvas.width;
            const height = juliaCanvas.height;
            const imageData = juliaCtx.createImageData(width, height);
            const data = imageData.data;
            const maxIter = parseInt(document.getElementById('juliaIter').value);
            const colorScheme = document.getElementById('juliaColors').value;

            const cReal = parseFloat(document.getElementById('juliaCReal').value);
            const cImag = parseFloat(document.getElementById('juliaCImag').value);

            const { xMin, xMax, yMin, yMax } = juliaBounds;

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    let x = xMin + (px / width) * (xMax - xMin);
                    let y = yMin + (py / height) * (yMax - yMin);

                    let iteration = 0;

                    while (x * x + y * y <= 4 && iteration < maxIter) {
                        const xTemp = x * x - y * y + cReal;
                        y = 2 * x * y + cImag;
                        x = xTemp;
                        iteration++;
                    }

                    const color = getColor(iteration, maxIter, colorScheme);
                    const index = (py * width + px) * 4;
                    data[index] = color[0];
                    data[index + 1] = color[1];
                    data[index + 2] = color[2];
                    data[index + 3] = 255;
                }

                if (py % 10 === 0) {
                    juliaCtx.putImageData(imageData, 0, 0);
                    document.getElementById('juliaStatus').textContent = 
                        `${Math.floor((py / height) * 100)}%`;
                    await sleep(1);
                }
            }

            juliaCtx.putImageData(imageData, 0, 0);
            document.getElementById('juliaStatus').textContent = 'Completo!';
            document.getElementById('juliaDraw').disabled = false;
            document.getElementById('randomJuliaDraw').disabled = false;
            juliaRendering = false;
        }

        juliaCanvas.addEventListener('click', async (e) => {
            if (juliaRendering) return;
            juliaRendering = true;

            const rect = juliaCanvas.getBoundingClientRect();

            // Coordenadas normalizadas [0..1] em CSS pixels
            const nx = (e.clientX - rect.left) / rect.width;
            const ny = (e.clientY - rect.top) / rect.height;

            const { xMin, xMax, yMin, yMax } = juliaBounds;

            // Mapeamento correto para o plano complexo
            const clickX = xMin + nx * (xMax - xMin);
            const clickY = yMin + ny * (yMax - yMin);

            const zoomFactor = 0.5;
            const rangeX = (xMax - xMin) * zoomFactor;
            const rangeY = (yMax - yMin) * zoomFactor;

            juliaBounds = {
                xMin: clickX - rangeX / 2,
                xMax: clickX + rangeX / 2,
                yMin: clickY - rangeY / 2,
                yMax: clickY + rangeY / 2
            };

            juliaZoomLevel *= 2;
            document.getElementById('juliaZoom').textContent =
                juliaZoomLevel >= 1000
                    ? (juliaZoomLevel / 1000).toFixed(1) + 'Kx'
                    : juliaZoomLevel + 'x';

            await sleep(50);
            await drawJulia();

            juliaRendering = false;
        });

        function randomJuliaC() {
            const presets = [
                { real: -0.7, imag: 0.27 },
                { real: -0.8, imag: 0.156 },
                { real: 0.285, imag: 0.01 },
                { real: -0.4, imag: 0.6 },
                { real: -0.162, imag: 1.04 },
                { real: -0.74543, imag: 0.11301 },
                { real: -0.1, imag: 0.651 },
                { real: 0.3, imag: -0.01 }
            ];
            
            const preset = presets[Math.floor(Math.random() * presets.length)];
            document.getElementById('juliaCReal').value = preset.real;
            document.getElementById('juliaCImag').value = preset.imag;
            document.getElementById('juliaCRealValue').textContent = preset.real.toFixed(3);
            document.getElementById('juliaCImagValue').textContent = preset.imag.toFixed(3);
            
            drawJulia();
        }

        function resetJulia() {
            juliaBounds = {
                xMin: -1.5,
                xMax:  1.5,
                yMin: -1.5,
                yMax:  1.5
            };

            juliaZoomLevel = 1;
            document.getElementById('juliaZoom').textContent = '1x';

            drawJulia();
        }

        document.getElementById('juliaIter').addEventListener('input', (e) => {
            document.getElementById('juliaIterValue').textContent = e.target.value;
        });

        document.getElementById('juliaCReal').addEventListener('input', (e) => {
            document.getElementById('juliaCRealValue').textContent = parseFloat(e.target.value).toFixed(3);
        });

        document.getElementById('juliaCImag').addEventListener('input', (e) => {
            document.getElementById('juliaCImagValue').textContent = parseFloat(e.target.value).toFixed(3);
        });

        // ========== QUICK SORT ==========
        const quickCanvas = document.getElementById('quickCanvas');
        const quickCtx = quickCanvas.getContext('2d');
        let quickArray = [];
        let quickAnimating = false;
        let quickComparisons = 0;
        let quickSwaps = 0;
        let quickRecursions = 0;
        let quickShouldStop = false;
        let quickIsSorted = false;

        function generateQuickArray() {
            quickArray = [];
            for (let i = 0; i < 20; i++) {
                quickArray.push(Math.floor(Math.random() * 200) + 20);
            }
            quickComparisons = 0;
            quickSwaps = 0;
            quickRecursions = 0;
            quickIsSorted = false;
            updateQuickStats();
            drawQuickArray();
        }

        function drawQuickArray(comparing = [], pivot = -1, sorted = []) {
            quickCtx.clearRect(0, 0, quickCanvas.width, quickCanvas.height);
            const barWidth = quickCanvas.width / quickArray.length;
            const maxHeight = 250;

            quickArray.forEach((value, index) => {
                const x = index * barWidth;
                const height = (value / Math.max(...quickArray)) * maxHeight;
                const y = quickCanvas.height - height - 20;

                if (sorted.includes(index)) {
                    quickCtx.fillStyle = '#4CAF50';
                } else if (index === pivot) {
                    quickCtx.fillStyle = '#9C27B0';
                } else if (comparing.includes(index)) {
                    quickCtx.fillStyle = '#ff9800';
                } else {
                    quickCtx.fillStyle = '#5c6d82';
                }

                quickCtx.fillRect(x + 2, y, barWidth - 4, height);
                quickCtx.fillStyle = '#333';
                quickCtx.font = '10px Arial';
                quickCtx.textAlign = 'center';
                quickCtx.fillText(value, x + barWidth / 2, quickCanvas.height - 5);
            });
        }

        function updateQuickStats() {
            document.getElementById('quickComparisons').textContent = quickComparisons;
            document.getElementById('quickSwaps').textContent = quickSwaps;
            document.getElementById('quickRecursions').textContent = quickRecursions;
        }

        async function partition(low, high, sortedIndices) {
            if (quickShouldStop) return high;
            
            const pivot = quickArray[high];
            let i = low - 1;

            drawQuickArray([], high, sortedIndices);
            await sleep(parseInt(document.getElementById('quickSpeed').value));

            for (let j = low; j < high; j++) {
                if (quickShouldStop) return high;
                
                quickComparisons++;
                updateQuickStats();
                drawQuickArray([j, high], high, sortedIndices);
                await sleep(parseInt(document.getElementById('quickSpeed').value));

                if (quickArray[j] < pivot) {
                    i++;
                    [quickArray[i], quickArray[j]] = [quickArray[j], quickArray[i]];
                    quickSwaps++;
                    updateQuickStats();
                    if (!quickAnimating) return;
                    drawQuickArray([i, j], high, sortedIndices);
                    await sleep(parseInt(document.getElementById('quickSpeed').value));
                }
            }

            [quickArray[i + 1], quickArray[high]] = [quickArray[high], quickArray[i + 1]];
            quickSwaps++;
            updateQuickStats();
            return i + 1;
        }

        async function quickSortRecursive(low, high, sortedIndices) {
            if (quickShouldStop) return;
            
            if (low < high) {
                quickRecursions++;
                updateQuickStats();

                const pi = await partition(low, high, sortedIndices);
                sortedIndices.push(pi);

                await quickSortRecursive(low, pi - 1, sortedIndices);
                await quickSortRecursive(pi + 1, high, sortedIndices);
            } else if (low === high) {
                sortedIndices.push(low);
            }
        }

        async function startQuickSort() {
            if (quickAnimating) return;
            if (quickIsSorted) {
                alert('O array já está ordenado! Clique em "Gerar Novo Array" para criar um novo.');
                return;
            }
            
            quickAnimating = true;
            quickShouldStop = false;
            document.getElementById('quickStart').disabled = true;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Gerar Novo Array')) btn.disabled = true;
            });

            const sortedIndices = [];
            await quickSortRecursive(0, quickArray.length - 1, sortedIndices);

            if (!quickShouldStop) {
                for (let i = 0; i < quickArray.length; i++) {
                    sortedIndices.push(i);
                }
                drawQuickArray([], -1, sortedIndices);
                quickIsSorted = true;
            }

            quickAnimating = false;
            document.getElementById('quickStart').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Gerar Novo Array')) btn.disabled = false;
            });
        }

        function resetQuickSort() {
            quickShouldStop = true;
            quickAnimating = false;
            quickIsSorted = false;
            generateQuickArray();
            document.getElementById('quickStart').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent.includes('Gerar Novo Array')) btn.disabled = false;
            });
        }

        document.getElementById('quickSpeed').addEventListener('input', (e) => {
            document.getElementById('quickSpeedValue').textContent = e.target.value + 'ms';
        });

        // ========== LINEAR REGRESSION ==========
        const regressionCanvas = document.getElementById('regressionCanvas');
        const regressionCtx = regressionCanvas.getContext('2d');
        let regressionData = [];
        let regressionM = 0;
        let regressionB = 0;
        let regressionAnimating = false;
        let regressionShouldStop = false;
        const padding = 50;

        function initRegression() {
            regressionData = [];
            regressionM = Math.random() * 2 - 1;
            regressionB = Math.random() * 100 - 50;
            document.getElementById('regressionEpoch').textContent = 0;
            document.getElementById('regressionError').textContent = '-';
            document.getElementById('regressionM').textContent = '-';
            document.getElementById('regressionB').textContent = '-';
            drawRegression();
        }

        function generateRegressionData() {
            if (regressionAnimating) return;
            
            regressionData = [];
            const numPoints = 20;
            const trueM = 2;
            const trueB = 50;
            const noise = parseInt(document.getElementById('noiseLevel').value);

            for (let i = 0; i < numPoints; i++) {
                const x = Math.random() * 400 + 50;
                const yTrue = trueM * ((x - padding) / (regressionCanvas.width - 2 * padding)) * 400 + trueB;
                const yNoise = (Math.random() - 0.5) * noise;
                regressionData.push({
                    x: x,
                    y: Math.max(padding, Math.min(regressionCanvas.height - padding, yTrue + yNoise))
                });
            }

            regressionM = Math.random() * 2 - 1;
            regressionB = Math.random() * 100 - 50;
            drawRegression();
        }

        function drawRegression(showErrors = false) {
            regressionCtx.clearRect(0, 0, regressionCanvas.width, regressionCanvas.height);

            // Desenha grade
            regressionCtx.strokeStyle = '#e0e0e0';
            regressionCtx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = padding + (i / 10) * (regressionCanvas.width - 2 * padding);
                const y = padding + (i / 10) * (regressionCanvas.height - 2 * padding);
                
                regressionCtx.beginPath();
                regressionCtx.moveTo(x, padding);
                regressionCtx.lineTo(x, regressionCanvas.height - padding);
                regressionCtx.stroke();

                regressionCtx.beginPath();
                regressionCtx.moveTo(padding, y);
                regressionCtx.lineTo(regressionCanvas.width - padding, y);
                regressionCtx.stroke();
            }

            // Eixos
            regressionCtx.strokeStyle = '#333';
            regressionCtx.lineWidth = 2;
            regressionCtx.beginPath();
            regressionCtx.moveTo(padding, padding);
            regressionCtx.lineTo(padding, regressionCanvas.height - padding);
            regressionCtx.lineTo(regressionCanvas.width - padding, regressionCanvas.height - padding);
            regressionCtx.stroke();

            // Desenha linhas de erro
            if (showErrors && regressionData.length > 0) {
                regressionCtx.strokeStyle = '#ff9800';
                regressionCtx.lineWidth = 1;
                regressionCtx.setLineDash([5, 5]);

                regressionData.forEach(point => {
                    const xNorm = (point.x - padding) / (regressionCanvas.width - 2 * padding);
                    const yPred = regressionM * xNorm * (regressionCanvas.height - 2 * padding) + 
                                  regressionB * (regressionCanvas.height - 2 * padding) / 100;
                    const yPredCanvas = regressionCanvas.height - padding - yPred;

                    regressionCtx.beginPath();
                    regressionCtx.moveTo(point.x, point.y);
                    regressionCtx.lineTo(point.x, yPredCanvas);
                    regressionCtx.stroke();
                });

                regressionCtx.setLineDash([]);
            }

            // Desenha linha de regressão
            if (regressionData.length > 0) {
                regressionCtx.strokeStyle = '#f44336';
                regressionCtx.lineWidth = 3;
                regressionCtx.beginPath();

                const x1 = padding;
                const x1Norm = 0;
                const y1 = regressionM * x1Norm * (regressionCanvas.height - 2 * padding) + 
                           regressionB * (regressionCanvas.height - 2 * padding) / 100;
                const y1Canvas = regressionCanvas.height - padding - y1;

                const x2 = regressionCanvas.width - padding;
                const x2Norm = 1;
                const y2 = regressionM * x2Norm * (regressionCanvas.height - 2 * padding) + 
                           regressionB * (regressionCanvas.height - 2 * padding) / 100;
                const y2Canvas = regressionCanvas.height - padding - y2;

                regressionCtx.moveTo(x1, y1Canvas);
                regressionCtx.lineTo(x2, y2Canvas);
                regressionCtx.stroke();
            }

            // Desenha pontos
            regressionData.forEach(point => {
                regressionCtx.beginPath();
                regressionCtx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                regressionCtx.fillStyle = '#5c6d82';
                regressionCtx.fill();
                regressionCtx.strokeStyle = '#273E74';
                regressionCtx.lineWidth = 2;
                regressionCtx.stroke();
            });
        }

        function calculateMSE() {
            if (regressionData.length === 0) return 0;

            let sumSquaredError = 0;
            regressionData.forEach(point => {
                const xNorm = (point.x - padding) / (regressionCanvas.width - 2 * padding);
                const yNorm = (regressionCanvas.height - padding - point.y) / (regressionCanvas.height - 2 * padding);
                const yPred = regressionM * xNorm + regressionB / 100;
                const error = yNorm - yPred;
                sumSquaredError += error * error;
            });

            return sumSquaredError / regressionData.length;
        }

        async function startRegression() {
            if (regressionAnimating) return;
            if (regressionData.length === 0) {
                alert('Gere dados primeiro!');
                return;
            }

            regressionAnimating = true;
            regressionShouldStop = false;
            document.getElementById('regressionStart').disabled = true;
            document.getElementById('noiseLevel').disabled = true;
            document.getElementById('learningRate').disabled = true;
            document.getElementById('regressionGenerateData').disabled = true;

            const learningRate = parseFloat(document.getElementById('learningRate').value);
            const maxEpochs = 500;

            for (let epoch = 0; epoch < maxEpochs; epoch++) {
                if (regressionShouldStop) break;

                let sumErrorM = 0;
                let sumErrorB = 0;

                regressionData.forEach(point => {
                    const xNorm = (point.x - padding) / (regressionCanvas.width - 2 * padding);
                    const yNorm = (regressionCanvas.height - padding - point.y) / (regressionCanvas.height - 2 * padding);
                    const yPred = regressionM * xNorm + regressionB / 100;
                    const error = yPred - yNorm;

                    sumErrorM += error * xNorm;
                    sumErrorB += error;
                });

                const gradientM = (2 / regressionData.length) * sumErrorM;
                const gradientB = (2 / regressionData.length) * sumErrorB;

                regressionM -= learningRate * gradientM * 10;
                regressionB -= learningRate * gradientB * 1000;

                const mse = calculateMSE();

                document.getElementById('regressionEpoch').textContent = epoch + 1;
                document.getElementById('regressionError').textContent = mse.toFixed(6);
                document.getElementById('regressionM').textContent = regressionM.toFixed(3);
                document.getElementById('regressionB').textContent = regressionB.toFixed(3);

                drawRegression(true);
                await sleep(parseInt(document.getElementById('regressionSpeed').value));

                if (mse < 0.0001) break;
            }

            regressionAnimating = false;
            document.getElementById('regressionStart').disabled = false;
            document.getElementById('noiseLevel').disabled = false;
            document.getElementById('learningRate').disabled = false;
            document.getElementById('regressionGenerateData').disabled = false;
        }

        regressionCanvas.addEventListener('click', (e) => {
            if (regressionAnimating) return;

            const { x, y } = getCanvasCoords(regressionCanvas, e);

            if (
                x >= padding &&
                x <= regressionCanvas.width - padding &&
                y >= padding &&
                y <= regressionCanvas.height - padding
            ) {
                regressionData.push({ x, y });
                drawRegression();
            }
        });

        function resetRegression() {
            regressionShouldStop = true;
            regressionAnimating = false;
            initRegression();
            document.getElementById('regressionStart').disabled = false;
            document.getElementById('noiseLevel').disabled = false;
            document.getElementById('learningRate').disabled = false;
            document.getElementById('regressionGenerateData').disabled = false;
        }

        document.getElementById('regressionSpeed').addEventListener('input', (e) => {
            document.getElementById('regressionSpeedValue').textContent = e.target.value + 'ms';
        });

        document.getElementById('learningRate').addEventListener('input', (e) => {
            document.getElementById('learningRateValue').textContent = parseFloat(e.target.value).toFixed(4);
        });

        document.getElementById('noiseLevel').addEventListener('input', (e) => {
            document.getElementById('noiseLevelValue').textContent = e.target.value;
        });

        // ========== L-SYSTEMS ==========
        const lsystemCanvas = document.getElementById('lsystemCanvas');
        const lsystemCtx = lsystemCanvas.getContext('2d');

        const lsystems = {
            tree: {
                axiom: 'F',
                rules: {
                    'F': 'F[+F]F[-F][F]'
                },
                angle: 25,
                startAngle: -90,
                length: 7,
                scaleMode: 'shrink',
                jitter: 1,
                maxIterations: 6,
                name: 'Árvore Fractal'
            },
            plant: {
                axiom: 'F',
                rules: {
                    'F': 'F[+F]F[-F]F'
                },
                angle: 20,
                startAngle: -90,
                length: 6,
                scaleMode: 'shrink',
                jitter: 4,
                maxIterations: 7,
                name: 'Planta Ramificada'
            },
            bush: {
                axiom: 'F',
                rules: { 'F': 'FF-[-F+F+F]+[+F-F-F]' },
                angle: 22.5,
                startAngle: -90,
                length: 6,
                scaleMode: 'shrink',
                jitter: 2,
                maxIterations: 5,
                name: 'Arbusto'
            },
            fern: {
                axiom: 'X',
                rules: {
                    'X': 'F+[[X]-X]-F[-FX]+X',
                    'F': 'FF'
                },
                angle: 22.5,
                startAngle: -90,
                length: 4,
                scaleMode: 'shrink',
                jitter: 1,
                maxIterations: 8,
                name: 'Samambaia'
            },
            dragon: {
                axiom: 'FX',
                rules: { 'X': 'X+YF+', 'Y': '-FX-Y' },
                angle: 90,
                startAngle: 0,
                length: 1,
                scaleMode: 'fit',
                maxIterations: 14,
                name: 'Curva do Dragão'
            },
            sierpinski: {
                axiom: 'F-G-G',
                rules: { 'F': 'F-G+F+G-F', 'G': 'GG' },
                angle: 120,
                startAngle: 0,
                length: 1,
                scaleMode: 'fit',
                maxIterations: 8,
                name: 'Triângulo Sierpinski'
            },
            hilbert: {
                axiom: 'A',
                rules: {
                    'A': '+BF-AFA-FB+',
                    'B': '-AF+BFB+FA-'
                },
                angle: 90,
                startAngle: 0,
                length: 1,
                scaleMode: 'fit',
                maxIterations: 6,
                name: 'Curva de Hilbert'
            },
            peano: {
                axiom: 'X',
                rules: {
                    'X': 'XFYFX+F+YFXFY-F-XFYFX',
                    'Y': 'YFXFY-F-XFYFX+F+YFXFY'
                },
                angle: 90,
                startAngle: 0,
                length: 1,
                scaleMode: 'fit',
                maxIterations: 4,
                name: 'Curva de Peano'
            },
            gosper: {
                axiom: 'FX',
                rules: {
                    'X': 'X+YF++YF-FX--FXFX-YF+',
                    'Y': '-FX+YFYF++YF+FX--FX-Y'
                },
                angle: 60,
                startAngle: 0,
                length: 1,
                scaleMode: 'fit',
                maxIterations: 5,
                name: 'Curva de Gosper'
            },
            koch: {
                axiom: 'F--F--F',
                rules: {
                    'F': 'F+F--F+F'
                },
                angle: 60,
                startAngle: 0,
                length: 1,
                scaleMode: 'fit',
                maxIterations: 6,
                name: 'Floco de Neve de Koch'
            },
            kochIsland: {
                axiom: 'F+F+F+F',
                rules: {
                    'F': 'F+F-F-FF+F+F-F'
                },
                angle: 90,
                startAngle: 0,
                length: 1,
                scaleMode: 'fit',
                maxIterations: 4,
                name: 'Ilha de Koch'
            },
            alternatingPlant: {
                axiom: 'F',
                rules: {
                    'F': 'F[+F][-F]F'
                },
                angle: 30,
                startAngle: -90,
                length: 6,
                scaleMode: 'shrink',
                jitter: 3,
                maxIterations: 6,
                name: 'Planta Alternada'
            },
            whorledPlant: {
                axiom: 'F',
                rules: {
                    'F': 'F[+F][−F][++F][--F]'
                },
                angle: 18,
                startAngle: -90,
                length: 5,
                scaleMode: 'shrink',
                jitter: 1,
                maxIterations: 5,
                name: 'Planta em Camadas'
            },
            leafPlant: {
                axiom: 'F',
                rules: {
                    'F': 'F[+F]F[-F]L',
                    'L': 'L'
                },
                angle: 22,
                startAngle: -90,
                length: 6,
                scaleMode: 'shrink',
                jitter: 2,
                maxIterations: 6,
                name: 'Planta com Folhas'
            }
        };

        // ========== CORES ==========
        const colorSchemes = {
            brown: (d, m) => {
                const r = d / m;
                return `rgb(${140 - r * 80}, ${80 + r * 100}, 30)`;
            },
            green: (d, m) => `rgb(30, ${100 + (d / m) * 155}, 40)`,
            rainbow: (d, m) => `hsl(${(d / m) * 360}, 70%, 50%)`,
            autumn: (d, m) => `hsl(${15 + (d / m) * 40}, 70%, 50%)`,
            neon: (d) => `hsl(${(d * 137.5) % 360}, 100%, 50%)`
        };

        // ========== GERAR STRING ==========
        function generateLSystem(axiom, rules, iterations) {
            let current = axiom;
            for (let i = 0; i < iterations; i++) {
                let next = '';
                for (const c of current) next += rules[c] || c;
                current = next;
            }
            return current;
        }

        // ========== PASSO 1 — BOUNDING BOX ==========
        function computeBounds(lstring, system, length) {
            let x = 0, y = 0;
            let angle = system.startAngle;
            const stack = [];

            let minX = 0, maxX = 0, minY = 0, maxY = 0;

            for (const c of lstring) {
                switch (c) {
                    case 'F':
                    case 'G':
                        x += length * Math.cos(angle * Math.PI / 180);
                        y += length * Math.sin(angle * Math.PI / 180);
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                        break;
                    case '+': angle += system.angle; break;
                    case '-': angle -= system.angle; break;
                    case '[': stack.push({ x, y, angle }); break;
                    case ']': ({ x, y, angle } = stack.pop()); break;
                }
            }
            return { minX, maxX, minY, maxY };
        }

        // ========== DESENHAR ==========
        function drawLSystem() {
            document.getElementById('lsystemDraw').disabled = true;
            document.getElementById('lsystemStatus').textContent = 'Gerando...';

            setTimeout(() => {
                const type = document.getElementById('lsystemType').value;
                const iterations = +document.getElementById('lsystemIterations').value;
                const colorScheme = document.getElementById('lsystemColor').value;

                const system = lsystems[type];
                const lstring = generateLSystem(system.axiom, system.rules, iterations);

                document.getElementById('lsystemLength').textContent = lstring.length;
                document.getElementById('lsystemStatus').textContent = 'Desenhando...';

                lsystemCtx.clearRect(0, 0, lsystemCanvas.width, lsystemCanvas.height);
                lsystemCtx.fillStyle = '#f9f9f9';
                lsystemCtx.fillRect(0, 0, lsystemCanvas.width, lsystemCanvas.height);

                let length = system.length;

                if (system.scaleMode === 'shrink') {
                    length *= Math.pow(0.85, iterations);
                }

                const bounds = computeBounds(lstring, system, length);
                const w = bounds.maxX - bounds.minX;
                const h = bounds.maxY - bounds.minY;

                const scale = Math.min(
                    lsystemCanvas.width / w,
                    lsystemCanvas.height / h
                ) * 0.9;

                length *= scale;

                let x = lsystemCanvas.width / 2 - (bounds.minX + w / 2) * scale;
                let y = lsystemCanvas.height / 2 - (bounds.minY + h / 2) * scale;

                let angle = system.startAngle;
                let depth = 0;
                let segments = 0;
                const stack = [];
                const maxDepth = Math.max(1, lstring.split('[').length);

                for (const c of lstring) {
                    switch (c) {
                        case 'F':
                        case 'G': {
                            const nx = x + length * Math.cos(angle * Math.PI / 180);
                            const ny = y + length * Math.sin(angle * Math.PI / 180);

                            lsystemCtx.beginPath();
                            lsystemCtx.moveTo(x, y);
                            lsystemCtx.lineTo(nx, ny);
                            lsystemCtx.strokeStyle = colorSchemes[colorScheme](depth, maxDepth);
                            lsystemCtx.lineWidth = Math.max(0.5, 3 - depth * 0.4);
                            lsystemCtx.stroke();

                            x = nx;
                            y = ny;
                            segments++;
                            break;
                        }
                        case '+':
                            angle += system.angle + (Math.random() - 0.5) * (system.jitter || 0);
                            break;
                        case '-':
                            angle -= system.angle + (Math.random() - 0.5) * (system.jitter || 0);
                            break;
                        case '[':
                            stack.push({ x, y, angle, depth });
                            depth++;
                            break;
                        case ']': {
                            const s = stack.pop();
                            if (s) ({ x, y, angle, depth } = s);
                            break;
                        }
                    }
                }

                document.getElementById('lsystemSegments').textContent = segments;
                document.getElementById('lsystemStatus').textContent = 'Completo!';
                document.getElementById('lsystemDraw').disabled = false;
            }, 50);
        }

        // ========== RESET ==========
        function resetLSystem() {
            lsystemCtx.clearRect(0, 0, lsystemCanvas.width, lsystemCanvas.height);
            lsystemCtx.fillStyle = '#f9f9f9';
            lsystemCtx.fillRect(0, 0, lsystemCanvas.width, lsystemCanvas.height);
            document.getElementById('lsystemLength').textContent = 0;
            document.getElementById('lsystemSegments').textContent = 0;
            document.getElementById('lsystemStatus').textContent = 'Pronto';
        }

        document.getElementById('lsystemIterations').addEventListener('input', e => {
            document.getElementById('lsystemIterationsValue').textContent = e.target.value;
        });

        const lsystemTypeSelect = document.getElementById('lsystemType');
        const iterationsSlider = document.getElementById('lsystemIterations');
        const iterationsValue = document.getElementById('lsystemIterationsValue');

        function updateIterationsLimit() {
            const type = lsystemTypeSelect.value;
            const system = lsystems[type];

            iterationsSlider.max = system.maxIterations;

            // Garante que o valor atual não ultrapasse o novo max
            if (+iterationsSlider.value > system.maxIterations) {
                iterationsSlider.value = system.maxIterations;
            }

            iterationsValue.textContent = iterationsSlider.value;
        }

        // Atualiza ao trocar o L-System
        lsystemTypeSelect.addEventListener('change', updateIterationsLimit);

        // Atualiza valor exibido
        iterationsSlider.addEventListener('input', e => {
            iterationsValue.textContent = e.target.value;
        });

        // Inicializa corretamente na primeira carga
        updateIterationsLimit();

        // ========== DELAUNAY TRIANGULATION ==========
        const delaunayCanvas = document.getElementById('delaunayCanvas');
        const delaunayCtx = delaunayCanvas.getContext('2d');
        let delaunayPoints = [];
        let delaunayTriangles = [];
        let delaunayAnimating = false;
        let delaunayShouldStop = false;

        function generateDelaunayPoints() {
            if (delaunayAnimating) return;
            
            const numPoints = parseInt(document.getElementById('delaunayPoints').value);
            delaunayPoints = [];
            delaunayTriangles = [];
            
            const padding = 50;
            for (let i = 0; i < numPoints; i++) {
                delaunayPoints.push({
                    x: Math.random() * (delaunayCanvas.width - 2 * padding) + padding,
                    y: Math.random() * (delaunayCanvas.height - 2 * padding) + padding
                });
            }
            
            document.getElementById('delaunayPointCount').textContent = numPoints;
            document.getElementById('delaunayTriangleCount').textContent = 0;
            document.getElementById('delaunayEdgeCount').textContent = 0;
            drawDelaunay();
        }

        function drawDelaunay(currentTriangle = null) {
            delaunayCtx.clearRect(0, 0, delaunayCanvas.width, delaunayCanvas.height);
            
            const vizMode = document.getElementById('delaunayVisualization').value;

            // Desenha triângulos
            if (vizMode === 'triangles' || vizMode === 'voronoi' || vizMode === 'mesh') {
                delaunayTriangles.forEach((tri, idx) => {
                    const isCurrent = currentTriangle && idx === currentTriangle;
                    
                    delaunayCtx.beginPath();
                    delaunayCtx.moveTo(tri.a.x, tri.a.y);
                    delaunayCtx.lineTo(tri.b.x, tri.b.y);
                    delaunayCtx.lineTo(tri.c.x, tri.c.y);
                    delaunayCtx.closePath();
                    
                    if (vizMode === 'mesh') {
                        // Efeito 3D com gradiente
                        const gradient = delaunayCtx.createLinearGradient(
                            tri.a.x, tri.a.y, tri.c.x, tri.c.y
                        );
                        const lightness = 30 + (idx % 5) * 10;
                        gradient.addColorStop(0, `hsl(210, 50%, ${lightness}%)`);
                        gradient.addColorStop(1, `hsl(210, 50%, ${lightness + 20}%)`);
                        delaunayCtx.fillStyle = gradient;
                    } else {
                        delaunayCtx.fillStyle = isCurrent ? 
                            'rgba(255, 152, 0, 0.3)' : 
                            'rgba(33, 150, 243, 0.1)';
                    }
                    delaunayCtx.fill();
                    
                    delaunayCtx.strokeStyle = isCurrent ? '#ff9800' : '#2196F3';
                    delaunayCtx.lineWidth = isCurrent ? 3 : 2;
                    delaunayCtx.stroke();
                });
            }

            // Desenha círculos circunscritos
            if (vizMode === 'circles') {
                delaunayTriangles.forEach(tri => {
                    const circle = circumcircle(tri.a, tri.b, tri.c);
                    delaunayCtx.beginPath();
                    delaunayCtx.arc(circle.x, circle.y, circle.r, 0, Math.PI * 2);
                    delaunayCtx.strokeStyle = 'rgba(156, 39, 176, 0.5)';
                    delaunayCtx.lineWidth = 1;
                    delaunayCtx.stroke();
                });
            }

            // Desenha Voronoi se selecionado
            if (vizMode === 'voronoi' && delaunayPoints.length > 0) {
                drawVoronoiDual();
            }

            // Desenha pontos
            delaunayPoints.forEach(point => {
                delaunayCtx.beginPath();
                delaunayCtx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                delaunayCtx.fillStyle = '#5c6d82';
                delaunayCtx.fill();
                delaunayCtx.strokeStyle = '#273E74';
                delaunayCtx.lineWidth = 2;
                delaunayCtx.stroke();
            });
        }

        function drawVoronoiDual() {
            // Desenha células de Voronoi baseado na triangulação
            delaunayTriangles.forEach(tri => {
                const circle = circumcircle(tri.a, tri.b, tri.c);
                
                delaunayCtx.beginPath();
                delaunayCtx.arc(circle.x, circle.y, 3, 0, Math.PI * 2);
                delaunayCtx.fillStyle = '#f44336';
                delaunayCtx.fill();
            });

            // Conecta centros (arestas de Voronoi)
            delaunayTriangles.forEach((tri1, i) => {
                const c1 = circumcircle(tri1.a, tri1.b, tri1.c);
                
                delaunayTriangles.forEach((tri2, j) => {
                    if (i >= j) return;
                    
                    const shared = countSharedVertices(tri1, tri2);
                    if (shared === 2) {
                        const c2 = circumcircle(tri2.a, tri2.b, tri2.c);
                        delaunayCtx.beginPath();
                        delaunayCtx.moveTo(c1.x, c1.y);
                        delaunayCtx.lineTo(c2.x, c2.y);
                        delaunayCtx.strokeStyle = '#f44336';
                        delaunayCtx.lineWidth = 1;
                        delaunayCtx.setLineDash([5, 5]);
                        delaunayCtx.stroke();
                        delaunayCtx.setLineDash([]);
                    }
                });
            });
        }

        function countSharedVertices(tri1, tri2) {
            const vertices1 = [tri1.a, tri1.b, tri1.c];
            const vertices2 = [tri2.a, tri2.b, tri2.c];
            let count = 0;
            vertices1.forEach(v1 => {
                if (vertices2.some(v2 => v1.x === v2.x && v1.y === v2.y)) {
                    count++;
                }
            });
            return count;
        }

        function circumcircle(a, b, c) {
            const ax = a.x, ay = a.y;
            const bx = b.x, by = b.y;
            const cx = c.x, cy = c.y;

            const d = 2 * (
                ax * (by - cy) +
                bx * (cy - ay) +
                cx * (ay - by)
            );

            if (Math.abs(d) < 1e-6) {
                return {
                    x: (ax + bx + cx) / 3,
                    y: (ay + by + cy) / 3,
                    r: Infinity
                };
            }

            const ux = (
                (ax * ax + ay * ay) * (by - cy) +
                (bx * bx + by * by) * (cy - ay) +
                (cx * cx + cy * cy) * (ay - by)
            ) / d;

            const uy = (
                (ax * ax + ay * ay) * (cx - bx) +
                (bx * bx + by * by) * (ax - cx) +
                (cx * cx + cy * cy) * (bx - ax)
            ) / d;

            const dx = ux - ax;
            const dy = uy - ay;

            return {
                x: ux,
                y: uy,
                r: Math.sqrt(dx * dx + dy * dy)
            };
        }


        function inCircumcircle(p, tri) {
            const c = circumcircle(tri.a, tri.b, tri.c);
            const dx = p.x - c.x;
            const dy = p.y - c.y;
            return dx * dx + dy * dy <= c.r * c.r;
        }

        async function startDelaunay() {
            if (delaunayAnimating) return;
            if (delaunayPoints.length < 3) {
                alert('Gere pelo menos 3 pontos primeiro!');
                return;
            }

            delaunayAnimating = true;
            delaunayShouldStop = false;
            document.getElementById('delaunayStart').disabled = true;
            document.getElementById('delaunayGenerate').disabled = true;
            document.getElementById('delaunayVisualization').disabled = true;
            document.getElementById('delaunayPoints').disabled = true;

            delaunayTriangles = [];

            // Super-triângulo
            const superTriangle = {
                a: { x: -1000, y: -1000 },
                b: { x: 3000, y: -1000 },
                c: { x: 1000, y: 3000 }
            };
            delaunayTriangles.push(superTriangle);

            // Algoritmo Bowyer-Watson
            for (let i = 0; i < delaunayPoints.length; i++) {
                if (delaunayShouldStop) break;

                const point = delaunayPoints[i];
                const badTriangles = [];

                // Encontra triângulos "ruins"
                delaunayTriangles.forEach((tri, idx) => {
                    if (inCircumcircle(point, tri)) {
                        badTriangles.push(idx);
                    }
                });

                // Encontra polígono
                const polygon = [];
                badTriangles.forEach(idx => {
                    const tri = delaunayTriangles[idx];
                    const edges = [
                        [tri.a, tri.b],
                        [tri.b, tri.c],
                        [tri.c, tri.a]
                    ];

                    edges.forEach(edge => {
                        let shared = false;
                        badTriangles.forEach(otherIdx => {
                            if (idx === otherIdx) return;
                            const otherTri = delaunayTriangles[otherIdx];
                            const otherEdges = [
                                [otherTri.a, otherTri.b],
                                [otherTri.b, otherTri.c],
                                [otherTri.c, otherTri.a]
                            ];
                            
                            otherEdges.forEach(otherEdge => {
                                if ((edge[0] === otherEdge[0] && edge[1] === otherEdge[1]) ||
                                    (edge[0] === otherEdge[1] && edge[1] === otherEdge[0])) {
                                    shared = true;
                                }
                            });
                        });

                        if (!shared) {
                            polygon.push(edge);
                        }
                    });
                });

                // Remove triângulos ruins
                for (let j = badTriangles.length - 1; j >= 0; j--) {
                    delaunayTriangles.splice(badTriangles[j], 1);
                }

                // Adiciona novos triângulos
                polygon.forEach(edge => {
                    delaunayTriangles.push({
                        a: edge[0],
                        b: edge[1],
                        c: point
                    });
                });

                drawDelaunay(delaunayTriangles.length - 1);
                await sleep(parseInt(document.getElementById('delaunaySpeed').value));
            }

            // Remove triângulos conectados ao super-triângulo
            delaunayTriangles = delaunayTriangles.filter(tri => {
                return !([tri.a, tri.b, tri.c].some(v => 
                    v === superTriangle.a || v === superTriangle.b || v === superTriangle.c
                ));
            });

            // Calcula estatísticas
            const uniqueEdges = new Set();
            delaunayTriangles.forEach(tri => {
                [[tri.a, tri.b], [tri.b, tri.c], [tri.c, tri.a]].forEach(edge => {
                    const key = [edge[0].x, edge[0].y, edge[1].x, edge[1].y].sort().join(',');
                    uniqueEdges.add(key);
                });
            });

            document.getElementById('delaunayTriangleCount').textContent = delaunayTriangles.length;
            document.getElementById('delaunayEdgeCount').textContent = uniqueEdges.size;

            drawDelaunay();
            delaunayAnimating = false;
            document.getElementById('delaunayStart').disabled = false;
            document.getElementById('delaunayGenerate').disabled = false;
            document.getElementById('delaunayVisualization').disabled = false;
            document.getElementById('delaunayPoints').disabled = false;
        }

        function resetDelaunay() {
            delaunayShouldStop = true;
            delaunayAnimating = false;
            delaunayTriangles = [];
            drawDelaunay();
            document.getElementById('delaunayStart').disabled = false;
            document.getElementById('delaunayGenerate').disabled = false;
            document.getElementById('delaunayVisualization').disabled = false;
            document.getElementById('delaunayPoints').disabled = false;
        }

        document.getElementById('delaunaySpeed').addEventListener('input', (e) => {
            document.getElementById('delaunaySpeedValue').textContent = e.target.value + 'ms';
        });

        document.getElementById('delaunayPoints').addEventListener('input', (e) => {
            document.getElementById('delaunayPointsValue').textContent = e.target.value;
        });

        document.getElementById('delaunayVisualization').addEventListener('change', () => {
            drawDelaunay();
        });

        // ============== BUSCA LINEAR EM CANVAS =================
        (function () {

            const canvas = document.getElementById("linearCanvas");
            if (!canvas) return;

            const ctx = canvas.getContext("2d");

            const ARRAY_SIZE = 9;
            const MIN_VALUE = 1;
            const MAX_VALUE = 9;

            let values = [];
            let target = null;

            function generateRandomData() {
                const pool = [];

                for (let i = MIN_VALUE; i <= MAX_VALUE; i++) {
                    pool.push(i);
                }

                // embaralha
                for (let i = pool.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pool[i], pool[j]] = [pool[j], pool[i]];
                }

                values = pool.slice(0, ARRAY_SIZE);

                // agora o alvo é único
                target = values[Math.floor(Math.random() * values.length)];
            }

            let index = 0;
            let running = false;
            let anim = null;

            const boxSize = 60;
            const startX = 50;
            const startY = 60;

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                values.forEach((value, i) => {
                    const x = startX + i * (boxSize + 10);

                    ctx.fillStyle = value === target ? "#d1ecff" : "#ddd";
                    ctx.fillRect(x, startY, boxSize, boxSize);

                    ctx.strokeStyle = "#333";
                    ctx.strokeRect(x, startY, boxSize, boxSize);

                    ctx.fillStyle = "#000";
                    ctx.font = "18px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(value, x + boxSize / 2, startY + boxSize / 2);

                    // índice
                    ctx.fillStyle = "#555";
                    ctx.font = "13px Arial";
                    ctx.fillText(i, x + boxSize / 2, startY + boxSize + 15);
                });

                // cursor
                if (running && index < values.length) {
                    const cx = startX + index * (boxSize + 10) + boxSize / 2;

                    ctx.fillStyle = "#ff9800";
                    ctx.beginPath();
                    ctx.arc(cx, startY - 15, 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillText("?", cx, startY - 35);
                }
            }

            function startLinearCanvas() {
                if (running) return;

                running = true;
                document.getElementById('startLinearSearch').disabled = true;
                index = 0;

                document.getElementById("linearCanvasStatus").textContent =
                    "Procurando o valor " + target + "...";

                anim = setInterval(() => {
                    if (index >= values.length) {
                        document.getElementById("linearCanvasStatus").textContent =
                            "Valor não encontrado.";
                        clearInterval(anim);
                        running = false;
                        document.getElementById('startLinearSearch').disabled = false;
                        return;
                    }

                    if (values[index] === target) {
                        highlightFound(index);
                        document.getElementById("linearCanvasStatus").textContent =
                            "Valor encontrado na posição " + index + ".";
                        clearInterval(anim);
                        running = false;
                        document.getElementById('startLinearSearch').disabled = false;
                        return;
                    }

                    index++;
                    draw();
                }, 800);

                draw();
            }

            function highlightFound(i) {
                const x = startX + i * (boxSize + 10);

                ctx.fillStyle = "#4CAF50";
                ctx.fillRect(x, startY, boxSize, boxSize);
                ctx.strokeRect(x, startY, boxSize, boxSize);

                ctx.fillStyle = "#fff";
                ctx.font = "18px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                ctx.fillText(
                    values[i],
                    x + boxSize / 2,
                    startY + boxSize / 2
                );
            }

            function resetLinearCanvas() {
                clearInterval(anim);
                running = false;
                document.getElementById('startLinearSearch').disabled = false;
                index = 0;

                document.getElementById("linearCanvasStatus").textContent = "";
                generateRandomData();
                draw();
            }

            window.startLinearCanvas = startLinearCanvas;
            window.resetLinearCanvas = resetLinearCanvas;

            generateRandomData();
            draw();
        })();

        // ========== KNN (K-NEAREST NEIGHBORS) ==========
        const knnCanvas = document.getElementById('knnCanvas');
        const knnCtx = knnCanvas.getContext('2d', {
            willReadFrequently: true
        });
        let knnPoints = [];
        let knnAnimating = false;
        let knnShouldStop = false;
        const knnPadding = 30;
        let knnBackgroundImage = null;

        const knnColors = {
            0: { fill: '#f44336', border: '#c62828', bg: 'rgba(244, 67, 54, 0.15)' },
            1: { fill: '#2196F3', border: '#1565C0', bg: 'rgba(33, 150, 243, 0.15)' },
            2: { fill: '#4CAF50', border: '#2E7D32', bg: 'rgba(76, 175, 80, 0.15)' }
        };

        function initKNN() {
            knnPoints = [];
            knnBackgroundImage = null;
            updateKNNStats();
            drawKNN();
        }

        function drawKNN(highlightPoint = null, neighbors = []) {
            knnCtx.clearRect(0, 0, knnCanvas.width, knnCanvas.height);

            if (knnBackgroundImage) {
                knnCtx.putImageData(knnBackgroundImage, 0, 0);
            } else {
                knnCtx.fillStyle = '#f9f9f9';
                knnCtx.fillRect(0, 0, knnCanvas.width, knnCanvas.height);
            }
            
            // Desenha linhas para vizinhos
            if (highlightPoint && neighbors.length > 0) {
                neighbors.forEach(neighbor => {
                    knnCtx.beginPath();
                    knnCtx.moveTo(highlightPoint.x, highlightPoint.y);
                    knnCtx.lineTo(neighbor.x, neighbor.y);
                    knnCtx.strokeStyle = '#ff9800';
                    knnCtx.lineWidth = 2;
                    knnCtx.setLineDash([5, 5]);
                    knnCtx.stroke();
                    knnCtx.setLineDash([]);
                });
            }

            // Desenha círculos ao redor dos vizinhos
            if (neighbors.length > 0) {
                neighbors.forEach(neighbor => {
                    knnCtx.beginPath();
                    knnCtx.arc(neighbor.x, neighbor.y, 15, 0, Math.PI * 2);
                    knnCtx.strokeStyle = '#ff9800';
                    knnCtx.lineWidth = 2;
                    knnCtx.setLineDash([5, 5]);
                    knnCtx.stroke();
                    knnCtx.setLineDash([]);
                });
            }

            // Desenha pontos de dados
            knnPoints.forEach(point => {
                const colors = knnColors[point.class];
                
                knnCtx.beginPath();
                knnCtx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                knnCtx.fillStyle = colors.fill;
                knnCtx.fill();
                knnCtx.strokeStyle = colors.border;
                knnCtx.lineWidth = 2;
                knnCtx.stroke();
            });

            // Desenha ponto a classificar
            if (highlightPoint) {
                knnCtx.beginPath();
                knnCtx.arc(highlightPoint.x, highlightPoint.y, 10, 0, Math.PI * 2);
                knnCtx.fillStyle = '#FFD700';
                knnCtx.fill();
                knnCtx.strokeStyle = '#F57C00';
                knnCtx.lineWidth = 3;
                knnCtx.stroke();
            }
        }

        function updateKNNStats() {
            const counts = [0, 0, 0];
            knnPoints.forEach(p => counts[p.class]++);
            document.getElementById('knnClassA').textContent = counts[0];
            document.getElementById('knnClassB').textContent = counts[1];
            document.getElementById('knnClassC').textContent = counts[2];
        }

        function distance(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function classifyPoint(point, k) {
            if (knnPoints.length === 0) return null;

            // Calcula distâncias
            const distances = knnPoints.map(p => ({
                point: p,
                distance: distance(point, p)
            }));

            // Ordena por distância
            distances.sort((a, b) => a.distance - b.distance);

            // Pega os K vizinhos mais próximos
            const neighbors = distances.slice(0, Math.min(k, distances.length));

            // Voto majoritário
            const votes = [0, 0, 0];
            neighbors.forEach(n => votes[n.point.class]++);

            // Retorna classe com mais votos
            const maxVotes = Math.max(...votes);
            const predictedClass = votes.indexOf(maxVotes);

            return {
                class: predictedClass,
                neighbors: neighbors.map(n => n.point),
                votes: votes
            };
        }

        knnCanvas.addEventListener('click', (e) => {
            if (knnAnimating) return;

            const { x, y } = getCanvasCoords(knnCanvas, e);
            const selectedClass = parseInt(document.getElementById('knnClassSelect').value);

            knnPoints.push({ x, y, class: selectedClass });
            updateKNNStats();
            drawKNN();
        });

        knnCanvas.addEventListener('contextmenu', async (e) => {
            e.preventDefault();
            if (knnAnimating) return;
            if (knnPoints.length === 0) {
                alert('Adicione pontos de treino primeiro!');
                return;
            }

            const { x, y } = getCanvasCoords(knnCanvas, e);
            const point = { x, y };

            const k = parseInt(document.getElementById('knnK').value);
            const result = classifyPoint(point, k);

            if (result) {
                drawKNN(point, result.neighbors);

                const classNames = ['A (Vermelho)', 'B (Azul)', 'C (Verde)'];
                const votesStr = `A:${result.votes[0]}, B:${result.votes[1]}, C:${result.votes[2]}`;

                setTimeout(() => {
                    alert(
                        `Classificado como Classe ${classNames[result.class]}\n\n` +
                        `Votos: ${votesStr}\n` +
                        `Vizinhos analisados: ${result.neighbors.length}`
                    );
                    drawKNN();
                }, 100);
            }
        });

        function generateKNNData() {
            if (knnAnimating) return;
            
            knnPoints = [];

            // Pontos ambíguos no centro
            for (let i = 0; i < 6; i++) {
                knnPoints.push({
                    x: Math.random() * 150 + 275,
                    y: Math.random() * 150 + 225,
                    class: i % 3
                });
            }
            
            // Cluster A (canto superior esquerdo)
            for (let i = 0; i < 15; i++) {
                knnPoints.push({
                    x: Math.random() * 200 + 50,
                    y: Math.random() * 200 + 50,
                    class: 0
                });
            }

            // Cluster B (canto superior direito)
            for (let i = 0; i < 15; i++) {
                knnPoints.push({
                    x: Math.random() * 200 + 450,
                    y: Math.random() * 200 + 50,
                    class: 1
                });
            }

            // Cluster C (centro inferior)
            for (let i = 0; i < 15; i++) {
                knnPoints.push({
                    x: Math.random() * 200 + 250,
                    y: Math.random() * 200 + 350,
                    class: 2
                });
            }

            updateKNNStats();
            drawKNN();
        }

        function clearKNNData() {
            if (knnAnimating) return;
            knnBackgroundImage = null;
            initKNN();
        }

        async function classifyAllKNN() {
            if (knnAnimating) return;
            if (knnPoints.length === 0) {
                alert('Adicione pontos de treino primeiro!');
                return;
            }

            knnAnimating = true;
            knnShouldStop = false;
            document.getElementById('knnClassifyAll').disabled = true;
            document.getElementById('knnK').disabled = true;
            document.querySelectorAll('#knnCanvas').forEach(el => {
                el.closest('.section').querySelectorAll('button').forEach(btn => {
                    if (!btn.textContent.includes('Classificar Área')) btn.disabled = true;
                });
            });

            const k = parseInt(document.getElementById('knnK').value);
            const gridSize = 10;
            let classified = 0;
            const totalPixels = Math.ceil(knnCanvas.width / gridSize) * Math.ceil(knnCanvas.height / gridSize);

            // Limpa e desenha fundo
            knnCtx.clearRect(0, 0, knnCanvas.width, knnCanvas.height);

            for (let y = 0; y < knnCanvas.height; y += gridSize) {
                if (knnShouldStop) break;

                for (let x = 0; x < knnCanvas.width; x += gridSize) {
                    if (knnShouldStop) break;

                    const point = { x: x + gridSize / 2, y: y + gridSize / 2 };
                    const result = classifyPoint(point, k);

                    if (result) {
                        const colors = knnColors[result.class];
                        knnCtx.fillStyle = colors.bg;
                        knnCtx.fillRect(x, y, gridSize, gridSize);
                    }

                    classified++;
                    document.getElementById('knnClassified').textContent = classified;

                    if (classified % 50 === 0) {
                        await sleep(parseInt(document.getElementById('knnSpeed').value));
                    }
                }
            }

            // Redesenha pontos por cima
            knnPoints.forEach(point => {
                const colors = knnColors[point.class];
                
                knnCtx.beginPath();
                knnCtx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                knnCtx.fillStyle = colors.fill;
                knnCtx.fill();
                knnCtx.strokeStyle = colors.border;
                knnCtx.lineWidth = 2;
                knnCtx.stroke();
            });

            knnAnimating = false;
            document.getElementById('knnClassifyAll').disabled = false;
            document.getElementById('knnK').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                btn.disabled = false;
            });

            knnBackgroundImage = knnCtx.getImageData(
                0, 0, knnCanvas.width, knnCanvas.height
            );
        }

        function resetKNN() {
            knnShouldStop = true;
            knnAnimating = false;
            knnBackgroundImage = null;
            document.getElementById('knnClassified').textContent = 0;
            initKNN();
            document.getElementById('knnClassifyAll').disabled = false;
            document.getElementById('knnK').disabled = false;
            document.querySelectorAll('button').forEach(btn => {
                btn.disabled = false;
            });
        }

        document.getElementById('knnK').addEventListener('input', (e) => {
            document.getElementById('knnKValue').textContent = e.target.value;
        });

        document.getElementById('knnSpeed').addEventListener('input', (e) => {
            document.getElementById('knnSpeedValue').textContent = e.target.value + 'ms';
        });

        // ========== SUDOKU SOLVER ==========
        const sudokuCanvas = document.getElementById('sudokuCanvas');
        const sudokuCtx = sudokuCanvas.getContext('2d');
        const sudokuSize = 9;
        const sudokuCellSize = 60;
        let sudokuGrid = [];
        let sudokuInitial = [];
        let sudokuAnimating = false;
        let sudokuShouldStop = false;
        let sudokuAttempts = 0;
        let sudokuBacktracks = 0;
        let sudokuSelectedCell = null;

        function initSudoku() {
            sudokuGrid = Array(9).fill().map(() => Array(9).fill(0));
            sudokuInitial = Array(9).fill().map(() => Array(9).fill(false));
            sudokuAttempts = 0;
            sudokuBacktracks = 0;
            updateSudokuStats();
            drawSudoku();
        }

        function drawSudoku(highlightRow = -1, highlightCol = -1, state = 'normal', testingNumber = null) {
            sudokuCtx.clearRect(0, 0, sudokuCanvas.width, sudokuCanvas.height);
            
            // Fundo
            sudokuCtx.fillStyle = '#ffffff';
            sudokuCtx.fillRect(0, 0, sudokuCanvas.width, sudokuCanvas.height);

            // Desenha células
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const x = col * sudokuCellSize;
                    const y = row * sudokuCellSize;

                    // Cor de fundo
                    if (row === highlightRow && col === highlightCol) {
                        if (state === 'trying') {
                            sudokuCtx.fillStyle = '#fff9c4'; // Amarelo - testando
                        } else if (state === 'correct') {
                            sudokuCtx.fillStyle = '#c8e6c9'; // Verde - correto
                        } else if (state === 'backtrack') {
                            sudokuCtx.fillStyle = '#ffcdd2'; // Vermelho - backtracking
                        } else if (state === 'filling') {
                            sudokuCtx.fillStyle = '#b2dfdb'; // Verde água - preenchendo solução
                        }
                    } else if (sudokuInitial[row][col]) {
                        sudokuCtx.fillStyle = '#e3f2fd'; // Azul claro para números iniciais
                    } else if (sudokuGrid[row][col] !== 0) {
                        sudokuCtx.fillStyle = '#f0f0f0';
                    } else {
                        sudokuCtx.fillStyle = '#ffffff';
                    }

                    sudokuCtx.fillRect(x, y, sudokuCellSize, sudokuCellSize);

                    // Destaque de seleção
                    if (sudokuSelectedCell && sudokuSelectedCell.row === row && sudokuSelectedCell.col === col) {
                        sudokuCtx.fillStyle = 'rgba(255, 193, 7, 0.3)';
                        sudokuCtx.fillRect(x, y, sudokuCellSize, sudokuCellSize);
                    }

                    // Linhas finas
                    sudokuCtx.strokeStyle = '#999';
                    sudokuCtx.lineWidth = 1;
                    sudokuCtx.strokeRect(x, y, sudokuCellSize, sudokuCellSize);

                    // Números
                    if (row === highlightRow && col === highlightCol && testingNumber !== null && state === 'trying') {
                        // Mostra número sendo testado em destaque
                        sudokuCtx.fillStyle = '#F57F17';
                        sudokuCtx.font = 'bold 32px Arial';
                        sudokuCtx.textAlign = 'center';
                        sudokuCtx.textBaseline = 'middle';
                        sudokuCtx.fillText(
                            testingNumber,
                            x + sudokuCellSize / 2,
                            y + sudokuCellSize / 2
                        );
                    } else if (sudokuGrid[row][col] !== 0) {
                        sudokuCtx.fillStyle = sudokuInitial[row][col] ? '#1565C0' : '#333';
                        sudokuCtx.font = sudokuInitial[row][col] ? 'bold 28px Arial' : '24px Arial';
                        sudokuCtx.textAlign = 'center';
                        sudokuCtx.textBaseline = 'middle';
                        sudokuCtx.fillText(
                            sudokuGrid[row][col],
                            x + sudokuCellSize / 2,
                            y + sudokuCellSize / 2
                        );
                    }
                }
            }

            // Linhas grossas (3x3)
            sudokuCtx.strokeStyle = '#333';
            sudokuCtx.lineWidth = 3;
            for (let i = 0; i <= 8; i += 3) {
                sudokuCtx.beginPath();
                sudokuCtx.moveTo(i * sudokuCellSize, 0);
                sudokuCtx.lineTo(i * sudokuCellSize, 9 * sudokuCellSize);
                sudokuCtx.stroke();

                sudokuCtx.beginPath();
                sudokuCtx.moveTo(0, i * sudokuCellSize);
                sudokuCtx.lineTo(9 * sudokuCellSize, i * sudokuCellSize);
                sudokuCtx.stroke();
            }
        }

        function isValidSudoku(grid, row, col, num) {
            // Verifica linha
            for (let x = 0; x < 9; x++) {
                if (grid[row][x] === num) return false;
            }

            // Verifica coluna
            for (let x = 0; x < 9; x++) {
                if (grid[x][col] === num) return false;
            }

            // Verifica quadrante 3x3
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (grid[startRow + i][startCol + j] === num) return false;
                }
            }

            return true;
        }

        function findEmptyCell(grid) {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) {
                        return { row, col };
                    }
                }
            }
            return null;
        }

        async function solveSudokuBacktrack(grid, vizMode, solution = null) {
            if (sudokuShouldStop) return false;

            const empty = findEmptyCell(grid);
            if (!empty) return true; // Resolvido!

            const { row, col } = empty;

            for (let num = 1; num <= 9; num++) {
                if (sudokuShouldStop) return false;

                sudokuAttempts++;
                updateSudokuStats();

                // Mostra o número sendo testado
                if (vizMode === 'full') {
                    drawSudoku(row, col, 'trying', num);
                    await sleep(parseInt(document.getElementById('sudokuSpeed').value));
                }

                if (isValidSudoku(grid, row, col, num)) {
                    grid[row][col] = num;
                    if (vizMode !== 'solution') {
                        sudokuGrid[row][col] = num;
                    }

                    // Guarda solução se estiver no modo solution
                    if (vizMode === 'solution' && solution) {
                        solution.push({ row, col, num });
                    }

                    // Visualização de colocação (sem mostrar o número ainda no modo solution)
                    if (vizMode === 'full') {
                        if (!sudokuAnimating) return;
                        drawSudoku(row, col, 'correct');
                        await sleep(parseInt(document.getElementById('sudokuSpeed').value) / 2);
                    }

                    if (await solveSudokuBacktrack(grid, vizMode, solution)) {
                        return true;
                    }

                    // Backtrack
                    if (vizMode === 'solution' && solution) {
                        solution.pop(); // Remove da solução se backtrack
                    }
                    
                    grid[row][col] = 0;
                    sudokuGrid[row][col] = 0;
                    sudokuBacktracks++;
                    updateSudokuStats();

                    if (vizMode === 'full' || vizMode === 'backtrack') {
                        if (!sudokuAnimating) return;
                        drawSudoku(row, col, 'backtrack');
                        await sleep(parseInt(document.getElementById('sudokuSpeed').value));
                    }
                }
            }

            return false;
        }

        async function fillSolutionGradually(solution) {
            document.getElementById('sudokuStatus').textContent = 'Preenchendo solução...';
            
            for (const step of solution) {
                if (sudokuShouldStop) break;
                
                sudokuGrid[step.row][step.col] = step.num;
                drawSudoku(step.row, step.col, 'filling');
                await sleep(parseInt(document.getElementById('sudokuSpeed').value) * 2);
            }
            
            drawSudoku(); // Desenho final
        }

        function lockSudokuUI() {
            // Botões
            document
                .querySelectorAll('.section button')
                .forEach(btn => {
                    if (!btn.textContent.includes('Resetar')) {
                        btn.disabled = true;
                    }
                });

            // Select de modo
            document.getElementById('sudokuVizMode').disabled = true;
        }

        function unlockSudokuUI() {
            document
                .querySelectorAll('.section button')
                .forEach(btn => btn.disabled = false);

            document.getElementById('sudokuVizMode').disabled = false;
        }

        async function solveSudoku() {
            if (sudokuAnimating) return;

            // Verifica se há algum número
            let hasNumbers = false;
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (sudokuGrid[i][j] !== 0) {
                        hasNumbers = true;
                        break;
                    }
                }
                if (hasNumbers) break;
            }

            if (!hasNumbers) {
                alert('Adicione alguns números primeiro ou gere um puzzle!');
                return;
            }

            sudokuAnimating = true;
            sudokuShouldStop = false;
            lockSudokuUI();

            sudokuAttempts = 0;
            sudokuBacktracks = 0;
            updateSudokuStats();

            document.getElementById('sudokuStatus').textContent = 'Resolvendo...';

            const vizMode = document.getElementById('sudokuVizMode').value;
            const gridCopy = sudokuGrid.map(row => [...row]);
            
            // Array para guardar a solução no modo 'solution'
            const solution = vizMode === 'solution' ? [] : null;

            const solved = await solveSudokuBacktrack(gridCopy, vizMode, solution);

            if (solved && !sudokuShouldStop) {
                if (vizMode === 'solution' && solution) {
                    // No modo solution, preenche gradualmente
                    await fillSolutionGradually(solution);
                } else {
                    // Nos outros modos, já está preenchido
                    sudokuGrid = gridCopy;
                    drawSudoku();
                }
                document.getElementById('sudokuStatus').textContent = '✓ Resolvido!';
            } else if (sudokuShouldStop) {
                document.getElementById('sudokuStatus').textContent = 'Cancelado';
            } else {
                document.getElementById('sudokuStatus').textContent = '✗ Sem solução';
            }

            sudokuAnimating = false;
            unlockSudokuUI();
        }

        function generateCompleteSudoku() {
            const grid = Array(9).fill().map(() => Array(9).fill(0));

            function fillGrid(g) {
                const empty = findEmptyCell(g);
                if (!empty) return true;

                const { row, col } = empty;
                const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                
                // Embaralha
                for (let i = numbers.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
                }

                for (const num of numbers) {
                    if (isValidSudoku(g, row, col, num)) {
                        g[row][col] = num;
                        if (fillGrid(g)) return true;
                        g[row][col] = 0;
                    }
                }

                return false;
            }

            fillGrid(grid);
            return grid;
        }

        function generateSudokuPuzzle(difficulty) {
            if (sudokuAnimating) return;

            const complete = generateCompleteSudoku();
            sudokuGrid = complete.map(row => [...row]);
            sudokuInitial = Array(9).fill().map(() => Array(9).fill(false));

            // Remove números baseado na dificuldade
            const cellsToRemove = {
                'easy': 40,
                'medium': 50,
                'hard': 56
            }[difficulty];

            const positions = [];
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    positions.push({ row: i, col: j });
                }
            }

            // Embaralha posições
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            // Remove células
            for (let i = 0; i < cellsToRemove; i++) {
                const { row, col } = positions[i];
                sudokuGrid[row][col] = 0;
            }

            // Marca células iniciais
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (sudokuGrid[i][j] !== 0) {
                        sudokuInitial[i][j] = true;
                    }
                }
            }

            sudokuAttempts = 0;
            sudokuBacktracks = 0;
            updateSudokuStats();
            document.getElementById('sudokuStatus').textContent = `Puzzle ${difficulty}`;
            drawSudoku();
        }

        function clearSudoku() {
            if (sudokuAnimating) return;
            
            // Limpa apenas células não iniciais
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (!sudokuInitial[i][j]) {
                        sudokuGrid[i][j] = 0;
                    }
                }
            }
            
            sudokuAttempts = 0;
            sudokuBacktracks = 0;
            updateSudokuStats();
            document.getElementById('sudokuStatus').textContent = 'Limpo';
            drawSudoku();
        }

        function resetSudoku() {
            sudokuShouldStop = true;
            sudokuAnimating = false;
            initSudoku();
            document.getElementById('sudokuStatus').textContent = 'Resetado';
            unlockSudokuUI();
        }

        function updateSudokuStats() {
            document.getElementById('sudokuAttempts').textContent = sudokuAttempts;
            document.getElementById('sudokuBacktracks').textContent = sudokuBacktracks;
            
            let filled = 0;
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (sudokuGrid[i][j] !== 0) filled++;
                }
            }
            document.getElementById('sudokuFilled').textContent = filled;
        }

        // Interação com clique
        sudokuCanvas.addEventListener('click', (e) => {
            if (sudokuAnimating) return;

            const { x, y } = getCanvasCoords(sudokuCanvas, e);

            const col = Math.floor(x / sudokuCellSize);
            const row = Math.floor(y / sudokuCellSize);

            if (row >= 0 && row < 9 && col >= 0 && col < 9) {
                if (!sudokuInitial[row][col]) {
                    sudokuSelectedCell = { row, col };
                    drawSudoku();
                }
            }
        });

        // Teclado
        document.addEventListener('keydown', (e) => {
            if (sudokuAnimating || !sudokuSelectedCell) return;

            const { row, col } = sudokuSelectedCell;

            if (e.key >= '1' && e.key <= '9') {
                const num = parseInt(e.key);
                sudokuGrid[row][col] = num;
                updateSudokuStats();
                drawSudoku();
            } else if (e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') {
                sudokuGrid[row][col] = 0;
                updateSudokuStats();
                drawSudoku();
            }
        });

        document.getElementById('sudokuSpeed').addEventListener('input', (e) => {
            document.getElementById('sudokuSpeedValue').textContent = e.target.value + 'ms';
        });

        // ========== SIEVE OF ERATOSTHENES ==========
        const sieveCanvas = document.getElementById('sieveCanvas');
        const sieveCtx = sieveCanvas.getContext('2d');
        let sieveAnimating = false;
        let sieveShouldStop = false;
        let sieveNumbers = [];

        function initSieve() {
            const limit = parseInt(document.getElementById('sieveLimit').value);
            sieveNumbers = [];
            
            for (let i = 2; i <= limit; i++) {
                sieveNumbers.push({
                    value: i,
                    isPrime: true,
                    isEliminated: false,
                    isCurrent: false,
                    isBeingEliminated: false
                });
            }
            
            document.getElementById('sieveCurrentPrime').textContent = '-';
            document.getElementById('sievePrimeCount').textContent = 0;
            document.getElementById('sieveEliminated').textContent = 0;
            document.getElementById('sieveProgress').textContent = '0%';
            
            drawSieve();
        }

        function drawSieve() {
            const mode = document.getElementById('sieveVizMode').value;
            
            if (mode === 'grid') {
                drawSieveGrid();
            } else {
                drawSieveSpiral();
            }
        }

        function drawSieveGrid() {
            sieveCtx.clearRect(0, 0, sieveCanvas.width, sieveCanvas.height);
            sieveCtx.fillStyle = '#f9f9f9';
            sieveCtx.fillRect(0, 0, sieveCanvas.width, sieveCanvas.height);
            
            const cols = 20;
            const cellSize = 38;
            const startX = 10;
            const startY = 10;
            
            sieveNumbers.forEach((num, index) => {
                const row = Math.floor(index / cols);
                const col = index % cols;
                const x = startX + col * cellSize;
                const y = startY + row * cellSize;
                
                // Cor de fundo
                if (num.isCurrent) {
                    sieveCtx.fillStyle = '#FFD700'; // Dourado - primo atual
                } else if (num.isBeingEliminated) {
                    sieveCtx.fillStyle = '#f44336'; // Vermelho - sendo eliminado
                } else if (num.isEliminated) {
                    sieveCtx.fillStyle = '#999'; // Cinza - eliminado
                } else if (!num.isPrime && !num.isEliminated) {
                    sieveCtx.fillStyle = '#f0f0f0'; // Cinza claro - não processado
                } else if (num.isPrime) {
                    sieveCtx.fillStyle = '#4CAF50'; // Verde - primo
                } else {
                    sieveCtx.fillStyle = '#f0f0f0';
                }
                
                sieveCtx.fillRect(x, y, cellSize - 2, cellSize - 2);
                
                // Borda
                sieveCtx.strokeStyle = num.isCurrent ? '#F57C00' : '#ddd';
                sieveCtx.lineWidth = num.isCurrent ? 3 : 1;
                sieveCtx.strokeRect(x, y, cellSize - 2, cellSize - 2);
                
                // Número
                sieveCtx.fillStyle = num.isEliminated ? '#fff' : '#333';
                sieveCtx.font = num.isCurrent ? 'bold 14px Arial' : '12px Arial';
                sieveCtx.textAlign = 'center';
                sieveCtx.textBaseline = 'middle';
                sieveCtx.fillText(num.value, x + (cellSize - 2) / 2, y + (cellSize - 2) / 2);
            });
        }

        function drawSieveSpiral() {
            sieveCtx.clearRect(0, 0, sieveCanvas.width, sieveCanvas.height);
            sieveCtx.fillStyle = '#f9f9f9';
            sieveCtx.fillRect(0, 0, sieveCanvas.width, sieveCanvas.height);
            
            const limit = sieveNumbers.length + 1;
            const gridSize = Math.ceil(Math.sqrt(limit));
            const cellSize = Math.min(30, Math.floor(Math.min(sieveCanvas.width, sieveCanvas.height) / gridSize));
            const startX = (sieveCanvas.width - gridSize * cellSize) / 2;
            const startY = (sieveCanvas.height - gridSize * cellSize) / 2;
            
            // Gera coordenadas da espiral
            const spiral = generateSpiralCoordinates(gridSize);
            
            // Desenha apenas até o limite
            for (let i = 0; i < Math.min(spiral.length, limit); i++) {
                const { row, col } = spiral[i];
                const x = startX + col * cellSize;
                const y = startY + row * cellSize;
                
                const value = i + 1;
                
                // Encontra o número no array (se for >= 2)
                const numObj = value >= 2 ? sieveNumbers[value - 2] : null;
                
                // Cor de fundo
                if (value === 1) {
                    sieveCtx.fillStyle = '#e0e0e0'; // 1 não é primo nem composto
                } else if (numObj) {
                    if (numObj.isCurrent) {
                        sieveCtx.fillStyle = '#FFD700';
                    } else if (numObj.isBeingEliminated) {
                        sieveCtx.fillStyle = '#f44336';
                    } else if (numObj.isEliminated) {
                        sieveCtx.fillStyle = '#999';
                    } else if (numObj.isPrime) {
                        sieveCtx.fillStyle = '#4CAF50';
                    } else {
                        sieveCtx.fillStyle = '#f0f0f0';
                    }
                } else {
                    sieveCtx.fillStyle = '#f0f0f0';
                }
                
                sieveCtx.fillRect(x, y, cellSize - 1, cellSize - 1);
                
                // Borda
                sieveCtx.strokeStyle = (numObj && numObj.isCurrent) ? '#F57C00' : '#ddd';
                sieveCtx.lineWidth = (numObj && numObj.isCurrent) ? 2 : 0.5;
                sieveCtx.strokeRect(x, y, cellSize - 1, cellSize - 1);
                
                // Número (só mostra se cabe)
                if (cellSize > 15) {
                    sieveCtx.fillStyle = (numObj && numObj.isEliminated) ? '#fff' : '#333';
                    sieveCtx.font = (numObj && numObj.isCurrent) ? 'bold 10px Arial' : '9px Arial';
                    sieveCtx.textAlign = 'center';
                    sieveCtx.textBaseline = 'middle';
                    sieveCtx.fillText(value, x + (cellSize - 1) / 2, y + (cellSize - 1) / 2);
                }
            }
        }

        function generateSpiralCoordinates(gridSize) {
            const spiral = [];
            let row = Math.floor(gridSize / 2);
            let col = Math.floor(gridSize / 2);
            
            spiral.push({ row, col });
            
            let steps = 1;
            let direction = 0; // 0: direita, 1: cima, 2: esquerda, 3: baixo
            
            while (spiral.length < gridSize * gridSize) {
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < steps; j++) {
                        if (direction === 0) col++;
                        else if (direction === 1) row--;
                        else if (direction === 2) col--;
                        else if (direction === 3) row++;
                        
                        if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
                            spiral.push({ row, col });
                        }
                    }
                    direction = (direction + 1) % 4;
                }
                steps++;
            }
            
            return spiral;
        }

        async function startSieve() {
            if (sieveAnimating) return;
            
            sieveAnimating = true;
            sieveShouldStop = false;
            document.getElementById('sieveStart').disabled = true;
            document.querySelectorAll('#sieveCanvas').forEach(el => {
                el.closest('.section').querySelectorAll('button, input, select').forEach(elem => {
                    if (elem.id !== 'sieveSpeed') elem.disabled = true;
                    if (elem.id === 'sieveReset') elem.disabled = false;
                });
            });
            
            initSieve();
            
            const limit = parseInt(document.getElementById('sieveLimit').value);
            const sqrtLimit = Math.sqrt(limit);
            let primeCount = 0;
            let eliminated = 0;
            
            for (let i = 0; i < sieveNumbers.length; i++) {
                if (sieveShouldStop) break;
                
                const num = sieveNumbers[i];
                
                if (num.isPrime && !num.isEliminated) {
                    // Encontrou um primo
                    primeCount++;
                    num.isCurrent = true;
                    document.getElementById('sieveCurrentPrime').textContent = num.value;
                    document.getElementById('sievePrimeCount').textContent = primeCount;
                    
                    drawSieve();
                    await sleep(parseInt(document.getElementById('sieveSpeed').value) * 3);
                    
                    if (sieveShouldStop) break;
                    
                    // Elimina múltiplos
                    if (num.value <= sqrtLimit) {
                        for (let j = num.value * num.value; j <= limit; j += num.value) {
                            if (sieveShouldStop) break;
                            
                            const index = j - 2;
                            if (index >= 0 && index < sieveNumbers.length && !sieveNumbers[index].isEliminated) {
                                sieveNumbers[index].isBeingEliminated = true;
                                if (!sieveAnimating) return;
                                drawSieve();
                                await sleep(parseInt(document.getElementById('sieveSpeed').value));
                                
                                sieveNumbers[index].isBeingEliminated = false;
                                sieveNumbers[index].isEliminated = true;
                                sieveNumbers[index].isPrime = false;
                                eliminated++;
                                document.getElementById('sieveEliminated').textContent = eliminated;
                                if (!sieveAnimating) return;
                                drawSieve();
                            }
                        }
                    }
                    
                    num.isCurrent = false;
                    if (!sieveAnimating) return;
                    drawSieve();
                }
                
                // Atualiza progresso
                const progress = Math.floor(((i + 1) / sieveNumbers.length) * 100);
                document.getElementById('sieveProgress').textContent = progress + '%';
            }
            
            if (!sieveShouldStop) {
                // Conta primos finais
                primeCount = sieveNumbers.filter(n => n.isPrime && !n.isEliminated).length;
                document.getElementById('sievePrimeCount').textContent = primeCount;
                document.getElementById('sieveProgress').textContent = '100%';
                document.getElementById('sieveCurrentPrime').textContent = 'Completo!';
            }
            
            sieveAnimating = false;
            document.getElementById('sieveStart').disabled = false;
            document.querySelectorAll('button, input, select').forEach(elem => {
                elem.disabled = false;
            });
        }

        function resetSieve() {
            sieveShouldStop = true;
            sieveAnimating = false;
            initSieve();
            document.getElementById('sieveStart').disabled = false;
            document.querySelectorAll('button, input, select').forEach(elem => {
                elem.disabled = false;
            });
        }

        document.getElementById('sieveLimit').addEventListener('input', (e) => {
            document.getElementById('sieveLimitValue').textContent = e.target.value;
            if (!sieveAnimating) initSieve();
        });

        document.getElementById('sieveSpeed').addEventListener('input', (e) => {
            document.getElementById('sieveSpeedValue').textContent = e.target.value + 'ms';
        });

        document.getElementById('sieveVizMode').addEventListener('change', () => {
            if (!sieveAnimating) drawSieve();
        });

        // ========== FIBONACCI ==========
        const fibSequenceCanvas = document.getElementById('fibSequenceCanvas');
        const fibSequenceCtx = fibSequenceCanvas.getContext('2d');
        let fibSequence = [];
        let fibAnimating = false;
        let fibShouldStop = false;

        function drawFibSequence(highlightIndex = -1) {
            fibSequenceCtx.clearRect(0, 0, fibSequenceCanvas.width, fibSequenceCanvas.height);
            
            if (fibSequence.length === 0) return;

            const maxValue = Math.max(...fibSequence);
            const barWidth = (fibSequenceCanvas.width - 40) / fibSequence.length;
            const maxHeight = fibSequenceCanvas.height - 80;

            fibSequence.forEach((value, index) => {
                const height = maxValue > 0 ? (value / maxValue) * maxHeight : 0;
                const x = 20 + index * barWidth;
                const y = fibSequenceCanvas.height - height - 40;

                // Cor baseada no índice (gradiente)
                const hue = (index / fibSequence.length) * 280; // 0-280 (azul a roxo)
                
                if (index === highlightIndex) {
                    fibSequenceCtx.fillStyle = '#ff9800';
                } else {
                    fibSequenceCtx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                }

                fibSequenceCtx.fillRect(x, y, barWidth - 2, height);
                
                // Borda
                fibSequenceCtx.strokeStyle = '#273E74';
                fibSequenceCtx.lineWidth = 1;
                fibSequenceCtx.strokeRect(x, y, barWidth - 2, height);

                // Valor do número
                fibSequenceCtx.fillStyle = '#273E74';
                fibSequenceCtx.font = 'bold 12px Arial';
                fibSequenceCtx.textAlign = 'center';
                fibSequenceCtx.fillText(value, x + barWidth / 2 - 1, fibSequenceCanvas.height - 20);
                
                // Índice
                fibSequenceCtx.font = '10px Arial';
                fibSequenceCtx.fillStyle = '#666';
                fibSequenceCtx.fillText(`F(${index})`, x + barWidth / 2 - 1, fibSequenceCanvas.height - 5);
            });

            // Título
            fibSequenceCtx.fillStyle = '#273E74';
            fibSequenceCtx.font = 'bold 16px Arial';
            fibSequenceCtx.textAlign = 'center';
            fibSequenceCtx.fillText('Sequência de Fibonacci', fibSequenceCanvas.width / 2, 20);
        }

        async function startFibSequence() {
            if (fibAnimating) return;
            fibAnimating = true;
            fibShouldStop = false;
            document.getElementById('fibSeqStart').disabled = true;
            document.getElementById('fibCount').disabled = true;

            fibSequence = [0, 1];
            const count = parseInt(document.getElementById('fibCount').value);
            
            drawFibSequence(0);
            await sleep(parseInt(document.getElementById('fibSpeed').value));

            for (let i = 2; i < count; i++) {
                if (fibShouldStop) break;

                const next = fibSequence[i - 1] + fibSequence[i - 2];
                fibSequence.push(next);

                document.getElementById('fibLast').textContent = next.toLocaleString();
                document.getElementById('fibIterations').textContent = i + 1;
                
                // Calcula razão áurea
                if (fibSequence[i - 1] !== 0) {
                    const ratio = next / fibSequence[i - 1];
                    document.getElementById('fibRatio').textContent = ratio.toFixed(6);
                }

                drawFibSequence(i);
                await sleep(parseInt(document.getElementById('fibSpeed').value));
            }

            drawFibSequence(-1);
            fibAnimating = false;
            document.getElementById('fibSeqStart').disabled = false;
            document.getElementById('fibCount').disabled = false;
        }

        function resetFibonacci() {
            fibShouldStop = true;
            fibAnimating = false;
            fibSequence = [];
            
            fibSequenceCtx.clearRect(0, 0, fibSequenceCanvas.width, fibSequenceCanvas.height);
            
            document.getElementById('fibLast').textContent = '-';
            document.getElementById('fibRatio').textContent = '-';
            document.getElementById('fibIterations').textContent = '0';
            
            document.getElementById('fibSeqStart').disabled = false;
            document.getElementById('fibCount').disabled = false;
        }

        document.getElementById('fibSpeed').addEventListener('input', (e) => {
            document.getElementById('fibSpeedValue').textContent = e.target.value + 'ms';
        });

        document.getElementById('fibCount').addEventListener('input', (e) => {
            document.getElementById('fibCountValue').textContent = e.target.value;
        });

        // ========== PERLIN NOISE ==========
        const perlinCanvas = document.getElementById('perlinCanvas');
        const perlinCtx = perlinCanvas.getContext('2d');
        let perlinAnimating = false;
        let perlinAnimationId = null;
        let perlinTimeOffset = 0;

        // Gerador de Perlin Noise
        class PerlinNoise {
            constructor(seed = Math.random()) {
                this.gradients = {};
                this.memory = {};
                this.seed = seed;
            }

            rand_vect() {
                let theta = Math.random() * 2 * Math.PI;
                return { x: Math.cos(theta), y: Math.sin(theta) };
            }

            dot_prod_grid(x, y, vx, vy) {
                let g_vect;
                let d_vect = { x: x - vx, y: y - vy };
                let grid_key = `${vx},${vy}`;

                if (this.gradients[grid_key]) {
                    g_vect = this.gradients[grid_key];
                } else {
                    g_vect = this.rand_vect();
                    this.gradients[grid_key] = g_vect;
                }

                return d_vect.x * g_vect.x + d_vect.y * g_vect.y;
            }

            smootherstep(x) {
                return 6 * x ** 5 - 15 * x ** 4 + 10 * x ** 3;
            }

            interp(x, a, b) {
                return a + this.smootherstep(x) * (b - a);
            }

            get(x, y) {
                let xf = Math.floor(x);
                let yf = Math.floor(y);

                let tl = this.dot_prod_grid(x, y, xf, yf);
                let tr = this.dot_prod_grid(x, y, xf + 1, yf);
                let bl = this.dot_prod_grid(x, y, xf, yf + 1);
                let br = this.dot_prod_grid(x, y, xf + 1, yf + 1);

                let xt = this.interp(x - xf, tl, tr);
                let xb = this.interp(x - xf, bl, br);
                let v = this.interp(y - yf, xt, xb);

                return v;
            }
        }

        function getPerlinColor(value, mode) {
            // Normaliza valor de -1,1 para 0,1
            value = (value + 1) / 2;
            value = Math.max(0, Math.min(1, value));

            let r, g, b;

            switch (mode) {
                case 'grayscale':
                    const gray = Math.floor(value * 255);
                    return [gray, gray, gray];

                case 'terrain':
                    // Água -> Areia -> Grama -> Montanha -> Neve
                    if (value < 0.3) {
                        const t = value / 0.3;
                        r = Math.floor(20 + t * 30);
                        g = Math.floor(50 + t * 100);
                        b = Math.floor(150 + t * 105);
                    } else if (value < 0.35) {
                        r = 238;
                        g = 214;
                        b = 175;
                    } else if (value < 0.6) {
                        const t = (value - 0.35) / 0.25;
                        r = Math.floor(34 + t * 50);
                        g = Math.floor(139 + t * 60);
                        b = Math.floor(34 + t * 30);
                    } else if (value < 0.8) {
                        const t = (value - 0.6) / 0.2;
                        r = Math.floor(139 - t * 20);
                        g = Math.floor(90 - t * 20);
                        b = Math.floor(43 - t * 20);
                    } else {
                        const t = (value - 0.8) / 0.2;
                        r = Math.floor(200 + t * 55);
                        g = Math.floor(200 + t * 55);
                        b = Math.floor(200 + t * 55);
                    }
                    return [r, g, b];

                case 'clouds':
                    r = Math.floor(135 + value * 120);
                    g = Math.floor(206 + value * 49);
                    b = 235;
                    return [r, g, b];

                case 'fire':
                    if (value < 0.33) {
                        const t = value / 0.33;
                        r = Math.floor(t * 255);
                        g = 0;
                        b = 0;
                    } else if (value < 0.66) {
                        const t = (value - 0.33) / 0.33;
                        r = 255;
                        g = Math.floor(t * 165);
                        b = 0;
                    } else {
                        const t = (value - 0.66) / 0.34;
                        r = 255;
                        g = Math.floor(165 + t * 90);
                        b = Math.floor(t * 100);
                    }
                    return [r, g, b];

                case 'water':
                    r = Math.floor(0 + value * 100);
                    g = Math.floor(50 + value * 150);
                    b = Math.floor(150 + value * 105);
                    return [r, g, b];

                case 'wood':
                    const woodBase = Math.sin(value * 20) * 0.3 + 0.7;
                    r = Math.floor(139 * woodBase);
                    g = Math.floor(90 * woodBase);
                    b = Math.floor(43 * woodBase);
                    return [r, g, b];

                default:
                    return [128, 128, 128];
            }
        }

        async function generatePerlinNoise() {
            if (perlinAnimating) return;

            const btnStart = document.getElementById('perlinStart');
            const btnAnimate = document.getElementById('perlinAnimate');
            const selectPerlinMode = document.getElementById('perlinMode');
            const perlinScale = document.getElementById('perlinScale');
            const perlinOctaves = document.getElementById('perlinOctaves');
            const perlinPersistence = document.getElementById('perlinPersistence');
            const perlinStop = document.getElementById('perlinStop');
            const resetPerlin = document.getElementById('resetPerlin');
            
            if (btnStart) btnStart.disabled = true;
            if (btnAnimate) btnAnimate.disabled = true;
            if (selectPerlinMode) selectPerlinMode.disabled = true;
            if (perlinScale) perlinScale.disabled = true;
            if (perlinOctaves) perlinOctaves.disabled = true;
            if (perlinPersistence) perlinPersistence.disabled = true;
            if (resetPerlin) resetPerlin.disabled = true;
            if (perlinStop) perlinStop.disabled = true;

            const startTime = performance.now();
            const width = perlinCanvas.width;
            const height = perlinCanvas.height;
            const imageData = perlinCtx.createImageData(width, height);
            const data = imageData.data;

            const scale = parseInt(document.getElementById('perlinScale').value);
            const octaves = parseInt(document.getElementById('perlinOctaves').value);
            const persistence = parseFloat(document.getElementById('perlinPersistence').value);
            const mode = document.getElementById('perlinMode').value;

            const noise = new PerlinNoise();
            let pixelCount = 0;
            const totalPixels = width * height;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let value = 0;
                    let amplitude = 1;
                    let frequency = 1;
                    let maxValue = 0;

                    for (let o = 0; o < octaves; o++) {
                        const sampleX = (x / scale) * frequency;
                        const sampleY = (y / scale) * frequency;
                        value += noise.get(sampleX, sampleY) * amplitude;
                        maxValue += amplitude;
                        amplitude *= persistence;
                        frequency *= 2;
                    }

                    value = value / maxValue;

                    const color = getPerlinColor(value, mode);
                    const index = (y * width + x) * 4;
                    data[index] = color[0];
                    data[index + 1] = color[1];
                    data[index + 2] = color[2];
                    data[index + 3] = 255;

                    pixelCount++;
                }

                if (y % 10 === 0) {
                    perlinCtx.putImageData(imageData, 0, 0);
                    const elPixels = document.getElementById('perlinPixels');
                    const elProgress = document.getElementById('perlinProgress');
                    if (elPixels) elPixels.textContent = pixelCount.toLocaleString();
                    if (elProgress) elProgress.textContent = Math.floor((pixelCount / totalPixels) * 100) + '%';
                    await sleep(1);
                }
            }

            perlinCtx.putImageData(imageData, 0, 0);
            const endTime = performance.now();
            
            const elTime = document.getElementById('perlinTime');
            const elPixels = document.getElementById('perlinPixels');
            const elProgress = document.getElementById('perlinProgress');
            
            if (elTime) elTime.textContent = ((endTime - startTime) / 1000).toFixed(2) + 's';
            if (elPixels) elPixels.textContent = totalPixels.toLocaleString();
            if (elProgress) elProgress.textContent = '100%';

            if (btnStart) btnStart.disabled = false;
            if (btnAnimate) btnAnimate.disabled = false;
            if (selectPerlinMode) selectPerlinMode.disabled = false;
            if (resetPerlin) resetPerlin.disabled = false;
            if (perlinScale) perlinScale.disabled = false;
            if (perlinOctaves) perlinOctaves.disabled = false;
            if (perlinPersistence) perlinPersistence.disabled = false;
            if (perlinStop) perlinStop.disabled = false;
        }

        // Versão otimizada para animação - usa resolução reduzida
        function animatePerlinFrame() {
            if (!perlinAnimating) return;

            const startTime = performance.now();
            
            // Usa resolução menor para animação suave
            const renderWidth = 150;  // Reduzido de 600 para 150
            const renderHeight = 150; // Reduzido de 600 para 150
            
            const scale = parseInt(document.getElementById('perlinScale').value);
            const octaves = parseInt(document.getElementById('perlinOctaves').value);
            const persistence = parseFloat(document.getElementById('perlinPersistence').value);
            const mode = document.getElementById('perlinMode').value;

            const noise = new PerlinNoise();
            
            // Cria um canvas temporário menor
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = renderWidth;
            tempCanvas.height = renderHeight;
            const tempCtx = tempCanvas.getContext('2d');
            const imageData = tempCtx.createImageData(renderWidth, renderHeight);
            const data = imageData.data;

            // Renderiza em resolução menor
            for (let y = 0; y < renderHeight; y++) {
                for (let x = 0; x < renderWidth; x++) {
                    let value = 0;
                    let amplitude = 1;
                    let frequency = 1;
                    let maxValue = 0;

                    for (let o = 0; o < octaves; o++) {
                        const sampleX = (x / scale) * frequency + perlinTimeOffset;
                        const sampleY = (y / scale) * frequency;
                        value += noise.get(sampleX, sampleY) * amplitude;
                        maxValue += amplitude;
                        amplitude *= persistence;
                        frequency *= 2;
                    }

                    value = value / maxValue;

                    const color = getPerlinColor(value, mode);
                    const index = (y * renderWidth + x) * 4;
                    data[index] = color[0];
                    data[index + 1] = color[1];
                    data[index + 2] = color[2];
                    data[index + 3] = 255;
                }
            }

            tempCtx.putImageData(imageData, 0, 0);
            
            // Escala para o canvas principal (smooth scaling)
            perlinCtx.clearRect(0, 0, perlinCanvas.width, perlinCanvas.height);
            perlinCtx.imageSmoothingEnabled = true;
            perlinCtx.imageSmoothingQuality = 'high';
            perlinCtx.drawImage(tempCanvas, 0, 0, perlinCanvas.width, perlinCanvas.height);
            
            perlinTimeOffset += 0.05;

            const endTime = performance.now();
            const elTime = document.getElementById('perlinTime');
            if (elTime) elTime.textContent = ((endTime - startTime) / 1000).toFixed(3) + 's';

            perlinAnimationId = requestAnimationFrame(animatePerlinFrame);
        }

        function animatePerlinNoise() {
            if (perlinAnimating) return;
            perlinAnimating = true;
            perlinTimeOffset = 0;
            
            const btnStart = document.getElementById('perlinStart');
            const btnAnimate = document.getElementById('perlinAnimate');
            const selectPerlinMode = document.getElementById('perlinMode');
            const perlinScale = document.getElementById('perlinScale');
            const perlinOctaves = document.getElementById('perlinOctaves');
            const perlinPersistence = document.getElementById('perlinPersistence');
            const resetPerlin = document.getElementById('resetPerlin');
            
            if (btnStart) btnStart.disabled = true;
            if (btnAnimate) btnAnimate.disabled = true;
            if (selectPerlinMode) selectPerlinMode.disabled = true;
            if (resetPerlin) resetPerlin.disabled = true;
            if (perlinScale) perlinScale.disabled = true;
            if (perlinOctaves) perlinOctaves.disabled = true;
            if (perlinPersistence) perlinPersistence.disabled = true;
            
            animatePerlinFrame();
        }

        function stopPerlinAnimation() {
            perlinAnimating = false;
            if (perlinAnimationId) {
                cancelAnimationFrame(perlinAnimationId);
                perlinAnimationId = null;
            }
            
            const btnStart = document.getElementById('perlinStart');
            const btnAnimate = document.getElementById('perlinAnimate');
            const selectPerlinMode = document.getElementById('perlinMode');
            const perlinScale = document.getElementById('perlinScale');
            const perlinOctaves = document.getElementById('perlinOctaves');
            const perlinPersistence = document.getElementById('perlinPersistence');
            const resetPerlin = document.getElementById('resetPerlin');
            
            if (btnStart) btnStart.disabled = false;
            if (btnAnimate) btnAnimate.disabled = false;
            if (selectPerlinMode) selectPerlinMode.disabled = false;
            if (resetPerlin) resetPerlin.disabled = false;
            if (perlinScale) perlinScale.disabled = false;
            if (perlinOctaves) perlinOctaves.disabled = false;
            if (perlinPersistence) perlinPersistence.disabled = false;
        }

        function resetPerlin() {
            stopPerlinAnimation();
            perlinCtx.clearRect(0, 0, perlinCanvas.width, perlinCanvas.height);
            perlinTimeOffset = 0;
            
            const elPixels = document.getElementById('perlinPixels');
            const elProgress = document.getElementById('perlinProgress');
            const elTime = document.getElementById('perlinTime');
            
            if (elPixels) elPixels.textContent = '0';
            if (elProgress) elProgress.textContent = '0%';
            if (elTime) elTime.textContent = '0.00';
        }

        document.getElementById('perlinScale').addEventListener('input', (e) => {
            document.getElementById('perlinScaleValue').textContent = e.target.value;
        });

        document.getElementById('perlinOctaves').addEventListener('input', (e) => {
            document.getElementById('perlinOctavesValue').textContent = e.target.value;
        });

        document.getElementById('perlinPersistence').addEventListener('input', (e) => {
            document.getElementById('perlinPersistenceValue').textContent = e.target.value;
        });

        // ========== FOURIER TRANSFORM ==========
        const fourierTimeCanvas = document.getElementById('fourierTimeCanvas');
        const fourierTimeCtx = fourierTimeCanvas.getContext('2d');
        const fourierFreqCanvas = document.getElementById('fourierFreqCanvas');
        const fourierFreqCtx = fourierFreqCanvas.getContext('2d');

        let fourierWaves = [];
        let fourierAnimating = false;
        let fourierAnimationId = null;
        let fourierTime = 0;

        class FourierWave {
            constructor(frequency, amplitude, phase = 0) {
                this.frequency = frequency;
                this.amplitude = amplitude;
                this.phase = phase;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
            }

            getValue(t) {
                return this.amplitude * Math.sin(2 * Math.PI * this.frequency * t + this.phase);
            }
        }

        function drawFourierTime(time = 0) {
            const width = fourierTimeCanvas.width;
            const height = fourierTimeCanvas.height;
            
            fourierTimeCtx.clearRect(0, 0, width, height);
            
            // Grid
            fourierTimeCtx.strokeStyle = '#e0e0e0';
            fourierTimeCtx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (height / 10) * i;
                fourierTimeCtx.beginPath();
                fourierTimeCtx.moveTo(0, y);
                fourierTimeCtx.lineTo(width, y);
                fourierTimeCtx.stroke();
            }
            
            // Eixo central
            fourierTimeCtx.strokeStyle = '#999';
            fourierTimeCtx.lineWidth = 2;
            fourierTimeCtx.beginPath();
            fourierTimeCtx.moveTo(0, height / 2);
            fourierTimeCtx.lineTo(width, height / 2);
            fourierTimeCtx.stroke();
            
            if (fourierWaves.length === 0) {
                fourierTimeCtx.fillStyle = '#666';
                fourierTimeCtx.font = '16px Arial';
                fourierTimeCtx.textAlign = 'center';
                fourierTimeCtx.fillText('Adicione ondas para visualizar', width / 2, height / 2 - 20);
                return;
            }
            
            // Desenha ondas individuais (transparentes)
            fourierWaves.forEach(wave => {
                fourierTimeCtx.strokeStyle = wave.color;
                fourierTimeCtx.globalAlpha = 0.3;
                fourierTimeCtx.lineWidth = 1;
                fourierTimeCtx.beginPath();
                
                for (let x = 0; x < width; x++) {
                    const t = (x / width) * 2 + time;
                    const y = height / 2 - wave.getValue(t) * (height / 3);
                    
                    if (x === 0) {
                        fourierTimeCtx.moveTo(x, y);
                    } else {
                        fourierTimeCtx.lineTo(x, y);
                    }
                }
                fourierTimeCtx.stroke();
            });
            
            fourierTimeCtx.globalAlpha = 1;
            
            // Desenha onda composta (soma de todas)
            fourierTimeCtx.strokeStyle = '#5c6d82';
            fourierTimeCtx.lineWidth = 3;
            fourierTimeCtx.beginPath();
            
            for (let x = 0; x < width; x++) {
                const t = (x / width) * 2 + time;
                let y = 0;
                
                fourierWaves.forEach(wave => {
                    y += wave.getValue(t);
                });
                
                y = height / 2 - y * (height / 3);
                
                if (x === 0) {
                    fourierTimeCtx.moveTo(x, y);
                } else {
                    fourierTimeCtx.lineTo(x, y);
                }
            }
            fourierTimeCtx.stroke();
            
            // Labels
            fourierTimeCtx.fillStyle = '#273E74';
            fourierTimeCtx.font = 'bold 12px Arial';
            fourierTimeCtx.textAlign = 'left';
            fourierTimeCtx.fillText('Amplitude', 10, 20);
            fourierTimeCtx.textAlign = 'right';
            fourierTimeCtx.fillText('Tempo →', width - 10, height - 10);
        }

        function drawFourierFrequency() {
            const width = fourierFreqCanvas.width;
            const height = fourierFreqCanvas.height;
            
            fourierFreqCtx.clearRect(0, 0, width, height);
            
            // Grid
            fourierFreqCtx.strokeStyle = '#e0e0e0';
            fourierFreqCtx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (height / 10) * i;
                fourierFreqCtx.beginPath();
                fourierFreqCtx.moveTo(0, y);
                fourierFreqCtx.lineTo(width, y);
                fourierFreqCtx.stroke();
            }
            
            if (fourierWaves.length === 0) {
                fourierFreqCtx.fillStyle = '#666';
                fourierFreqCtx.font = '16px Arial';
                fourierFreqCtx.textAlign = 'center';
                fourierFreqCtx.fillText('Espectro de Frequência', width / 2, height / 2 - 20);
                return;
            }
            
            // Ordena ondas por frequência
            const sortedWaves = [...fourierWaves].sort((a, b) => a.frequency - b.frequency);
            const maxFreq = Math.max(...fourierWaves.map(w => w.frequency));
            const maxAmp = Math.max(...fourierWaves.map(w => w.amplitude));
            
            // Desenha barras de frequência
            const barWidth = width / (sortedWaves.length + 1);
            
            sortedWaves.forEach((wave, index) => {
                const x = (index + 0.5) * barWidth;
                const barHeight = (wave.amplitude / maxAmp) * (height - 60);
                const y = height - 40 - barHeight;
                
                // Barra
                fourierFreqCtx.fillStyle = wave.color;
                fourierFreqCtx.fillRect(x - barWidth * 0.4, y, barWidth * 0.8, barHeight);
                
                // Borda
                fourierFreqCtx.strokeStyle = '#273E74';
                fourierFreqCtx.lineWidth = 2;
                fourierFreqCtx.strokeRect(x - barWidth * 0.4, y, barWidth * 0.8, barHeight);
                
                // Frequência (label)
                fourierFreqCtx.fillStyle = '#273E74';
                fourierFreqCtx.font = 'bold 11px Arial';
                fourierFreqCtx.textAlign = 'center';
                fourierFreqCtx.fillText(`${wave.frequency}Hz`, x, height - 25);
                
                // Amplitude (label)
                fourierFreqCtx.font = '10px Arial';
                fourierFreqCtx.fillText(`A:${wave.amplitude.toFixed(1)}`, x, height - 10);
            });
            
            // Labels
            fourierFreqCtx.fillStyle = '#273E74';
            fourierFreqCtx.font = 'bold 12px Arial';
            fourierFreqCtx.textAlign = 'left';
            fourierFreqCtx.fillText('Amplitude', 10, 20);
            fourierFreqCtx.textAlign = 'right';
            fourierFreqCtx.fillText('Frequência →', width - 10, height - 45);
        }

        function updateFourierWavesList() {
            const list = document.getElementById('fourierWavesList');
            list.innerHTML = '';
            
            if (fourierWaves.length === 0) {
                list.innerHTML = '<p style="color: #666; text-align: center;">Nenhuma onda adicionada</p>';
                return;
            }
            
            fourierWaves.forEach((wave, index) => {
                const waveDiv = document.createElement('div');
                waveDiv.style.cssText = 'display: flex; align-items: center; gap: 15px; padding: 10px; background: white; border: 2px solid #273E74; border-radius: 5px;';
                
                waveDiv.innerHTML = `
                    <div style="width: 30px; height: 30px; background: ${wave.color}; border: 2px solid #273E74; border-radius: 5px;"></div>
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Frequência: <span id="freq-${index}">${wave.frequency}</span> Hz</label>
                        <input type="range" id="freq-slider-${index}" min="0.5" max="10" step="0.5" value="${wave.frequency}" 
                            style="width: 100%;" onchange="updateWaveFrequency(${index}, this.value)">
                    </div>
                    <div style="flex: 1;">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">Amplitude: <span id="amp-${index}">${wave.amplitude.toFixed(1)}</span></label>
                        <input type="range" id="amp-slider-${index}" min="0.1" max="2" step="0.1" value="${wave.amplitude}" 
                            style="width: 100%;" onchange="updateWaveAmplitude(${index}, this.value)">
                    </div>
                    <button onclick="removeSpecificWave(${index})" style="padding: 5px 10px; background: #f44336; color: white; border: none; cursor: pointer; border-radius: 3px;">✕</button>
                `;
                
                list.appendChild(waveDiv);
            });
        }

        function updateWaveFrequency(index, value) {
            fourierWaves[index].frequency = parseFloat(value);
            document.getElementById(`freq-${index}`).textContent = value;
            updateFourierStats();
            drawFourierTime(fourierTime);
            drawFourierFrequency();
        }

        function updateWaveAmplitude(index, value) {
            fourierWaves[index].amplitude = parseFloat(value);
            document.getElementById(`amp-${index}`).textContent = parseFloat(value).toFixed(1);
            updateFourierStats();
            drawFourierTime(fourierTime);
            drawFourierFrequency();
        }

        function removeSpecificWave(index) {
            fourierWaves.splice(index, 1);
            updateFourierWavesList();
            updateFourierStats();
            drawFourierTime(fourierTime);
            drawFourierFrequency();
        }

        function addFourierWave() {
            const frequency = 1 + fourierWaves.length * 0.5;
            const amplitude = 0.5 + Math.random() * 0.5;
            const phase = Math.random() * Math.PI * 2;

            if (fourierWaves.length > 10) return;
            
            fourierWaves.push(new FourierWave(frequency, amplitude, phase));
            updateFourierWavesList();
            updateFourierStats();
            drawFourierTime(fourierTime);
            drawFourierFrequency();
        }

        function removeFourierWave() {
            if (fourierWaves.length > 0) {
                fourierWaves.pop();
                updateFourierWavesList();
                updateFourierStats();
                drawFourierTime(fourierTime);
                drawFourierFrequency();
            }
        }

        function loadFourierPreset() {
            const preset = document.getElementById('fourierPreset').value;
            fourierWaves = [];
            
            switch(preset) {
                case 'sine':
                    fourierWaves.push(new FourierWave(2, 1, 0));
                    break;
                    
                case 'square':
                    // Série de Fourier para onda quadrada
                    for (let n = 1; n <= 5; n += 2) {
                        fourierWaves.push(new FourierWave(n, 4 / (Math.PI * n), 0));
                    }
                    break;
                    
                case 'sawtooth':
                    // Série de Fourier para dente de serra
                    for (let n = 1; n <= 5; n++) {
                        fourierWaves.push(new FourierWave(n, 1 / n, Math.PI));
                    }
                    break;
                    
                case 'triangle':
                    // Série de Fourier para onda triangular
                    for (let n = 1; n <= 5; n += 2) {
                        const sign = ((n - 1) / 2) % 2 === 0 ? 1 : -1;
                        fourierWaves.push(new FourierWave(n, sign * 8 / (Math.PI * Math.PI * n * n), 0));
                    }
                    break;
                    
                case 'complex':
                    fourierWaves.push(new FourierWave(1, 0.8, 0));
                    fourierWaves.push(new FourierWave(2.5, 0.5, Math.PI / 4));
                    fourierWaves.push(new FourierWave(4, 0.3, 0));
                    fourierWaves.push(new FourierWave(6, 0.2, Math.PI / 2));
                    break;
            }
            
            updateFourierWavesList();
            updateFourierStats();
            drawFourierTime(fourierTime);
            drawFourierFrequency();
        }

        function updateFourierStats() {
            document.getElementById('fourierWaveCount').textContent = fourierWaves.length;
            
            if (fourierWaves.length > 0) {
                const maxAmpWave = fourierWaves.reduce((max, wave) => 
                    wave.amplitude > max.amplitude ? wave : max
                );
                document.getElementById('fourierDominant').textContent = `${maxAmpWave.frequency} Hz`;
                
                const totalAmp = fourierWaves.reduce((sum, wave) => sum + wave.amplitude, 0);
                document.getElementById('fourierAmplitude').textContent = totalAmp.toFixed(2);
            } else {
                document.getElementById('fourierDominant').textContent = '-';
                document.getElementById('fourierAmplitude').textContent = '0.00';
            }
        }

        function animateFourierFrame() {
            if (!fourierAnimating) return;
            
            fourierTime += 0.01;
            drawFourierTime(fourierTime);
            
            fourierAnimationId = requestAnimationFrame(animateFourierFrame);
        }

        function animateFourier() {
            if (fourierAnimating) return;
            if (fourierWaves.length === 0) {
                alert('Adicione ondas primeiro!');
                return;
            }
            
            fourierAnimating = true;
            document.getElementById('fourierAnimate').disabled = true;
            animateFourierFrame();
        }

        function stopFourierAnimation() {
            fourierAnimating = false;
            if (fourierAnimationId) {
                cancelAnimationFrame(fourierAnimationId);
                fourierAnimationId = null;
            }
            document.getElementById('fourierAnimate').disabled = false;
        }

        function resetFourier() {
            stopFourierAnimation();
            fourierWaves = [];
            fourierTime = 0;
            document.getElementById('fourierPreset').value = 'custom';
            updateFourierWavesList();
            updateFourierStats();
            drawFourierTime(0);
            drawFourierFrequency();
        }

        // Inicializa
        drawFourierTime(0);
        drawFourierFrequency();
        updateFourierStats();

        // ========== CIRCLE PACKING ==========
        const circlePackCanvas = document.getElementById('circlePackCanvas');
        const circlePackCtx = circlePackCanvas.getContext('2d');

        let circlePackCircles = [];
        let circlePackAnimating = false;
        let circlePackAnimationId = null;

        class PackCircle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 2; // Começa com raio mínimo de 2
                this.growing = true;
                this.maxRadius = 0;
                this.hue = Math.random() * 360;
            }

            grow(growthRate) {
                if (this.growing) {
                    this.radius += growthRate;
                }
            }

            getDistanceTo(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            checkCollision(other) {
                const distance = this.getDistanceTo(other);
                return distance <= this.radius + other.radius;
            }

            checkEdges(width, height) {
                return (
                    this.x - this.radius <= 0 ||
                    this.x + this.radius >= width ||
                    this.y - this.radius <= 0 ||
                    this.y + this.radius >= height
                );
            }

            // Calcula o raio máximo antes de tocar em outro círculo
            getMaxRadiusBeforeCollision(other) {
                const distance = this.getDistanceTo(other);
                return Math.max(2, distance - other.radius); // Nunca menor que 2
            }

            // Calcula o raio máximo antes de tocar nas bordas
            getMaxRadiusBeforeEdge(width, height) {
                const distToLeft = this.x;
                const distToRight = width - this.x;
                const distToTop = this.y;
                const distToBottom = height - this.y;
                
                return Math.max(2, Math.min(distToLeft, distToRight, distToTop, distToBottom)); // Nunca menor que 2
            }

            draw(ctx, style, showBorders) {
                // Proteção: garante que o raio seja sempre positivo e maior que 1
                if (this.radius < 1) {
                    this.radius = 1;
                    return;
                }

                const styleType = style || 'colorful';
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                switch(styleType) {
                    case 'colorful':
                        ctx.fillStyle = `hsl(${this.hue}, 70%, 60%)`;
                        ctx.fill();
                        if (showBorders) {
                            ctx.strokeStyle = `hsl(${this.hue}, 70%, 40%)`;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                        break;

                    case 'gradient':
                        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                        gradient.addColorStop(0, `hsl(${this.hue}, 70%, 80%)`);
                        gradient.addColorStop(0.7, `hsl(${this.hue}, 70%, 60%)`);
                        gradient.addColorStop(1, `hsl(${this.hue}, 70%, 40%)`);
                        ctx.fillStyle = gradient;
                        ctx.fill();
                        if (showBorders) {
                            ctx.strokeStyle = `hsl(${this.hue}, 70%, 30%)`;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                        break;

                    case 'monochrome':
                        const gray = Math.floor(100 + (this.radius / 100) * 155);
                        ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                        ctx.fill();
                        if (showBorders) {
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                        break;

                    case 'outline':
                        ctx.strokeStyle = `hsl(${this.hue}, 70%, 50%)`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        break;

                    case 'size':
                        const sizeFactor = this.radius / 100;
                        ctx.fillStyle = `hsl(${200 + sizeFactor * 160}, 70%, 60%)`;
                        ctx.fill();
                        if (showBorders) {
                            ctx.strokeStyle = `hsl(${200 + sizeFactor * 160}, 70%, 40%)`;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                        break;
                }

                // Mostra raio se o círculo parou de crescer
                if (!this.growing && this.radius > 20) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(Math.floor(this.radius), this.x, this.y);
                }
            }
        }

        function getCirclePackPosition(mode, index, total, width, height, randomFactorSpiral) {
            switch(mode) {
                case 'random':
                    return {
                        x: 10 + Math.random() * (width - 20),
                        y: 10 + Math.random() * (height - 20)
                    };

                case 'grid':
                    const cols = Math.ceil(Math.sqrt(total));
                    const row = Math.floor(index / cols);
                    const col = index % cols;
                    const cellWidth = width / cols;
                    const cellHeight = height / cols;
                    return {
                        x: col * cellWidth + cellWidth / 2 + (Math.random() - 0.5) * cellWidth * 0.4,
                        y: row * cellHeight + cellHeight / 2 + (Math.random() - 0.5) * cellHeight * 0.4
                    };

                case 'spiral':
                    const angle = index * randomFactorSpiral;
                    const radius = (index / total) * Math.min(width, height) * randomFactorSpiral;
                    return {
                        x: width / 2 + Math.cos(angle) * radius,
                        y: height / 2 + Math.sin(angle) * radius
                    };

                case 'center':
                    const distance = (index / total) * Math.min(width, height) * 0.48;
                    const randomAngle = Math.random() * Math.PI * 2;
                    return {
                        x: width / 2 + Math.cos(randomAngle) * distance,
                        y: height / 2 + Math.sin(randomAngle) * distance
                    };

                default:
                    return {
                        x: 10 + Math.random() * (width - 20),
                        y: 10 + Math.random() * (height - 20)
                    };
            }
        }

        function createCirclePackCircles() {
            const count = parseInt(document.getElementById('circlePackCount').value);
            const mode = document.getElementById('circlePackMode').value;
            const width = circlePackCanvas.width;
            const height = circlePackCanvas.height;

            circlePackCircles = [];

            const randomFactorSpiral = Math.random() < 0.5 ? 0.45 : 0.5;

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let validPosition = false;
                let newCircle;

                while (!validPosition && attempts < 150) {
                    const pos = getCirclePackPosition(mode, i, count, width, height, randomFactorSpiral);
                    newCircle = new PackCircle(pos.x, pos.y);

                    // Garante que o círculo está dentro dos limites
                    if (newCircle.x < 5 || newCircle.x > width - 5 || 
                        newCircle.y < 5 || newCircle.y > height - 5) {
                        attempts++;
                        continue;
                    }

                    // Verifica se está longe o suficiente de outros círculos
                    validPosition = true;
                    for (let other of circlePackCircles) {
                        const dx = newCircle.x - other.x;
                        const dy = newCircle.y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < 4) { // Distância mínima reduzida para 4
                            validPosition = false;
                            break;
                        }
                    }

                    attempts++;
                }

                if (validPosition && newCircle) {
                    circlePackCircles.push(newCircle);
                }
            }

            updateCirclePackStats();
        }

        function drawCirclePacking() {
            const width = circlePackCanvas.width;
            const height = circlePackCanvas.height;

            circlePackCtx.clearRect(0, 0, width, height);

            // Fundo
            circlePackCtx.fillStyle = '#f5f5f5';
            circlePackCtx.fillRect(0, 0, width, height);

            const style = document.getElementById('circlePackStyle').value;
            const showBorders = document.getElementById('circlePackBorders').checked;

            // Desenha todos os círculos
            circlePackCircles.forEach(circle => {
                circle.draw(circlePackCtx, style, showBorders);
            });
        }

        function redrawCirclePacking() {
            drawCirclePacking();
        }

        function animateCirclePacking() {
            if (!circlePackAnimating) return;

            const growthRate = parseFloat(document.getElementById('circlePackSpeed').value);
            const width = circlePackCanvas.width;
            const height = circlePackCanvas.height;

            let allStopped = true;

            circlePackCircles.forEach(circle => {
                if (circle.growing) {
                    allStopped = false;

                    // Calcula o raio máximo possível sem colidir
                    let maxPossibleRadius = Infinity;

                    // Verifica distância até as bordas (com margem mínima de 2px)
                    const distToLeft = circle.x - 2;
                    const distToRight = width - circle.x - 2;
                    const distToTop = circle.y - 2;
                    const distToBottom = height - circle.y - 2;
                    const maxRadiusEdge = Math.max(2, Math.min(distToLeft, distToRight, distToTop, distToBottom));
                    maxPossibleRadius = Math.min(maxPossibleRadius, maxRadiusEdge);

                    // Verifica distância até outros círculos
                    for (let other of circlePackCircles) {
                        if (circle !== other) {
                            const distance = circle.getDistanceTo(other);
                            const maxRadiusCircle = Math.max(2, distance - other.radius - 0.5); // Margem de 0.5px
                            maxPossibleRadius = Math.min(maxPossibleRadius, maxRadiusCircle);
                        }
                    }

                    // Garante que maxPossibleRadius seja pelo menos 2
                    maxPossibleRadius = Math.max(2, maxPossibleRadius);

                    // Se o crescimento faria o círculo ultrapassar o limite, para exatamente no limite
                    if (circle.radius + growthRate >= maxPossibleRadius) {
                        circle.radius = Math.max(2, maxPossibleRadius);
                        circle.growing = false;
                        circle.maxRadius = circle.radius;
                    } else {
                        // Pode crescer normalmente
                        circle.grow(growthRate);
                        circle.radius = Math.max(2, circle.radius);
                    }
                }
            });

            drawCirclePacking();
            updateCirclePackStats();

            if (allStopped) {
                stopCirclePacking();
            } else {
                circlePackAnimationId = requestAnimationFrame(animateCirclePacking);
            }
        }

        function startCirclePacking() {
            if (circlePackAnimating) return;

            if (circlePackCircles.length === 0) {
                createCirclePackCircles();
                drawCirclePacking();
            }

            circlePackAnimating = true;
            document.getElementById('circlePackStart').disabled = true;
            document.getElementById('circlePackCount').disabled = true;
            document.getElementById('circlePackMode').disabled = true;
            document.getElementById('circlePackStop').disabled = false;

            animateCirclePacking();
        }

        function stopCirclePacking() {
            circlePackAnimating = false;
            if (circlePackAnimationId) {
                cancelAnimationFrame(circlePackAnimationId);
                circlePackAnimationId = null;
            }

            document.getElementById('circlePackStart').disabled = false;
            document.getElementById('circlePackCount').disabled = false;
            document.getElementById('circlePackMode').disabled = false;
            document.getElementById('circlePackStop').disabled = true;
        }

        function resetCirclePacking() {
            stopCirclePacking();
            circlePackCircles = [];
            circlePackCtx.clearRect(0, 0, circlePackCanvas.width, circlePackCanvas.height);
            
            // Fundo
            circlePackCtx.fillStyle = '#f5f5f5';
            circlePackCtx.fillRect(0, 0, circlePackCanvas.width, circlePackCanvas.height);

            updateCirclePackStats();
        }

        function updateCirclePackStats() {
            const activeCount = circlePackCircles.filter(c => c.growing).length;
            const completeCount = circlePackCircles.filter(c => !c.growing).length;

            document.getElementById('circlePackActive').textContent = activeCount;
            document.getElementById('circlePackComplete').textContent = completeCount;

            // Calcula taxa de preenchimento
            const totalArea = circlePackCanvas.width * circlePackCanvas.height;
            const circlesArea = circlePackCircles.reduce((sum, c) => sum + Math.PI * c.radius * c.radius, 0);
            const fillRate = (circlesArea / totalArea) * 100;
            document.getElementById('circlePackFill').textContent = fillRate.toFixed(1) + '%';

            // Maior círculo
            const largestRadius = Math.max(...circlePackCircles.map(c => c.radius), 0);
            document.getElementById('circlePackLargest').textContent = Math.floor(largestRadius);
        }

        function exportCirclePackImage() {
            const link = document.createElement('a');
            link.download = 'circle-packing.png';
            link.href = circlePackCanvas.toDataURL();
            link.click();
        }

        document.getElementById('circlePackSpeed').addEventListener('input', (e) => {
            document.getElementById('circlePackSpeedValue').textContent = e.target.value;
        });

        document.getElementById('circlePackCount').addEventListener('input', (e) => {
            document.getElementById('circlePackCountValue').textContent = e.target.value;
        });

        // Inicializa com fundo
        circlePackCtx.fillStyle = '#f5f5f5';
        circlePackCtx.fillRect(0, 0, circlePackCanvas.width, circlePackCanvas.height);

        // ========== CHLADNI PATTERNS (VERSÃO COMPLETA) ==========
        const chladniCanvas = document.getElementById('chladniCanvas');
        const chladniCtx = chladniCanvas.getContext('2d');
        let chladniAnimating = false;
        let chladniAnimationId = null;

        // Múltiplas equações de Chladni para variedade
        function calculateChladniPattern(x, y, n, m, width, height, equation = 'classic') {
            // Normaliza coordenadas para [0, 2π]
            const nx = (x / width) * 2 * Math.PI;
            const ny = (y / height) * 2 * Math.PI;
            
            let value = 0;
            
            switch(equation) {
                case 'classic':
                    // Equação clássica: sin(n·x)·sin(m·y) + sin(m·x)·sin(n·y)
                    value = Math.sin(n * nx) * Math.sin(m * ny) + 
                            Math.sin(m * nx) * Math.sin(n * ny);
                    break;
                    
                case 'cosine':
                    // Variação com cossenos
                    value = Math.cos(n * nx) * Math.cos(m * ny) + 
                            Math.cos(m * nx) * Math.cos(n * ny);
                    break;
                    
                case 'mixed':
                    // Mistura seno e cosseno
                    value = Math.sin(n * nx) * Math.cos(m * ny) + 
                            Math.cos(m * nx) * Math.sin(n * ny);
                    break;
                    
                case 'square':
                    // Padrão quadrado/retangular
                    value = Math.sin(n * nx) * Math.sin(m * ny) * 
                            Math.cos(n * nx) * Math.cos(m * ny);
                    break;
                    
                case 'circular':
                    // Aproximação circular (usa coordenadas polares)
                    const cx = width / 2;
                    const cy = height / 2;
                    const r = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
                    const theta = Math.atan2(y - cy, x - cx);
                    const maxR = Math.min(width, height) / 2;
                    const nr = (r / maxR) * Math.PI;
                    
                    // Bessel-like pattern (aproximação)
                    value = Math.sin(n * nr) * Math.cos(m * theta) + 
                            Math.cos(n * nr) * Math.sin(m * theta);
                    break;
                    
                case 'diagonal':
                    // Ênfase em diagonais
                    value = Math.sin(n * nx + m * ny) * Math.sin(m * nx - n * ny);
                    break;
                    
                case 'complex':
                    // Padrão mais complexo (múltiplos harmônicos)
                    value = Math.sin(n * nx) * Math.sin(m * ny) + 
                            Math.sin(m * nx) * Math.sin(n * ny) +
                            0.5 * Math.sin((n + m) * nx) * Math.sin((n - m) * ny);
                    break;
                    
                case 'radial':
                    // Padrão radial
                    const rcx = width / 2;
                    const rcy = height / 2;
                    const rr = Math.sqrt((x - rcx) * (x - rcx) + (y - rcy) * (y - rcy));
                    const rtheta = Math.atan2(y - rcy, x - rcx);
                    
                    value = Math.sin(n * rr / 50) * Math.cos(m * rtheta);
                    break;
                    
                case 'spiral':
                    // Padrão espiral
                    const scx = width / 2;
                    const scy = height / 2;
                    const sr = Math.sqrt((x - scx) * (x - scx) + (y - scy) * (y - scy));
                    const stheta = Math.atan2(y - scy, x - scx);
                    
                    value = Math.sin(n * sr / 40 + m * stheta);
                    break;
                    
                case 'interference':
                    // Padrão de interferência
                    value = Math.sin(n * nx) * Math.sin(m * ny) * 
                            Math.sin((n + 1) * nx) * Math.sin((m + 1) * ny);
                    break;
                    
                case 'web':
                    // Padrão de teia
                    const wcx = width / 2;
                    const wcy = height / 2;
                    const wr = Math.sqrt((x - wcx) * (x - wcx) + (y - wcy) * (y - wcy));
                    const wtheta = Math.atan2(y - wcy, x - wcx);
                    
                    value = Math.sin(n * wr / 30) * Math.sin(m * wtheta) * 
                            Math.cos(n * wtheta);
                    break;
                    
                case 'flower':
                    // Padrão floral
                    const fcx = width / 2;
                    const fcy = height / 2;
                    const ftheta = Math.atan2(y - fcy, x - fcx);
                    const fr = Math.sqrt((x - fcx) * (x - fcx) + (y - fcy) * (y - fcy));
                    
                    value = Math.sin(m * ftheta) * Math.cos(n * fr / 50);
                    break;
            }
            
            return value;
        }

        function getChladniColor(value, threshold, colorScheme) {
            // Normaliza o valor para [0, 1]
            const normalized = (value + 2) / 4;
            const thresholdNorm = threshold / 100;
            
            if (colorScheme === 'bw') {
                // Preto e branco clássico com transição mais suave
                const diff = Math.abs(normalized - thresholdNorm);
                if (diff < 0.05) {
                    // Zona de transição suave
                    const gray = Math.floor((diff / 0.05) * 255);
                    return [gray, gray, gray];
                }
                return normalized < thresholdNorm ? [0, 0, 0] : [255, 255, 255];
            }
            
            // Para outros esquemas, cria gradiente baseado na intensidade
            const intensity = Math.abs(normalized - thresholdNorm) * 2;
            const smoothIntensity = Math.pow(intensity, 0.7); // Suaviza transições
            
            let r, g, b;
            
            switch (colorScheme) {
                case 'rainbow':
                    // CORREÇÃO: Retorna diretamente o resultado
                    const hue = smoothIntensity * 360;
                    const lightness = 40 + smoothIntensity * 30; // Varia entre 40% e 70%
                    return hslToRgbArray(hue, 100, lightness);
                    
                case 'gradient':
                    r = Math.floor(75 + smoothIntensity * 130);
                    g = Math.floor(0 + smoothIntensity * 100);
                    b = Math.floor(130 + smoothIntensity * 125);
                    break;
                    
                case 'fire':
                    if (smoothIntensity < 0.33) {
                        r = Math.floor(smoothIntensity * 765);
                        g = 0;
                        b = 0;
                    } else if (smoothIntensity < 0.66) {
                        r = 255;
                        g = Math.floor((smoothIntensity - 0.33) * 765);
                        b = 0;
                    } else {
                        r = 255;
                        g = 255;
                        b = Math.floor((smoothIntensity - 0.66) * 765);
                    }
                    break;
                    
                case 'ocean':
                    r = 0;
                    g = Math.floor(50 + smoothIntensity * 150);
                    b = Math.floor(100 + smoothIntensity * 155);
                    break;
                    
                case 'gold':
                    r = Math.floor(139 + smoothIntensity * 116);
                    g = Math.floor(69 + smoothIntensity * 186);
                    b = Math.floor(19 + smoothIntensity * 40);
                    break;
                    
                case 'copper':
                    r = Math.floor(184 + smoothIntensity * 71);
                    g = Math.floor(115 + smoothIntensity * 89);
                    b = Math.floor(51 + smoothIntensity * 76);
                    break;
                    
                case 'neon':
                    if (smoothIntensity < 0.5) {
                        r = Math.floor(smoothIntensity * 510);
                        g = 255;
                        b = Math.floor(255 - smoothIntensity * 255);
                    } else {
                        r = 255;
                        g = Math.floor(255 - (smoothIntensity - 0.5) * 510);
                        b = Math.floor((smoothIntensity - 0.5) * 510);
                    }
                    break;
                    
                default:
                    r = g = b = Math.floor(smoothIntensity * 255);
            }
            
            return [Math.min(255, r), Math.min(255, g), Math.min(255, b)];
        }

        function hslToRgbArray(h, s, l) {
            h = h / 360;
            s = s / 100;
            l = l / 100;
            
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function disableChladniControls(disabled) {
            const ids = [
                'chladniDraw',
                'chladniAnimate',
                'randomPatternChladni',
                'exportImageChladni',
                'resetChladniBtn',
                'chladniN',
                'chladniM',
                'chladniColors',
                'chladniEquation',
                'chladniResolution',
                'chladniThreshold'
            ];

            ids.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.disabled = disabled;
            });
        }

        async function drawChladni() {
            if (chladniAnimating) return;
            
            disableChladniControls(true);
            document.getElementById('chladniStatus').textContent = 'Desenhando...';
            
            const n = parseInt(document.getElementById('chladniN').value);
            const m = parseInt(document.getElementById('chladniM').value);
            const resolution = parseInt(document.getElementById('chladniResolution').value);
            const threshold = parseInt(document.getElementById('chladniThreshold').value);
            const colorScheme = document.getElementById('chladniColors').value;
            const equation = document.getElementById('chladniEquation').value;
            
            document.getElementById('chladniMode').textContent = `${n}, ${m}`;
            
            // Calcula frequência teórica
            const freq = Math.sqrt(n * n + m * m).toFixed(2);
            document.getElementById('chladniFreq').textContent = `${freq}f₀`;
            
            const width = chladniCanvas.width;
            const height = chladniCanvas.height;
            const imageData = chladniCtx.createImageData(width, height);
            const data = imageData.data;
            
            const stepX = width / resolution;
            const stepY = height / resolution;
            
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const x = Math.floor(px / stepX) * stepX;
                    const y = Math.floor(py / stepY) * stepY;
                    
                    const value = calculateChladniPattern(x, y, n, m, width, height, equation);
                    const color = getChladniColor(value, threshold, colorScheme);
                    
                    const index = (py * width + px) * 4;
                    data[index] = color[0];
                    data[index + 1] = color[1];
                    data[index + 2] = color[2];
                    data[index + 3] = 255;
                }
                
                if (py % 20 === 0) {
                    chladniCtx.putImageData(imageData, 0, 0);
                    document.getElementById('chladniStatus').textContent = 
                        `${Math.floor((py / height) * 100)}%`;
                    await sleep(1);
                }
            }
            
            chladniCtx.putImageData(imageData, 0, 0);
            document.getElementById('chladniStatus').textContent = 'Completo!';
            disableChladniControls(false);
        }

        let animationPhase = 0;
        async function animateChladni() {
            if (chladniAnimating) {
                chladniAnimating = false;
                if (chladniAnimationId) {
                    cancelAnimationFrame(chladniAnimationId);
                    chladniAnimationId = null;
                }
                document.getElementById('chladniAnimate').textContent = 'Animar';
                document.getElementById('chladniStatus').textContent = 'Parado';
                document.getElementById('chladniDraw').disabled = false;
                document.getElementById('chladniN').disabled = false;
                document.getElementById('chladniM').disabled = false;
                document.getElementById('chladniEquation').disabled = false;
                document.getElementById('chladniColors').disabled = false;
                document.getElementById('randomPatternChladni').disabled = false;
                return;
            }
            
            chladniAnimating = true;
            document.getElementById('chladniAnimate').textContent = 'Parar Animação';
            document.getElementById('chladniStatus').textContent = 'Animando...';
            document.getElementById('chladniDraw').disabled = true;
            document.getElementById('chladniN').disabled = true;
            document.getElementById('chladniM').disabled = true;
            document.getElementById('chladniEquation').disabled = true;
            document.getElementById('chladniColors').disabled = true;
            document.getElementById('randomPatternChladni').disabled = true;
            
            const n = parseInt(document.getElementById('chladniN').value);
            const m = parseInt(document.getElementById('chladniM').value);
            const resolution = parseInt(document.getElementById('chladniResolution').value);
            const threshold = parseInt(document.getElementById('chladniThreshold').value);
            const colorScheme = document.getElementById('chladniColors').value;
            const equation = document.getElementById('chladniEquation').value;
            
            const width = chladniCanvas.width;
            const height = chladniCanvas.height;
            
            const animate = () => {
                if (!chladniAnimating) return;
                
                const imageData = chladniCtx.createImageData(width, height);
                const data = imageData.data;
                
                const stepX = width / resolution;
                const stepY = height / resolution;
                
                const dynamicThreshold = threshold + Math.sin(animationPhase * 0.5) * 15;
                
                for (let py = 0; py < height; py++) {
                    for (let px = 0; px < width; px++) {
                        const x = Math.floor(px / stepX) * stepX;
                        const y = Math.floor(py / stepY) * stepY;
                        
                        const value = calculateChladniPattern(x, y, n, m, width, height, equation) * 
                                      Math.cos(animationPhase * 0.3);
                        const color = getChladniColor(value, dynamicThreshold, colorScheme);
                        
                        const index = (py * width + px) * 4;
                        data[index] = color[0];
                        data[index + 1] = color[1];
                        data[index + 2] = color[2];
                        data[index + 3] = 255;
                    }
                }
                
                chladniCtx.putImageData(imageData, 0, 0);
                animationPhase += 0.08;
                
                chladniAnimationId = requestAnimationFrame(animate);
            };
            
            animate();
        }

        let randomCooldown = false;

        function randomChladniPattern() {
            if (randomCooldown) return;
            randomCooldown = true;

            setTimeout(() => randomCooldown = false, 400);

            const n = Math.floor(Math.random() * 11) + 1;
            const m = Math.floor(Math.random() * 11) + 1;
            
            const equations = ['classic', 'cosine', 'mixed', 'square', 'circular', 'diagonal', 
                               'complex', 'radial', 'spiral', 'interference', 'web', 'flower'];
            const randomEq = equations[Math.floor(Math.random() * equations.length)];
            
            document.getElementById('chladniN').value = n;
            document.getElementById('chladniM').value = m;
            document.getElementById('chladniEquation').value = randomEq;
            document.getElementById('chladniNValue').textContent = n;
            document.getElementById('chladniMValue').textContent = m;
            
            drawChladni();
        }

        function loadChladniPreset(preset) {
            const presets = {
                1: { n: 1, m: 1, eq: 'classic' },      // Modo fundamental
                2: { n: 3, m: 4, eq: 'classic' },      // Padrão clássico
                3: { n: 5, m: 7, eq: 'mixed' },        // Complexo
                4: { n: 2, m: 5, eq: 'square' },       // Quadrado
                5: { n: 8, m: 3, eq: 'diagonal' },     // Diagonal
                6: { n: 6, m: 6, eq: 'circular' },     // Circular
                7: { n: 4, m: 8, eq: 'radial' },       // Radial
                8: { n: 3, m: 6, eq: 'spiral' },       // Espiral
                9: { n: 5, m: 5, eq: 'flower' },       // Floral
                10: { n: 7, m: 4, eq: 'web' }          // Teia
            };
            
            const { n, m, eq } = presets[preset];
            document.getElementById('chladniN').value = n;
            document.getElementById('chladniM').value = m;
            document.getElementById('chladniEquation').value = eq;
            document.getElementById('chladniNValue').textContent = n;
            document.getElementById('chladniMValue').textContent = m;
            
            drawChladni();
        }

        function resetChladni() {
            if (chladniAnimating) {
                chladniAnimating = false;
                if (chladniAnimationId) {
                    cancelAnimationFrame(chladniAnimationId);
                    chladniAnimationId = null;
                }
                document.getElementById('chladniAnimate').textContent = 'Animar';
                document.getElementById('chladniN').disabled = false;
                document.getElementById('chladniM').disabled = false;
                document.getElementById('chladniEquation').disabled = false;
                document.getElementById('chladniColors').disabled = false;
                document.getElementById('randomPatternChladni').disabled = false;
            }
            
            chladniCtx.clearRect(0, 0, chladniCanvas.width, chladniCanvas.height);
            chladniCtx.fillStyle = '#f0f0f0';
            chladniCtx.fillRect(0, 0, chladniCanvas.width, chladniCanvas.height);
            
            document.getElementById('chladniN').value = 3;
            document.getElementById('chladniM').value = 4;
            document.getElementById('chladniEquation').value = 'classic';
            document.getElementById('chladniNValue').textContent = '3';
            document.getElementById('chladniMValue').textContent = '4';
            document.getElementById('chladniThreshold').value = 50;
            document.getElementById('chladniThresholdValue').textContent = '50';
            document.getElementById('chladniMode').textContent = '-';
            document.getElementById('chladniFreq').textContent = '-';
            document.getElementById('chladniStatus').textContent = 'Pronto';
            document.getElementById('chladniDraw').disabled = false;
            
            animationPhase = 0;
        }

        function exportChladniImage() {
            // Verifica se há algo desenhado
            const imageData = chladniCtx.getImageData(0, 0, chladniCanvas.width, chladniCanvas.height);
            const data = imageData.data;
            let hasContent = false;
            
            // Verifica se o canvas não está vazio (não é só cinza)
            for (let i = 0; i < data.length; i += 4) {
                if (data[i] !== 240 || data[i + 1] !== 240 || data[i + 2] !== 240) {
                    hasContent = true;
                    break;
                }
            }
            
            if (!hasContent) {
                alert('Desenhe um padrão primeiro antes de exportar!');
                return;
            }
            
            // Cria nome do arquivo com informações do padrão
            const n = document.getElementById('chladniN').value;
            const m = document.getElementById('chladniM').value;
            const equation = document.getElementById('chladniEquation').value;
            const colorScheme = document.getElementById('chladniColors').value;
            const timestamp = new Date().toISOString().slice(0, 10);
            
            const filename = `chladni_${equation}_n${n}_m${m}_${colorScheme}_${timestamp}.png`;
            
            // Converte canvas para blob e faz download
            chladniCanvas.toBlob((blob) => {
                // Cria URL temporária
                const url = URL.createObjectURL(blob);
                
                // Cria elemento <a> temporário para download
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                
                // Simula clique para iniciar download
                document.body.appendChild(link);
                link.click();
                
                // Limpa
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                // Feedback visual
                const statusEl = document.getElementById('chladniStatus');
                const oldText = statusEl.textContent;
                statusEl.textContent = 'Imagem exportada!';
                statusEl.style.color = '#4CAF50';
                
                setTimeout(() => {
                    statusEl.textContent = oldText;
                    statusEl.style.color = '';
                }, 2000);
            }, 'image/png');
        }

        // Event listeners
        document.getElementById('chladniN').addEventListener('input', (e) => {
            document.getElementById('chladniNValue').textContent = e.target.value;
        });

        document.getElementById('chladniM').addEventListener('input', (e) => {
            document.getElementById('chladniMValue').textContent = e.target.value;
        });

        document.getElementById('chladniResolution').addEventListener('input', (e) => {
            document.getElementById('chladniResolutionValue').textContent = e.target.value;
        });

        document.getElementById('chladniThreshold').addEventListener('input', (e) => {
            document.getElementById('chladniThresholdValue').textContent = e.target.value;
        });

        document.getElementById('chladniColors').addEventListener('change', () => {
            if (!chladniAnimating) {
                drawChladni();
            }
        });

        document.getElementById('chladniEquation').addEventListener('change', () => {
            if (!chladniAnimating) {
                drawChladni();
            }
        });

        // Inicializa
        chladniCtx.fillStyle = '#f0f0f0';
        chladniCtx.fillRect(0, 0, chladniCanvas.width, chladniCanvas.height);

        // Initialize all algorithms
        generateBubbleArray();
        generateBinaryArray();
        initDijkstraGrid();
        initQueensBoard();
        generateQuickArray();
        initMazeGrid();
        generateConvexPoints();
        initFloodGrid();
        generateVoronoiSeeds();
        generateBFSGraph();
        initGameOfLife();
        initWFC();
        drawMandelbrot();
        drawJulia();
        initRegression();
        generateRegressionData();
        resetLSystem();
        drawLSystem();
        initKNN();
        initSudoku();
        initSieve();
    </script>
</body>
</html>